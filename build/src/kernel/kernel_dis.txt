
D:/linux_kernel/dmos/build/src/kernel/kernel.elf:     file format elf32-i386
D:/linux_kernel/dmos/build/src/kernel/kernel.elf
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010000

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00004024 memsz 0x00004024 flags r-x
    LOAD off    0x00006000 vaddr 0x00015000 paddr 0x00015000 align 2**12
         filesz 0x00000060 memsz 0x000271e0 flags rw-
    LOAD off    0x00007000 vaddr 0x80000000 paddr 0x0003c1e0 align 2**12
         filesz 0x00000234 memsz 0x00000234 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003b37  00010000  00010000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000004ec  00013b38  00013b38  00004b38  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00000060  00015000  00015000  00006000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          000261e0  00016000  00016000  00006060  2**12
                  ALLOC
  4 .first_task   00000234  80000000  0003c1e0  00007000  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  5 .debug_line   00001824  00000000  00000000  00007234  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000059bb  00000000  00000000  00008a58  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016b0  00000000  00000000  0000e413  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000220  00000000  00000000  0000fac8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000013d0  00000000  00000000  0000fce8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      00000011  00000000  00000000  000110b8  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00001788  00000000  00000000  000110cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000090  00000000  00000000  00012854  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00010000 l    d  .text	00000000 .text
00013b38 l    d  .rodata	00000000 .rodata
00015000 l    d  .data	00000000 .data
00016000 l    d  .bss	00000000 .bss
80000000 l    d  .first_task	00000000 .first_task
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 src/kernel/CMakeFiles/kernel.dir/kernel.S.obj
00010010 l       .text	00000000 gdt_reload
00000000 l    df *ABS*	00000000 mtime.c
000102d9 l     F .text	0000001f outb
00016000 l     O .bss	00000004 sys_tick
00010320 l     F .text	00000061 pit_init
00000000 l    df *ABS*	00000000 fs.c
00010399 l     F .text	0000001d inb
000103b6 l     F .text	0000001f inw
000103d5 l     F .text	0000001f outb
00016020 l     O .bss	00019000 TEMP_ADDR
0002f020 l     O .bss	00000004 temp_pos
000103f4 l     F .text	0000012f read_disk
00000000 l    df *ABS*	00000000 gdt.c
000105c9 l     F .text	00000028 lgdt
0002f040 l     O .bss	00000800 g_gdt_table
0002f840 l     O .bss	00000014 g_mutex
00000000 l    df *ABS*	00000000 init.c
000107c0 l     F .text	0000000b list_count
000107cb l     F .text	0000000a list_first
000107d5 l     F .text	0000000b list_last
00000000 l    df *ABS*	00000000 irq.c
00010a8a l     F .text	00000007 hlt
00010a91 l     F .text	00000007 cli
00010a98 l     F .text	00000007 sti
00010a9f l     F .text	00000028 lidt
00010ac7 l     F .text	0000001d inb
00010ae4 l     F .text	0000001f outb
00010b03 l     F .text	00000011 read_cr2
00010b14 l     F .text	00000010 read_eflags
00010b24 l     F .text	0000000b write_eflags
0002f860 l     O .bss	00000400 idt_table
00010b2f l     F .text	00000030 default_handler
00010eb0 l     F .text	00000093 init_pic
00000000 l    df *ABS*	00000000 bitmap.c
00000000 l    df *ABS*	00000000 klib.c
00015000 l     O .data	00000004 num2ch.1850
00000000 l    df *ABS*	00000000 list.c
00011980 l     F .text	00000013 list_is_empty
00000000 l    df *ABS*	00000000 log.c
00011b79 l     F .text	0000001d inb
00011b96 l     F .text	0000001f outb
0002fc60 l     O .bss	00000014 mutex
00000000 l    df *ABS*	00000000 mem.c
00011d30 l     F .text	0000000d down2
00011d3d l     F .text	00000017 up2
00011d54 l     F .text	0000000c write_cr3
00011d60 l     F .text	00000011 mmu_set_page_dir
00011d71 l     F .text	00000014 pde_index
00011d85 l     F .text	00000027 pde_paddr
00011dac l     F .text	00000010 pte_index
00011dbc l     F .text	00000027 pte_paddr
00011de3 l     F .text	0000000f get_pte_perm
00030000 l     O .bss	00000028 g_paddr_alloc
00031000 l     O .bss	00001000 g_kernel_page_dir
00011df2 l     F .text	00000058 addr_alloc_init
00011e4a l     F .text	00000067 addr_alloc_page
00011eb1 l     F .text	00000062 addr_free_page
00011f13 l     F .text	000000ad some_test
00011fc0 l     F .text	00000066 show_mem_info
00012026 l     F .text	00000037 total_mem_size
00015020 l     O .data	00000040 kernel_map.2296
000124cc l     F .text	00000010 curr_page_dir
00000000 l    df *ABS*	00000000 mutex.c
0001286e l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 sem.c
000129f8 l     F .text	0000000b list_count
00000000 l    df *ABS*	00000000 syscall.c
00013f7c l     O .rodata	00000018 sys_table
00000000 l    df *ABS*	00000000 task.c
00012beb l     F .text	00000007 hlt
00012bf2 l     F .text	0000000c write_cr3
00012bfe l     F .text	0000001a far_jump
00012c18 l     F .text	00000017 write_tr
00012c2f l     F .text	0000001b list_node_init
00012c4a l     F .text	0000000b list_node_next
00012c55 l     F .text	0000000b list_count
00012c60 l     F .text	0000000a list_first
00012c6a l     F .text	00000011 mmu_set_page_dir
00032000 l     O .bss	000001b0 g_task_manager
000321c0 l     O .bss	00002000 idle_task_stack
000341c0 l     O .bss	00006000 g_task_table
0003a1c0 l     O .bss	00000014 task_table_mutex
00012c7b l     F .text	0000000a idle_task_func
00012c9f l     F .text	00000156 tss_init
000133b2 l     F .text	0000006c alloc_task
0001341e l     F .text	00000030 free_task
0001344e l     F .text	00000080 task_uninit
00013645 l     F .text	000000fe load_phdr
00013743 l     F .text	0000015e load_elf_file
000138a1 l     F .text	000000e5 copy_args
00000000 l    df *ABS*	00000000 first_task.c
80000010 l     F .first_task	0000004e sys_call
8000005e l     F .first_task	0000002a msleep
80000088 l     F .first_task	0000001b getpid
800000a3 l     F .first_task	00000028 print_msg
800000cb l     F .first_task	0000001b fork
800000e6 l     F .first_task	0000002d execve
000112ad g     F .text	0000003a bitmap_get_bit
000105bf g     F .text	0000000a sys_close
000130a1 g     F .text	0000000a task_current
0001121b g     F .text	00000018 irq_enter_proection
00011af4 g     F .text	00000085 list_delete
000111e5 g     F .text	0000000b irq_enable_global
00011a17 g     F .text	00000064 list_insert_last
0001310b g     F .text	00000061 sys_yield
000130ab g     F .text	00000035 task_set_ready
000112e7 g     F .text	0000001b bitmap_is_set
000105a0 g     F .text	0000001f sys_lseek
00010beb g     F .text	0000001c handle_overflow
00010267 g       .text	00000000 exception_handler_virtual_exception
00012b56 g     F .text	00000095 do_handler_syscall
00011489 g     F .text	0000002d strings_count
00010e1d g     F .text	0000001c handle_virtual_exception
00011bb5 g     F .text	0000009d log_init
000134ce g     F .text	00000177 sys_fork
00010a58 g     F .text	00000032 init_main
0001020c g       .text	00000000 exception_handler_alignment_check
00010787 g     F .text	00000039 gdt_free_sel
00012b3c g     F .text	0000001a sys_print_msg
00015000 g       .data	00000000 s_data
000115b3 g     F .text	0000007a k_strncmp
00010c93 g     F .text	0000001c handle_segment_not_present
000110c8 g     F .text	0000008b irq_enable
00010028 g       .text	00000000 exception_handler_unknown
00010b97 g     F .text	0000001c handle_Debug
000100a4 g       .text	00000000 exception_handler_breakpoint
0001210d g     F .text	00000080 memory_create_map
0001055c g     F .text	0000003a sys_read
000101b3 g       .text	00000000 exception_handler_general_protection
00012b13 g     F .text	00000029 sem_count
80000113 g     F .first_task	000000b4 first_task_main
00011302 g     F .text	000000d4 bitmap_set_bit
00010ce7 g     F .text	000000c6 handle_page_fault
0001013f g       .text	00000000 exception_handler_double_fault
000111f0 g     F .text	0000002b pic_send_eoi
00010000 g       .text	00000000 s_text
00012317 g     F .text	00000085 memory_create_uvm
00012a26 g     F .text	0000006b sem_wait
00012485 g     F .text	00000027 memory_alloc_page_for
000114fc g     F .text	00000047 k_strcpy
00011543 g     F .text	00000070 k_strncpy
00010196 g       .text	00000000 exception_handler_stack_segment_fault
80000000 g       .first_task	00000000 first_task_entry
00010677 g     F .text	0000009b gdt_init
000100c3 g       .text	00000000 exception_handler_overflow
000102a5 g       .text	00000000 simple_switch
00010286 g       .text	00000000 exception_handler_time
0003a1e0 g     O .bss	00002000 stack
000132e9 g     F .text	00000058 sys_sleep
000124dc g     F .text	0000008d memory_free_page
00010850 g     F .text	00000163 list_test
0003c1e0 g       *ABS*	00000000 s_first_task
00010c23 g     F .text	0000001c handle_invalid_opcode
0001162d g     F .text	0000003b k_strlen
000116f8 g     F .text	00000064 k_memcmp
0001239c g     F .text	000000e9 memory_alloc_for_page_dir
000100e2 g       .text	00000000 exception_handler_bound_range
00012a91 g     F .text	00000082 sem_notify
00013097 g     F .text	0000000a get_first_task
000127eb g     F .text	00000083 memory_copy_uvm_data
0001015c g       .text	00000000 exception_handler_invalid_tss
00011833 g     F .text	0000014d k_vsprint
00010523 g     F .text	00000039 sys_open
000119b8 g     F .text	0000005f list_insert_first
0001337c g     F .text	00000020 task_set_wakeup
00012fec g     F .text	000000ab first_task_init
00010047 g       .text	00000000 exception_handler_divider
00010dad g     F .text	0000001c handle_fpu_error
000111da g     F .text	0000000b irq_disable_global
00010596 g     F .text	0000000a sys_write
000125af g     F .text	000000e7 memory_destory_uvm
0003c414 g       *ABS*	00000000 mem_free_start
00010b5f g     F .text	0000001c handle_unknown
000107e0 g     F .text	0000002b kernel_init
000116b7 g     F .text	00000041 k_memset
00012a03 g     F .text	00000023 sem_init
00010000 g       .text	00000000 _start
000114b6 g     F .text	00000046 get_file_name
00010120 g       .text	00000000 exception_handler_device_unavailable
00010101 g       .text	00000000 exception_handler_invalid_opcode
0001080b g     F .text	00000045 show_list
0003c1e0 g       .bss	00000000 e_data
000128a7 g     F .text	00000094 mutex_lock
00010229 g       .text	00000000 exception_handler_machine_check
00000000 g       *ABS*	00000000 kernel_base
0003c414 g       *ABS*	00000000 e_first_task
00013341 g     F .text	0000003b task_set_sleep
00010e80 g     F .text	00000030 irq_install
00010e01 g     F .text	0000001c handle_smd_exception
00012879 g     F .text	0000002e mutex_init
00011153 g     F .text	00000087 irq_disable
00010ccb g     F .text	0000001c handle_general_protection
00010248 g       .text	00000000 exception_handler_smd_exception
00011233 g     F .text	00000011 irq_leave_proection
00011244 g     F .text	00000016 bitmap_byte_count
00010dc9 g     F .text	0000001c handle_alignment_check
000131af g     F .text	0000005c task_dispatch
00012696 g     F .text	00000155 memory_copy_uvm
00010a13 g     F .text	00000045 move_to_first_task
00010de5 g     F .text	0000001c handle_machine_check
0001316c g     F .text	00000043 task_next_run
0001218d g     F .text	0000009b create_kernel_table
00011993 g     F .text	00000025 list_init
00010caf g     F .text	0000001c handle_stack_segment_fault
000101d0 g       .text	00000000 exception_handler_page_fault
000130e0 g     F .text	0000002b task_set_block
00010c07 g     F .text	0000001c handle_bound_range
000124ac g     F .text	00000020 memory_alloc_page
000101ed g       .text	00000000 exception_handler_fpu_error
00012c85 g     F .text	0000001a task_switch_from_to
00010f43 g     F .text	00000185 irq_init
0001175c g     F .text	000000d7 k_itoa
0001293b g     F .text	000000bd mutex_unlock
00010c5b g     F .text	0000001c handle_double_fault
000102f8 g     F .text	00000028 handle_time
000102bb g       .text	00000000 exception_handle_syscall
000105f1 g     F .text	00000086 segment_desc_set
000109b3 g     F .text	00000060 offset_test
00014024 g       .rodata	00000000 e_text
00010bcf g     F .text	0000001c handle_breakpoint
0001125a g     F .text	00000053 bitmap_init
00010179 g       .text	00000000 exception_handler_segment_not_present
00010085 g       .text	00000000 exception_handler_NMI
000113d6 g     F .text	000000b3 bitmap_alloc_nbits
00012f07 g     F .text	000000e5 task_manager_init
00012eda g     F .text	0000002d task_start
00010066 g       .text	00000000 exception_handler_Debug
0001320b g     F .text	000000de task_time_tick
00012228 g     F .text	000000ef memory_init
00013986 g     F .text	000001b1 sys_execve
00012569 g     F .text	00000046 memory_get_paddr
00010c3f g     F .text	0000001c handle_device_unavailable
00010b7b g     F .text	0000001c handle_divider
00011668 g     F .text	0000004f k_memcpy
00012df5 g     F .text	000000e5 task_init
0001339c g     F .text	00000016 sys_getpid
00010712 g     F .text	00000075 gdt_alloc_desc
00011a7b g     F .text	00000079 list_delete_first
00010e39 g     F .text	00000047 gate_desc_set
00011c52 g     F .text	000000de klog
00010bb3 g     F .text	0000001c handle_NMI
00010c77 g     F .text	0000001c handle_invalid_tss
0001205d g     F .text	000000b0 find_pte
00010381 g     F .text	00000018 time_init



Disassembly of section .text:

00010000 <_start>:
    # 第二种方法
    # mov 4(%esp), %eax
    # push %eax

    # 第三种方法
    push 4(%esp)
   10000:	ff 74 24 04          	pushl  0x4(%esp)

    # kernel_init(boot_info)
    call kernel_init
   10004:	e8 d7 07 00 00       	call   107e0 <kernel_init>

	// 重新加载GDT
	jmp $KERNEL_SELECTOR_CS, $gdt_reload
   10009:	ea 10 00 01 00 08 00 	ljmp   $0x8,$0x10010

00010010 <gdt_reload>:

gdt_reload:
	mov $KERNEL_SELECTOR_DS, %ax		// 16为数据段选择子
   10010:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
   10014:	8e d8                	mov    %eax,%ds
    mov %ax, %ss
   10016:	8e d0                	mov    %eax,%ss
    mov %ax, %es
   10018:	8e c0                	mov    %eax,%es
    mov %ax, %fs
   1001a:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
   1001c:	8e e8                	mov    %eax,%gs

	// 栈设置
	mov $(stack + KERNEL_STACK_SIZE), %esp
   1001e:	bc e0 c1 03 00       	mov    $0x3c1e0,%esp

	// 栈和段等沿用之前的设置
	jmp init_main
   10023:	e9 30 0a 00 00       	jmp    10a58 <init_main>

00010028 <exception_handler_unknown>:
    add $(2*4), %esp    # 跳过 with_error_code num
    iret                # 中断返回

.endm

exception_handler unknown, -1, 0
   10028:	6a 00                	push   $0x0
   1002a:	6a ff                	push   $0xffffffff
   1002c:	60                   	pusha  
   1002d:	1e                   	push   %ds
   1002e:	06                   	push   %es
   1002f:	0f a0                	push   %fs
   10031:	0f a8                	push   %gs
   10033:	54                   	push   %esp
   10034:	e8 26 0b 00 00       	call   10b5f <handle_unknown>
   10039:	83 c4 04             	add    $0x4,%esp
   1003c:	0f a9                	pop    %gs
   1003e:	0f a1                	pop    %fs
   10040:	07                   	pop    %es
   10041:	1f                   	pop    %ds
   10042:	61                   	popa   
   10043:	83 c4 08             	add    $0x8,%esp
   10046:	cf                   	iret   

00010047 <exception_handler_divider>:
exception_handler divider, 0, 0
   10047:	6a 00                	push   $0x0
   10049:	6a 00                	push   $0x0
   1004b:	60                   	pusha  
   1004c:	1e                   	push   %ds
   1004d:	06                   	push   %es
   1004e:	0f a0                	push   %fs
   10050:	0f a8                	push   %gs
   10052:	54                   	push   %esp
   10053:	e8 23 0b 00 00       	call   10b7b <handle_divider>
   10058:	83 c4 04             	add    $0x4,%esp
   1005b:	0f a9                	pop    %gs
   1005d:	0f a1                	pop    %fs
   1005f:	07                   	pop    %es
   10060:	1f                   	pop    %ds
   10061:	61                   	popa   
   10062:	83 c4 08             	add    $0x8,%esp
   10065:	cf                   	iret   

00010066 <exception_handler_Debug>:
exception_handler Debug, 1, 0
   10066:	6a 00                	push   $0x0
   10068:	6a 01                	push   $0x1
   1006a:	60                   	pusha  
   1006b:	1e                   	push   %ds
   1006c:	06                   	push   %es
   1006d:	0f a0                	push   %fs
   1006f:	0f a8                	push   %gs
   10071:	54                   	push   %esp
   10072:	e8 20 0b 00 00       	call   10b97 <handle_Debug>
   10077:	83 c4 04             	add    $0x4,%esp
   1007a:	0f a9                	pop    %gs
   1007c:	0f a1                	pop    %fs
   1007e:	07                   	pop    %es
   1007f:	1f                   	pop    %ds
   10080:	61                   	popa   
   10081:	83 c4 08             	add    $0x8,%esp
   10084:	cf                   	iret   

00010085 <exception_handler_NMI>:
exception_handler NMI, 2, 0
   10085:	6a 00                	push   $0x0
   10087:	6a 02                	push   $0x2
   10089:	60                   	pusha  
   1008a:	1e                   	push   %ds
   1008b:	06                   	push   %es
   1008c:	0f a0                	push   %fs
   1008e:	0f a8                	push   %gs
   10090:	54                   	push   %esp
   10091:	e8 1d 0b 00 00       	call   10bb3 <handle_NMI>
   10096:	83 c4 04             	add    $0x4,%esp
   10099:	0f a9                	pop    %gs
   1009b:	0f a1                	pop    %fs
   1009d:	07                   	pop    %es
   1009e:	1f                   	pop    %ds
   1009f:	61                   	popa   
   100a0:	83 c4 08             	add    $0x8,%esp
   100a3:	cf                   	iret   

000100a4 <exception_handler_breakpoint>:
exception_handler breakpoint, 3, 0
   100a4:	6a 00                	push   $0x0
   100a6:	6a 03                	push   $0x3
   100a8:	60                   	pusha  
   100a9:	1e                   	push   %ds
   100aa:	06                   	push   %es
   100ab:	0f a0                	push   %fs
   100ad:	0f a8                	push   %gs
   100af:	54                   	push   %esp
   100b0:	e8 1a 0b 00 00       	call   10bcf <handle_breakpoint>
   100b5:	83 c4 04             	add    $0x4,%esp
   100b8:	0f a9                	pop    %gs
   100ba:	0f a1                	pop    %fs
   100bc:	07                   	pop    %es
   100bd:	1f                   	pop    %ds
   100be:	61                   	popa   
   100bf:	83 c4 08             	add    $0x8,%esp
   100c2:	cf                   	iret   

000100c3 <exception_handler_overflow>:
exception_handler overflow, 4, 0
   100c3:	6a 00                	push   $0x0
   100c5:	6a 04                	push   $0x4
   100c7:	60                   	pusha  
   100c8:	1e                   	push   %ds
   100c9:	06                   	push   %es
   100ca:	0f a0                	push   %fs
   100cc:	0f a8                	push   %gs
   100ce:	54                   	push   %esp
   100cf:	e8 17 0b 00 00       	call   10beb <handle_overflow>
   100d4:	83 c4 04             	add    $0x4,%esp
   100d7:	0f a9                	pop    %gs
   100d9:	0f a1                	pop    %fs
   100db:	07                   	pop    %es
   100dc:	1f                   	pop    %ds
   100dd:	61                   	popa   
   100de:	83 c4 08             	add    $0x8,%esp
   100e1:	cf                   	iret   

000100e2 <exception_handler_bound_range>:
exception_handler bound_range, 5, 0
   100e2:	6a 00                	push   $0x0
   100e4:	6a 05                	push   $0x5
   100e6:	60                   	pusha  
   100e7:	1e                   	push   %ds
   100e8:	06                   	push   %es
   100e9:	0f a0                	push   %fs
   100eb:	0f a8                	push   %gs
   100ed:	54                   	push   %esp
   100ee:	e8 14 0b 00 00       	call   10c07 <handle_bound_range>
   100f3:	83 c4 04             	add    $0x4,%esp
   100f6:	0f a9                	pop    %gs
   100f8:	0f a1                	pop    %fs
   100fa:	07                   	pop    %es
   100fb:	1f                   	pop    %ds
   100fc:	61                   	popa   
   100fd:	83 c4 08             	add    $0x8,%esp
   10100:	cf                   	iret   

00010101 <exception_handler_invalid_opcode>:
exception_handler invalid_opcode, 6, 0
   10101:	6a 00                	push   $0x0
   10103:	6a 06                	push   $0x6
   10105:	60                   	pusha  
   10106:	1e                   	push   %ds
   10107:	06                   	push   %es
   10108:	0f a0                	push   %fs
   1010a:	0f a8                	push   %gs
   1010c:	54                   	push   %esp
   1010d:	e8 11 0b 00 00       	call   10c23 <handle_invalid_opcode>
   10112:	83 c4 04             	add    $0x4,%esp
   10115:	0f a9                	pop    %gs
   10117:	0f a1                	pop    %fs
   10119:	07                   	pop    %es
   1011a:	1f                   	pop    %ds
   1011b:	61                   	popa   
   1011c:	83 c4 08             	add    $0x8,%esp
   1011f:	cf                   	iret   

00010120 <exception_handler_device_unavailable>:
exception_handler device_unavailable, 7, 0
   10120:	6a 00                	push   $0x0
   10122:	6a 07                	push   $0x7
   10124:	60                   	pusha  
   10125:	1e                   	push   %ds
   10126:	06                   	push   %es
   10127:	0f a0                	push   %fs
   10129:	0f a8                	push   %gs
   1012b:	54                   	push   %esp
   1012c:	e8 0e 0b 00 00       	call   10c3f <handle_device_unavailable>
   10131:	83 c4 04             	add    $0x4,%esp
   10134:	0f a9                	pop    %gs
   10136:	0f a1                	pop    %fs
   10138:	07                   	pop    %es
   10139:	1f                   	pop    %ds
   1013a:	61                   	popa   
   1013b:	83 c4 08             	add    $0x8,%esp
   1013e:	cf                   	iret   

0001013f <exception_handler_double_fault>:
exception_handler double_fault, 8, 1
   1013f:	6a 08                	push   $0x8
   10141:	60                   	pusha  
   10142:	1e                   	push   %ds
   10143:	06                   	push   %es
   10144:	0f a0                	push   %fs
   10146:	0f a8                	push   %gs
   10148:	54                   	push   %esp
   10149:	e8 0d 0b 00 00       	call   10c5b <handle_double_fault>
   1014e:	83 c4 04             	add    $0x4,%esp
   10151:	0f a9                	pop    %gs
   10153:	0f a1                	pop    %fs
   10155:	07                   	pop    %es
   10156:	1f                   	pop    %ds
   10157:	61                   	popa   
   10158:	83 c4 08             	add    $0x8,%esp
   1015b:	cf                   	iret   

0001015c <exception_handler_invalid_tss>:
exception_handler invalid_tss, 10, 1
   1015c:	6a 0a                	push   $0xa
   1015e:	60                   	pusha  
   1015f:	1e                   	push   %ds
   10160:	06                   	push   %es
   10161:	0f a0                	push   %fs
   10163:	0f a8                	push   %gs
   10165:	54                   	push   %esp
   10166:	e8 0c 0b 00 00       	call   10c77 <handle_invalid_tss>
   1016b:	83 c4 04             	add    $0x4,%esp
   1016e:	0f a9                	pop    %gs
   10170:	0f a1                	pop    %fs
   10172:	07                   	pop    %es
   10173:	1f                   	pop    %ds
   10174:	61                   	popa   
   10175:	83 c4 08             	add    $0x8,%esp
   10178:	cf                   	iret   

00010179 <exception_handler_segment_not_present>:
exception_handler segment_not_present, 11, 1
   10179:	6a 0b                	push   $0xb
   1017b:	60                   	pusha  
   1017c:	1e                   	push   %ds
   1017d:	06                   	push   %es
   1017e:	0f a0                	push   %fs
   10180:	0f a8                	push   %gs
   10182:	54                   	push   %esp
   10183:	e8 0b 0b 00 00       	call   10c93 <handle_segment_not_present>
   10188:	83 c4 04             	add    $0x4,%esp
   1018b:	0f a9                	pop    %gs
   1018d:	0f a1                	pop    %fs
   1018f:	07                   	pop    %es
   10190:	1f                   	pop    %ds
   10191:	61                   	popa   
   10192:	83 c4 08             	add    $0x8,%esp
   10195:	cf                   	iret   

00010196 <exception_handler_stack_segment_fault>:
exception_handler stack_segment_fault, 12, 1
   10196:	6a 0c                	push   $0xc
   10198:	60                   	pusha  
   10199:	1e                   	push   %ds
   1019a:	06                   	push   %es
   1019b:	0f a0                	push   %fs
   1019d:	0f a8                	push   %gs
   1019f:	54                   	push   %esp
   101a0:	e8 0a 0b 00 00       	call   10caf <handle_stack_segment_fault>
   101a5:	83 c4 04             	add    $0x4,%esp
   101a8:	0f a9                	pop    %gs
   101aa:	0f a1                	pop    %fs
   101ac:	07                   	pop    %es
   101ad:	1f                   	pop    %ds
   101ae:	61                   	popa   
   101af:	83 c4 08             	add    $0x8,%esp
   101b2:	cf                   	iret   

000101b3 <exception_handler_general_protection>:
exception_handler general_protection, 13, 1
   101b3:	6a 0d                	push   $0xd
   101b5:	60                   	pusha  
   101b6:	1e                   	push   %ds
   101b7:	06                   	push   %es
   101b8:	0f a0                	push   %fs
   101ba:	0f a8                	push   %gs
   101bc:	54                   	push   %esp
   101bd:	e8 09 0b 00 00       	call   10ccb <handle_general_protection>
   101c2:	83 c4 04             	add    $0x4,%esp
   101c5:	0f a9                	pop    %gs
   101c7:	0f a1                	pop    %fs
   101c9:	07                   	pop    %es
   101ca:	1f                   	pop    %ds
   101cb:	61                   	popa   
   101cc:	83 c4 08             	add    $0x8,%esp
   101cf:	cf                   	iret   

000101d0 <exception_handler_page_fault>:
exception_handler page_fault, 14, 1
   101d0:	6a 0e                	push   $0xe
   101d2:	60                   	pusha  
   101d3:	1e                   	push   %ds
   101d4:	06                   	push   %es
   101d5:	0f a0                	push   %fs
   101d7:	0f a8                	push   %gs
   101d9:	54                   	push   %esp
   101da:	e8 08 0b 00 00       	call   10ce7 <handle_page_fault>
   101df:	83 c4 04             	add    $0x4,%esp
   101e2:	0f a9                	pop    %gs
   101e4:	0f a1                	pop    %fs
   101e6:	07                   	pop    %es
   101e7:	1f                   	pop    %ds
   101e8:	61                   	popa   
   101e9:	83 c4 08             	add    $0x8,%esp
   101ec:	cf                   	iret   

000101ed <exception_handler_fpu_error>:
exception_handler fpu_error, 16, 0
   101ed:	6a 00                	push   $0x0
   101ef:	6a 10                	push   $0x10
   101f1:	60                   	pusha  
   101f2:	1e                   	push   %ds
   101f3:	06                   	push   %es
   101f4:	0f a0                	push   %fs
   101f6:	0f a8                	push   %gs
   101f8:	54                   	push   %esp
   101f9:	e8 af 0b 00 00       	call   10dad <handle_fpu_error>
   101fe:	83 c4 04             	add    $0x4,%esp
   10201:	0f a9                	pop    %gs
   10203:	0f a1                	pop    %fs
   10205:	07                   	pop    %es
   10206:	1f                   	pop    %ds
   10207:	61                   	popa   
   10208:	83 c4 08             	add    $0x8,%esp
   1020b:	cf                   	iret   

0001020c <exception_handler_alignment_check>:
exception_handler alignment_check, 17, 1
   1020c:	6a 11                	push   $0x11
   1020e:	60                   	pusha  
   1020f:	1e                   	push   %ds
   10210:	06                   	push   %es
   10211:	0f a0                	push   %fs
   10213:	0f a8                	push   %gs
   10215:	54                   	push   %esp
   10216:	e8 ae 0b 00 00       	call   10dc9 <handle_alignment_check>
   1021b:	83 c4 04             	add    $0x4,%esp
   1021e:	0f a9                	pop    %gs
   10220:	0f a1                	pop    %fs
   10222:	07                   	pop    %es
   10223:	1f                   	pop    %ds
   10224:	61                   	popa   
   10225:	83 c4 08             	add    $0x8,%esp
   10228:	cf                   	iret   

00010229 <exception_handler_machine_check>:
exception_handler machine_check, 18, 0
   10229:	6a 00                	push   $0x0
   1022b:	6a 12                	push   $0x12
   1022d:	60                   	pusha  
   1022e:	1e                   	push   %ds
   1022f:	06                   	push   %es
   10230:	0f a0                	push   %fs
   10232:	0f a8                	push   %gs
   10234:	54                   	push   %esp
   10235:	e8 ab 0b 00 00       	call   10de5 <handle_machine_check>
   1023a:	83 c4 04             	add    $0x4,%esp
   1023d:	0f a9                	pop    %gs
   1023f:	0f a1                	pop    %fs
   10241:	07                   	pop    %es
   10242:	1f                   	pop    %ds
   10243:	61                   	popa   
   10244:	83 c4 08             	add    $0x8,%esp
   10247:	cf                   	iret   

00010248 <exception_handler_smd_exception>:
exception_handler smd_exception, 19, 0
   10248:	6a 00                	push   $0x0
   1024a:	6a 13                	push   $0x13
   1024c:	60                   	pusha  
   1024d:	1e                   	push   %ds
   1024e:	06                   	push   %es
   1024f:	0f a0                	push   %fs
   10251:	0f a8                	push   %gs
   10253:	54                   	push   %esp
   10254:	e8 a8 0b 00 00       	call   10e01 <handle_smd_exception>
   10259:	83 c4 04             	add    $0x4,%esp
   1025c:	0f a9                	pop    %gs
   1025e:	0f a1                	pop    %fs
   10260:	07                   	pop    %es
   10261:	1f                   	pop    %ds
   10262:	61                   	popa   
   10263:	83 c4 08             	add    $0x8,%esp
   10266:	cf                   	iret   

00010267 <exception_handler_virtual_exception>:
exception_handler virtual_exception, 20, 0
   10267:	6a 00                	push   $0x0
   10269:	6a 14                	push   $0x14
   1026b:	60                   	pusha  
   1026c:	1e                   	push   %ds
   1026d:	06                   	push   %es
   1026e:	0f a0                	push   %fs
   10270:	0f a8                	push   %gs
   10272:	54                   	push   %esp
   10273:	e8 a5 0b 00 00       	call   10e1d <handle_virtual_exception>
   10278:	83 c4 04             	add    $0x4,%esp
   1027b:	0f a9                	pop    %gs
   1027d:	0f a1                	pop    %fs
   1027f:	07                   	pop    %es
   10280:	1f                   	pop    %ds
   10281:	61                   	popa   
   10282:	83 c4 08             	add    $0x8,%esp
   10285:	cf                   	iret   

00010286 <exception_handler_time>:

exception_handler time, 0x20, 0
   10286:	6a 00                	push   $0x0
   10288:	6a 20                	push   $0x20
   1028a:	60                   	pusha  
   1028b:	1e                   	push   %ds
   1028c:	06                   	push   %es
   1028d:	0f a0                	push   %fs
   1028f:	0f a8                	push   %gs
   10291:	54                   	push   %esp
   10292:	e8 61 00 00 00       	call   102f8 <handle_time>
   10297:	83 c4 04             	add    $0x4,%esp
   1029a:	0f a9                	pop    %gs
   1029c:	0f a1                	pop    %fs
   1029e:	07                   	pop    %es
   1029f:	1f                   	pop    %ds
   102a0:	61                   	popa   
   102a1:	83 c4 08             	add    $0x8,%esp
   102a4:	cf                   	iret   

000102a5 <simple_switch>:
    // simple_switch(&from, &to)
.text
.global simple_switch

simple_switch:
    mov 4(%esp), %eax
   102a5:	8b 44 24 04          	mov    0x4(%esp),%eax
    mov 8(%esp), %edx
   102a9:	8b 54 24 08          	mov    0x8(%esp),%edx

    push %ebp
   102ad:	55                   	push   %ebp
    push %ebx
   102ae:	53                   	push   %ebx
    push %esi
   102af:	56                   	push   %esi
    push %edi
   102b0:	57                   	push   %edi
    mov %esp, (%eax)
   102b1:	89 20                	mov    %esp,(%eax)

    mov %edx, %esp
   102b3:	89 d4                	mov    %edx,%esp
    pop %edi
   102b5:	5f                   	pop    %edi
    pop %esi
   102b6:	5e                   	pop    %esi
    pop %ebx
   102b7:	5b                   	pop    %ebx
    pop %ebp
   102b8:	5d                   	pop    %ebp
    
    sti
   102b9:	fb                   	sti    
    ret
   102ba:	c3                   	ret    

000102bb <exception_handle_syscall>:

    .global exception_handle_syscall
    .extern do_handler_syscall
exception_handle_syscall:

    pusha
   102bb:	60                   	pusha  
    push %ds
   102bc:	1e                   	push   %ds
    push %es
   102bd:	06                   	push   %es
    push %fs
   102be:	0f a0                	push   %fs
    push %gs
   102c0:	0f a8                	push   %gs
    pushf
   102c2:	9c                   	pushf  

    mov %esp, %eax
   102c3:	89 e0                	mov    %esp,%eax
    push %eax
   102c5:	50                   	push   %eax
    call do_handler_syscall
   102c6:	e8 8b 28 00 00       	call   12b56 <do_handler_syscall>
    add $4, %esp
   102cb:	83 c4 04             	add    $0x4,%esp

    popf
   102ce:	9d                   	popf   
    pop %gs
   102cf:	0f a9                	pop    %gs
    pop %fs
   102d1:	0f a1                	pop    %fs
    pop %es
   102d3:	07                   	pop    %es
    pop %ds
   102d4:	1f                   	pop    %ds
    popa
   102d5:	61                   	popa   


   102d6:	ca 14 00             	lret   $0x14

000102d9 <outb>:
	uint16_t rv;
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
	return rv;
}

static inline void outb(uint16_t port, uint8_t data) {
   102d9:	55                   	push   %ebp
   102da:	89 e5                	mov    %esp,%ebp
   102dc:	83 ec 08             	sub    $0x8,%esp
   102df:	8b 55 08             	mov    0x8(%ebp),%edx
   102e2:	8b 45 0c             	mov    0xc(%ebp),%eax
   102e5:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   102e9:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   102ec:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   102f0:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   102f4:	ee                   	out    %al,(%dx)
}
   102f5:	90                   	nop
   102f6:	c9                   	leave  
   102f7:	c3                   	ret    

000102f8 <handle_time>:


static uint32_t sys_tick;

void exception_handler_time();
void handle_time(exception_frame_t * frame) {
   102f8:	55                   	push   %ebp
   102f9:	89 e5                	mov    %esp,%ebp
   102fb:	83 ec 08             	sub    $0x8,%esp
    sys_tick++;
   102fe:	a1 00 60 01 00       	mov    0x16000,%eax
   10303:	83 c0 01             	add    $0x1,%eax
   10306:	a3 00 60 01 00       	mov    %eax,0x16000
    pic_send_eoi(IRQ0_TIMER);
   1030b:	83 ec 0c             	sub    $0xc,%esp
   1030e:	6a 20                	push   $0x20
   10310:	e8 db 0e 00 00       	call   111f0 <pic_send_eoi>
   10315:	83 c4 10             	add    $0x10,%esp
    task_time_tick();
   10318:	e8 ee 2e 00 00       	call   1320b <task_time_tick>
} 
   1031d:	90                   	nop
   1031e:	c9                   	leave  
   1031f:	c3                   	ret    

00010320 <pit_init>:

static void pit_init (void) {
   10320:	55                   	push   %ebp
   10321:	89 e5                	mov    %esp,%ebp
   10323:	83 ec 18             	sub    $0x18,%esp
    uint32_t reload_count = PIT_OSC_FREQ / (1000.0 / OS_TICK_MS);
   10326:	c7 45 f4 9b 2e 00 00 	movl   $0x2e9b,-0xc(%ebp)
    outb(PIT_COMMAND_MODE_PORT, PIT_CHANNLE0 | PIT_LOAD_LOHI | PIT_MODE3);
   1032d:	6a 36                	push   $0x36
   1032f:	6a 43                	push   $0x43
   10331:	e8 a3 ff ff ff       	call   102d9 <outb>
   10336:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xFF);          // 加载低8位
   10339:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1033c:	0f b6 c0             	movzbl %al,%eax
   1033f:	50                   	push   %eax
   10340:	6a 40                	push   $0x40
   10342:	e8 92 ff ff ff       	call   102d9 <outb>
   10347:	83 c4 08             	add    $0x8,%esp
    outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xFF);   // 再加载高8位
   1034a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1034d:	c1 e8 08             	shr    $0x8,%eax
   10350:	0f b6 c0             	movzbl %al,%eax
   10353:	50                   	push   %eax
   10354:	6a 40                	push   $0x40
   10356:	e8 7e ff ff ff       	call   102d9 <outb>
   1035b:	83 c4 08             	add    $0x8,%esp
    irq_install(IRQ0_TIMER, (uint32_t)exception_handler_time);    
   1035e:	b8 86 02 01 00       	mov    $0x10286,%eax
   10363:	83 ec 08             	sub    $0x8,%esp
   10366:	50                   	push   %eax
   10367:	6a 20                	push   $0x20
   10369:	e8 12 0b 00 00       	call   10e80 <irq_install>
   1036e:	83 c4 10             	add    $0x10,%esp
    irq_enable(IRQ0_TIMER);
   10371:	83 ec 0c             	sub    $0xc,%esp
   10374:	6a 20                	push   $0x20
   10376:	e8 4d 0d 00 00       	call   110c8 <irq_enable>
   1037b:	83 c4 10             	add    $0x10,%esp
}
   1037e:	90                   	nop
   1037f:	c9                   	leave  
   10380:	c3                   	ret    

00010381 <time_init>:

void time_init() {
   10381:	55                   	push   %ebp
   10382:	89 e5                	mov    %esp,%ebp
   10384:	83 ec 08             	sub    $0x8,%esp
    sys_tick = 0;
   10387:	c7 05 00 60 01 00 00 	movl   $0x0,0x16000
   1038e:	00 00 00 

    pit_init();
   10391:	e8 8a ff ff ff       	call   10320 <pit_init>
   10396:	90                   	nop
   10397:	c9                   	leave  
   10398:	c3                   	ret    

00010399 <inb>:
static inline uint8_t inb(uint16_t  port) {
   10399:	55                   	push   %ebp
   1039a:	89 e5                	mov    %esp,%ebp
   1039c:	83 ec 14             	sub    $0x14,%esp
   1039f:	8b 45 08             	mov    0x8(%ebp),%eax
   103a2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   103a6:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   103aa:	89 c2                	mov    %eax,%edx
   103ac:	ec                   	in     (%dx),%al
   103ad:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   103b0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   103b4:	c9                   	leave  
   103b5:	c3                   	ret    

000103b6 <inw>:
static inline uint16_t inw(uint16_t  port) {
   103b6:	55                   	push   %ebp
   103b7:	89 e5                	mov    %esp,%ebp
   103b9:	83 ec 14             	sub    $0x14,%esp
   103bc:	8b 45 08             	mov    0x8(%ebp),%eax
   103bf:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("in %1, %0" : "=a" (rv) : "dN" (port));
   103c3:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   103c7:	89 c2                	mov    %eax,%edx
   103c9:	66 ed                	in     (%dx),%ax
   103cb:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	return rv;
   103cf:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
}
   103d3:	c9                   	leave  
   103d4:	c3                   	ret    

000103d5 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   103d5:	55                   	push   %ebp
   103d6:	89 e5                	mov    %esp,%ebp
   103d8:	83 ec 08             	sub    $0x8,%esp
   103db:	8b 55 08             	mov    0x8(%ebp),%edx
   103de:	8b 45 0c             	mov    0xc(%ebp),%eax
   103e1:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   103e5:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   103e8:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   103ec:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   103f0:	ee                   	out    %al,(%dx)
}
   103f1:	90                   	nop
   103f2:	c9                   	leave  
   103f3:	c3                   	ret    

000103f4 <read_disk>:

static uint8_t TEMP_ADDR[100*1024];
static uint8_t * temp_pos;
#define TEMP_FILE_ID    12

static void read_disk(int sector, int sector_count, uint8_t * buf) {
   103f4:	55                   	push   %ebp
   103f5:	89 e5                	mov    %esp,%ebp
   103f7:	53                   	push   %ebx
   103f8:	83 ec 10             	sub    $0x10,%esp
    outb(0x1F6, (uint8_t) (0xE0));
   103fb:	68 e0 00 00 00       	push   $0xe0
   10400:	68 f6 01 00 00       	push   $0x1f6
   10405:	e8 cb ff ff ff       	call   103d5 <outb>
   1040a:	83 c4 08             	add    $0x8,%esp

	outb(0x1F2, (uint8_t) (sector_count >> 8));
   1040d:	8b 45 0c             	mov    0xc(%ebp),%eax
   10410:	c1 f8 08             	sar    $0x8,%eax
   10413:	0f b6 c0             	movzbl %al,%eax
   10416:	50                   	push   %eax
   10417:	68 f2 01 00 00       	push   $0x1f2
   1041c:	e8 b4 ff ff ff       	call   103d5 <outb>
   10421:	83 c4 08             	add    $0x8,%esp
    outb(0x1F3, (uint8_t) (sector >> 24));		// LBA参数的24~31位
   10424:	8b 45 08             	mov    0x8(%ebp),%eax
   10427:	c1 f8 18             	sar    $0x18,%eax
   1042a:	0f b6 c0             	movzbl %al,%eax
   1042d:	50                   	push   %eax
   1042e:	68 f3 01 00 00       	push   $0x1f3
   10433:	e8 9d ff ff ff       	call   103d5 <outb>
   10438:	83 c4 08             	add    $0x8,%esp
    outb(0x1F4, (uint8_t) (0));					// LBA参数的32~39位
   1043b:	6a 00                	push   $0x0
   1043d:	68 f4 01 00 00       	push   $0x1f4
   10442:	e8 8e ff ff ff       	call   103d5 <outb>
   10447:	83 c4 08             	add    $0x8,%esp
    outb(0x1F5, (uint8_t) (0));					// LBA参数的40~47位
   1044a:	6a 00                	push   $0x0
   1044c:	68 f5 01 00 00       	push   $0x1f5
   10451:	e8 7f ff ff ff       	call   103d5 <outb>
   10456:	83 c4 08             	add    $0x8,%esp

    outb(0x1F2, (uint8_t) (sector_count));
   10459:	8b 45 0c             	mov    0xc(%ebp),%eax
   1045c:	0f b6 c0             	movzbl %al,%eax
   1045f:	50                   	push   %eax
   10460:	68 f2 01 00 00       	push   $0x1f2
   10465:	e8 6b ff ff ff       	call   103d5 <outb>
   1046a:	83 c4 08             	add    $0x8,%esp
	outb(0x1F3, (uint8_t) (sector));			// LBA参数的0~7位
   1046d:	8b 45 08             	mov    0x8(%ebp),%eax
   10470:	0f b6 c0             	movzbl %al,%eax
   10473:	50                   	push   %eax
   10474:	68 f3 01 00 00       	push   $0x1f3
   10479:	e8 57 ff ff ff       	call   103d5 <outb>
   1047e:	83 c4 08             	add    $0x8,%esp
	outb(0x1F4, (uint8_t) (sector >> 8));		// LBA参数的8~15位
   10481:	8b 45 08             	mov    0x8(%ebp),%eax
   10484:	c1 f8 08             	sar    $0x8,%eax
   10487:	0f b6 c0             	movzbl %al,%eax
   1048a:	50                   	push   %eax
   1048b:	68 f4 01 00 00       	push   $0x1f4
   10490:	e8 40 ff ff ff       	call   103d5 <outb>
   10495:	83 c4 08             	add    $0x8,%esp
	outb(0x1F5, (uint8_t) (sector >> 16));		// LBA参数的16~23位
   10498:	8b 45 08             	mov    0x8(%ebp),%eax
   1049b:	c1 f8 10             	sar    $0x10,%eax
   1049e:	0f b6 c0             	movzbl %al,%eax
   104a1:	50                   	push   %eax
   104a2:	68 f5 01 00 00       	push   $0x1f5
   104a7:	e8 29 ff ff ff       	call   103d5 <outb>
   104ac:	83 c4 08             	add    $0x8,%esp

	outb(0x1F7, (uint8_t) 0x24);
   104af:	6a 24                	push   $0x24
   104b1:	68 f7 01 00 00       	push   $0x1f7
   104b6:	e8 1a ff ff ff       	call   103d5 <outb>
   104bb:	83 c4 08             	add    $0x8,%esp

	uint16_t *data_buf = (uint16_t*) buf;
   104be:	8b 45 10             	mov    0x10(%ebp),%eax
   104c1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (sector_count-- > 0) {
   104c4:	eb 4a                	jmp    10510 <read_disk+0x11c>
		while ((inb(0x1F7) & 0x88) != 0x8) {}
   104c6:	90                   	nop
   104c7:	68 f7 01 00 00       	push   $0x1f7
   104cc:	e8 c8 fe ff ff       	call   10399 <inb>
   104d1:	83 c4 04             	add    $0x4,%esp
   104d4:	0f b6 c0             	movzbl %al,%eax
   104d7:	25 88 00 00 00       	and    $0x88,%eax
   104dc:	83 f8 08             	cmp    $0x8,%eax
   104df:	75 e6                	jne    104c7 <read_disk+0xd3>

		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   104e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   104e8:	eb 1d                	jmp    10507 <read_disk+0x113>
			*data_buf++ = inw(0x1F0);
   104ea:	8b 5d f8             	mov    -0x8(%ebp),%ebx
   104ed:	8d 43 02             	lea    0x2(%ebx),%eax
   104f0:	89 45 f8             	mov    %eax,-0x8(%ebp)
   104f3:	68 f0 01 00 00       	push   $0x1f0
   104f8:	e8 b9 fe ff ff       	call   103b6 <inw>
   104fd:	83 c4 04             	add    $0x4,%esp
   10500:	66 89 03             	mov    %ax,(%ebx)
		for (int i = 0; i < SECTOR_SIZE / 2; i++) {
   10503:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10507:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1050e:	7e da                	jle    104ea <read_disk+0xf6>
	while (sector_count-- > 0) {
   10510:	8b 45 0c             	mov    0xc(%ebp),%eax
   10513:	8d 50 ff             	lea    -0x1(%eax),%edx
   10516:	89 55 0c             	mov    %edx,0xc(%ebp)
   10519:	85 c0                	test   %eax,%eax
   1051b:	7f a9                	jg     104c6 <read_disk+0xd2>
		}
	}
}
   1051d:	90                   	nop
   1051e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   10521:	c9                   	leave  
   10522:	c3                   	ret    

00010523 <sys_open>:

int sys_open(const char* name, int flags, ...) {
   10523:	55                   	push   %ebp
   10524:	89 e5                	mov    %esp,%ebp
    if(name[0] == '/') {
   10526:	8b 45 08             	mov    0x8(%ebp),%eax
   10529:	0f b6 00             	movzbl (%eax),%eax
   1052c:	3c 2f                	cmp    $0x2f,%al
   1052e:	75 25                	jne    10555 <sys_open+0x32>
        read_disk(5000, 80, (uint8_t* )TEMP_ADDR);
   10530:	68 20 60 01 00       	push   $0x16020
   10535:	6a 50                	push   $0x50
   10537:	68 88 13 00 00       	push   $0x1388
   1053c:	e8 b3 fe ff ff       	call   103f4 <read_disk>
   10541:	83 c4 0c             	add    $0xc,%esp
        temp_pos = (uint8_t *)TEMP_ADDR;
   10544:	c7 05 20 f0 02 00 20 	movl   $0x16020,0x2f020
   1054b:	60 01 00 
        return TEMP_FILE_ID;
   1054e:	b8 0c 00 00 00       	mov    $0xc,%eax
   10553:	eb 05                	jmp    1055a <sys_open+0x37>
    }
    return -1;
   10555:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1055a:	c9                   	leave  
   1055b:	c3                   	ret    

0001055c <sys_read>:

int sys_read(int file, char* ptr, int len) {
   1055c:	55                   	push   %ebp
   1055d:	89 e5                	mov    %esp,%ebp
   1055f:	83 ec 08             	sub    $0x8,%esp
    if(file == TEMP_FILE_ID) {
   10562:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
   10566:	75 2c                	jne    10594 <sys_read+0x38>
        k_memcpy(ptr, temp_pos, len);
   10568:	a1 20 f0 02 00       	mov    0x2f020,%eax
   1056d:	83 ec 04             	sub    $0x4,%esp
   10570:	ff 75 10             	pushl  0x10(%ebp)
   10573:	50                   	push   %eax
   10574:	ff 75 0c             	pushl  0xc(%ebp)
   10577:	e8 ec 10 00 00       	call   11668 <k_memcpy>
   1057c:	83 c4 10             	add    $0x10,%esp
        temp_pos += len;
   1057f:	8b 15 20 f0 02 00    	mov    0x2f020,%edx
   10585:	8b 45 10             	mov    0x10(%ebp),%eax
   10588:	01 d0                	add    %edx,%eax
   1058a:	a3 20 f0 02 00       	mov    %eax,0x2f020
        return len;
   1058f:	8b 45 10             	mov    0x10(%ebp),%eax
   10592:	eb 00                	jmp    10594 <sys_read+0x38>
    }
}
   10594:	c9                   	leave  
   10595:	c3                   	ret    

00010596 <sys_write>:

int sys_write(int file, char* ptr, int len) {
   10596:	55                   	push   %ebp
   10597:	89 e5                	mov    %esp,%ebp
    return -1;
   10599:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   1059e:	5d                   	pop    %ebp
   1059f:	c3                   	ret    

000105a0 <sys_lseek>:

int sys_lseek(int file, int ptr, int dir) {
   105a0:	55                   	push   %ebp
   105a1:	89 e5                	mov    %esp,%ebp
    if(file == TEMP_FILE_ID) {
   105a3:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
   105a7:	75 14                	jne    105bd <sys_lseek+0x1d>
        temp_pos = (uint8_t *)(TEMP_ADDR + ptr);
   105a9:	8b 45 0c             	mov    0xc(%ebp),%eax
   105ac:	05 20 60 01 00       	add    $0x16020,%eax
   105b1:	a3 20 f0 02 00       	mov    %eax,0x2f020
        return 0;
   105b6:	b8 00 00 00 00       	mov    $0x0,%eax
   105bb:	eb 00                	jmp    105bd <sys_lseek+0x1d>
    }
}
   105bd:	5d                   	pop    %ebp
   105be:	c3                   	ret    

000105bf <sys_close>:

int sys_close(int file) {
   105bf:	55                   	push   %ebp
   105c0:	89 e5                	mov    %esp,%ebp
    return 0;
   105c2:	b8 00 00 00 00       	mov    $0x0,%eax
   105c7:	5d                   	pop    %ebp
   105c8:	c3                   	ret    

000105c9 <lgdt>:
static inline void lgdt(uint32_t start, uint32_t size) {
   105c9:	55                   	push   %ebp
   105ca:	89 e5                	mov    %esp,%ebp
   105cc:	83 ec 10             	sub    $0x10,%esp
	gdt.start31_16 = start >> 16;
   105cf:	8b 45 08             	mov    0x8(%ebp),%eax
   105d2:	c1 e8 10             	shr    $0x10,%eax
   105d5:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	gdt.start15_0 = start & 0xFFFF;
   105d9:	8b 45 08             	mov    0x8(%ebp),%eax
   105dc:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	gdt.limit = size - 1;
   105e0:	8b 45 0c             	mov    0xc(%ebp),%eax
   105e3:	83 e8 01             	sub    $0x1,%eax
   105e6:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	__asm__ __volatile__("lgdt %[g]"::[g]"m"(gdt));
   105ea:	0f 01 55 fa          	lgdtl  -0x6(%ebp)
}
   105ee:	90                   	nop
   105ef:	c9                   	leave  
   105f0:	c3                   	ret    

000105f1 <segment_desc_set>:
#include <irq.h>

static segment_desc_t g_gdt_table[GDT_TABLE_SIZE];
static mutex_t g_mutex;

void segment_desc_set(int selector, uint32_t base, uint32_t limit, uint16_t attr) {
   105f1:	55                   	push   %ebp
   105f2:	89 e5                	mov    %esp,%ebp
   105f4:	83 ec 14             	sub    $0x14,%esp
   105f7:	8b 45 14             	mov    0x14(%ebp),%eax
   105fa:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
    segment_desc_t * desc = g_gdt_table + (selector >> 3);
   105fe:	8b 45 08             	mov    0x8(%ebp),%eax
   10601:	c1 f8 03             	sar    $0x3,%eax
   10604:	c1 e0 03             	shl    $0x3,%eax
   10607:	05 40 f0 02 00       	add    $0x2f040,%eax
   1060c:	89 45 fc             	mov    %eax,-0x4(%ebp)

	if (limit > 0xfffff) {
   1060f:	81 7d 10 ff ff 0f 00 	cmpl   $0xfffff,0x10(%ebp)
   10616:	76 0f                	jbe    10627 <segment_desc_set+0x36>
		attr |= 0x8000;
   10618:	66 81 4d ec 00 80    	orw    $0x8000,-0x14(%ebp)
		limit /= 0x1000;
   1061e:	8b 45 10             	mov    0x10(%ebp),%eax
   10621:	c1 e8 0c             	shr    $0xc,%eax
   10624:	89 45 10             	mov    %eax,0x10(%ebp)
	}
	desc->limit15_0 = limit & 0xffff;
   10627:	8b 45 10             	mov    0x10(%ebp),%eax
   1062a:	89 c2                	mov    %eax,%edx
   1062c:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1062f:	66 89 10             	mov    %dx,(%eax)
	desc->base15_0 = base & 0xffff;
   10632:	8b 45 0c             	mov    0xc(%ebp),%eax
   10635:	89 c2                	mov    %eax,%edx
   10637:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1063a:	66 89 50 02          	mov    %dx,0x2(%eax)
	desc->base23_16 = (base >> 16) & 0xff;
   1063e:	8b 45 0c             	mov    0xc(%ebp),%eax
   10641:	c1 e8 10             	shr    $0x10,%eax
   10644:	89 c2                	mov    %eax,%edx
   10646:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10649:	88 50 04             	mov    %dl,0x4(%eax)
	desc->attr = attr | (((limit >> 16) & 0xf) << 8);
   1064c:	8b 45 10             	mov    0x10(%ebp),%eax
   1064f:	c1 e8 10             	shr    $0x10,%eax
   10652:	c1 e0 08             	shl    $0x8,%eax
   10655:	66 25 00 0f          	and    $0xf00,%ax
   10659:	66 0b 45 ec          	or     -0x14(%ebp),%ax
   1065d:	89 c2                	mov    %eax,%edx
   1065f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10662:	66 89 50 05          	mov    %dx,0x5(%eax)
	desc->base31_24 = (base >> 24) & 0xff;
   10666:	8b 45 0c             	mov    0xc(%ebp),%eax
   10669:	c1 e8 18             	shr    $0x18,%eax
   1066c:	89 c2                	mov    %eax,%edx
   1066e:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10671:	88 50 07             	mov    %dl,0x7(%eax)
}
   10674:	90                   	nop
   10675:	c9                   	leave  
   10676:	c3                   	ret    

00010677 <gdt_init>:

void gdt_init() {
   10677:	55                   	push   %ebp
   10678:	89 e5                	mov    %esp,%ebp
   1067a:	83 ec 18             	sub    $0x18,%esp
    mutex_init(&g_mutex);
   1067d:	83 ec 0c             	sub    $0xc,%esp
   10680:	68 40 f8 02 00       	push   $0x2f840
   10685:	e8 ef 21 00 00       	call   12879 <mutex_init>
   1068a:	83 c4 10             	add    $0x10,%esp

    for (int i = 0; i < GDT_TABLE_SIZE; i++) {
   1068d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10694:	eb 19                	jmp    106af <gdt_init+0x38>
        segment_desc_set(i * sizeof(segment_desc_t), 0, 0, 0);
   10696:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10699:	c1 e0 03             	shl    $0x3,%eax
   1069c:	6a 00                	push   $0x0
   1069e:	6a 00                	push   $0x0
   106a0:	6a 00                	push   $0x0
   106a2:	50                   	push   %eax
   106a3:	e8 49 ff ff ff       	call   105f1 <segment_desc_set>
   106a8:	83 c4 10             	add    $0x10,%esp
    for (int i = 0; i < GDT_TABLE_SIZE; i++) {
   106ab:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   106af:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   106b6:	7e de                	jle    10696 <gdt_init+0x1f>
    }

    segment_desc_set(KERNEL_SELECTOR_DS, 0x00000000, 0xFFFFFFFF,
   106b8:	68 92 c0 00 00       	push   $0xc092
   106bd:	6a ff                	push   $0xffffffff
   106bf:	6a 00                	push   $0x0
   106c1:	6a 10                	push   $0x10
   106c3:	e8 29 ff ff ff       	call   105f1 <segment_desc_set>
   106c8:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_DATA
        | SEG_TYPE_RW | SEG_D | SEG_G);

    segment_desc_set(KERNEL_SELECTOR_CS, 0x00000000, 0xFFFFFFFF,
   106cb:	68 9a c0 00 00       	push   $0xc09a
   106d0:	6a ff                	push   $0xffffffff
   106d2:	6a 00                	push   $0x0
   106d4:	6a 08                	push   $0x8
   106d6:	e8 16 ff ff ff       	call   105f1 <segment_desc_set>
   106db:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_S_NORMAL | SEG_TYPE_CODE
        | SEG_TYPE_RW | SEG_D | SEG_G);

    gate_desc_set((gate_desc_t *)(g_gdt_table + (SELECTOR_SYSCALL >> 3)),
   106de:	ba bb 02 01 00       	mov    $0x102bb,%edx
   106e3:	b8 58 f0 02 00       	mov    $0x2f058,%eax
   106e8:	68 05 ec 00 00       	push   $0xec05
   106ed:	52                   	push   %edx
   106ee:	6a 08                	push   $0x8
   106f0:	50                   	push   %eax
   106f1:	e8 43 07 00 00       	call   10e39 <gate_desc_set>
   106f6:	83 c4 10             	add    $0x10,%esp
            KERNEL_SELECTOR_CS,
            (uint32_t)exception_handle_syscall,
            GATE_P_PRESENT | GATE_DPL3 | GATE_TYPE_SYSCALL | SYSCALL_PARAM_COUNT);

    lgdt((uint32_t)g_gdt_table, sizeof(g_gdt_table));
   106f9:	b8 40 f0 02 00       	mov    $0x2f040,%eax
   106fe:	83 ec 08             	sub    $0x8,%esp
   10701:	68 00 08 00 00       	push   $0x800
   10706:	50                   	push   %eax
   10707:	e8 bd fe ff ff       	call   105c9 <lgdt>
   1070c:	83 c4 10             	add    $0x10,%esp

}
   1070f:	90                   	nop
   10710:	c9                   	leave  
   10711:	c3                   	ret    

00010712 <gdt_alloc_desc>:

int  gdt_alloc_desc() {
   10712:	55                   	push   %ebp
   10713:	89 e5                	mov    %esp,%ebp
   10715:	83 ec 18             	sub    $0x18,%esp
    mutex_lock(&g_mutex);
   10718:	83 ec 0c             	sub    $0xc,%esp
   1071b:	68 40 f8 02 00       	push   $0x2f840
   10720:	e8 82 21 00 00       	call   128a7 <mutex_lock>
   10725:	83 c4 10             	add    $0x10,%esp
    int i = 1;
   10728:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
    for(; i < GDT_TABLE_SIZE; i++) {
   1072f:	eb 36                	jmp    10767 <gdt_alloc_desc+0x55>
        segment_desc_t* desc = g_gdt_table + i;
   10731:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10734:	c1 e0 03             	shl    $0x3,%eax
   10737:	05 40 f0 02 00       	add    $0x2f040,%eax
   1073c:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if(desc->attr == 0) {
   1073f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10742:	0f b7 40 05          	movzwl 0x5(%eax),%eax
   10746:	66 85 c0             	test   %ax,%ax
   10749:	75 18                	jne    10763 <gdt_alloc_desc+0x51>
            mutex_unlock(&g_mutex);
   1074b:	83 ec 0c             	sub    $0xc,%esp
   1074e:	68 40 f8 02 00       	push   $0x2f840
   10753:	e8 e3 21 00 00       	call   1293b <mutex_unlock>
   10758:	83 c4 10             	add    $0x10,%esp
            return ( i * sizeof(segment_desc_t) );
   1075b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1075e:	c1 e0 03             	shl    $0x3,%eax
   10761:	eb 22                	jmp    10785 <gdt_alloc_desc+0x73>
    for(; i < GDT_TABLE_SIZE; i++) {
   10763:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   10767:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
   1076e:	7e c1                	jle    10731 <gdt_alloc_desc+0x1f>
        }
    }
    mutex_unlock(&g_mutex);
   10770:	83 ec 0c             	sub    $0xc,%esp
   10773:	68 40 f8 02 00       	push   $0x2f840
   10778:	e8 be 21 00 00       	call   1293b <mutex_unlock>
   1077d:	83 c4 10             	add    $0x10,%esp
    return -1;
   10780:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   10785:	c9                   	leave  
   10786:	c3                   	ret    

00010787 <gdt_free_sel>:

void gdt_free_sel(int sel) {
   10787:	55                   	push   %ebp
   10788:	89 e5                	mov    %esp,%ebp
   1078a:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&g_mutex);
   1078d:	83 ec 0c             	sub    $0xc,%esp
   10790:	68 40 f8 02 00       	push   $0x2f840
   10795:	e8 0d 21 00 00       	call   128a7 <mutex_lock>
   1079a:	83 c4 10             	add    $0x10,%esp
    g_gdt_table[sel/sizeof(segment_desc_t)].attr = 0;
   1079d:	8b 45 08             	mov    0x8(%ebp),%eax
   107a0:	c1 e8 03             	shr    $0x3,%eax
   107a3:	66 c7 04 c5 45 f0 02 	movw   $0x0,0x2f045(,%eax,8)
   107aa:	00 00 00 
    mutex_unlock(&g_mutex);
   107ad:	83 ec 0c             	sub    $0xc,%esp
   107b0:	68 40 f8 02 00       	push   $0x2f840
   107b5:	e8 81 21 00 00       	call   1293b <mutex_unlock>
   107ba:	83 c4 10             	add    $0x10,%esp
}
   107bd:	90                   	nop
   107be:	c9                   	leave  
   107bf:	c3                   	ret    

000107c0 <list_count>:

static inline int list_is_empty (list_t* list) {
    return list->count == 0;
}

static inline int list_count (list_t* list) {
   107c0:	55                   	push   %ebp
   107c1:	89 e5                	mov    %esp,%ebp
    return list->count;
   107c3:	8b 45 08             	mov    0x8(%ebp),%eax
   107c6:	8b 40 08             	mov    0x8(%eax),%eax
}
   107c9:	5d                   	pop    %ebp
   107ca:	c3                   	ret    

000107cb <list_first>:

static inline list_node_t* list_first (list_t* list) {
   107cb:	55                   	push   %ebp
   107cc:	89 e5                	mov    %esp,%ebp
    return list->first;
   107ce:	8b 45 08             	mov    0x8(%ebp),%eax
   107d1:	8b 00                	mov    (%eax),%eax
}
   107d3:	5d                   	pop    %ebp
   107d4:	c3                   	ret    

000107d5 <list_last>:

static inline list_node_t* list_last (list_t* list) {
   107d5:	55                   	push   %ebp
   107d6:	89 e5                	mov    %esp,%ebp
    return list->last;
   107d8:	8b 45 08             	mov    0x8(%ebp),%eax
   107db:	8b 40 04             	mov    0x4(%eax),%eax
}
   107de:	5d                   	pop    %ebp
   107df:	c3                   	ret    

000107e0 <kernel_init>:

// void test_mem_page() {}
// *(uint8_t*)test_mem_page = 0x12;
// *(uint8_t*)test_mem_page = 0x34;

void kernel_init (boot_info_t * boot_info) {
   107e0:	55                   	push   %ebp
   107e1:	89 e5                	mov    %esp,%ebp
   107e3:	83 ec 08             	sub    $0x8,%esp
    log_init();
   107e6:	e8 ca 13 00 00       	call   11bb5 <log_init>
    gdt_init();
   107eb:	e8 87 fe ff ff       	call   10677 <gdt_init>
    memory_init(boot_info);
   107f0:	83 ec 0c             	sub    $0xc,%esp
   107f3:	ff 75 08             	pushl  0x8(%ebp)
   107f6:	e8 2d 1a 00 00       	call   12228 <memory_init>
   107fb:	83 c4 10             	add    $0x10,%esp
    irq_init();
   107fe:	e8 40 07 00 00       	call   10f43 <irq_init>
    time_init();
   10803:	e8 79 fb ff ff       	call   10381 <time_init>
}
   10808:	90                   	nop
   10809:	c9                   	leave  
   1080a:	c3                   	ret    

0001080b <show_list>:


void show_list(list_t list) {
   1080b:	55                   	push   %ebp
   1080c:	89 e5                	mov    %esp,%ebp
   1080e:	56                   	push   %esi
   1080f:	53                   	push   %ebx
    klog("list: first=0x%x, last=0x%x, count=%d",
   10810:	8d 45 08             	lea    0x8(%ebp),%eax
   10813:	50                   	push   %eax
   10814:	e8 a7 ff ff ff       	call   107c0 <list_count>
   10819:	83 c4 04             	add    $0x4,%esp
   1081c:	89 c6                	mov    %eax,%esi
   1081e:	8d 45 08             	lea    0x8(%ebp),%eax
   10821:	50                   	push   %eax
   10822:	e8 ae ff ff ff       	call   107d5 <list_last>
   10827:	83 c4 04             	add    $0x4,%esp
   1082a:	89 c3                	mov    %eax,%ebx
   1082c:	8d 45 08             	lea    0x8(%ebp),%eax
   1082f:	50                   	push   %eax
   10830:	e8 96 ff ff ff       	call   107cb <list_first>
   10835:	83 c4 04             	add    $0x4,%esp
   10838:	56                   	push   %esi
   10839:	53                   	push   %ebx
   1083a:	50                   	push   %eax
   1083b:	68 38 3b 01 00       	push   $0x13b38
   10840:	e8 0d 14 00 00       	call   11c52 <klog>
   10845:	83 c4 10             	add    $0x10,%esp
         list_first(&list), list_last(&list), list_count(&list) );
}
   10848:	90                   	nop
   10849:	8d 65 f8             	lea    -0x8(%ebp),%esp
   1084c:	5b                   	pop    %ebx
   1084d:	5e                   	pop    %esi
   1084e:	5d                   	pop    %ebp
   1084f:	c3                   	ret    

00010850 <list_test>:

void list_test() {
   10850:	55                   	push   %ebp
   10851:	89 e5                	mov    %esp,%ebp
   10853:	83 ec 58             	sub    $0x58,%esp
    list_t list;
    list_node_t nodes[5];

    list_init(&list);
   10856:	83 ec 0c             	sub    $0xc,%esp
   10859:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   1085c:	50                   	push   %eax
   1085d:	e8 31 11 00 00       	call   11993 <list_init>
   10862:	83 c4 10             	add    $0x10,%esp

    show_list(list);
   10865:	83 ec 04             	sub    $0x4,%esp
   10868:	ff 75 dc             	pushl  -0x24(%ebp)
   1086b:	ff 75 d8             	pushl  -0x28(%ebp)
   1086e:	ff 75 d4             	pushl  -0x2c(%ebp)
   10871:	e8 95 ff ff ff       	call   1080b <show_list>
   10876:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<5; i++) {
   10879:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   10880:	eb 3f                	jmp    108c1 <list_test+0x71>
        list_node_t * node = nodes + i;
   10882:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10885:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   1088c:	8d 45 ac             	lea    -0x54(%ebp),%eax
   1088f:	01 d0                	add    %edx,%eax
   10891:	89 45 e0             	mov    %eax,-0x20(%ebp)
        klog("insert first to list: %d, 0x%x", i, (uint32_t)node);
   10894:	8b 45 e0             	mov    -0x20(%ebp),%eax
   10897:	83 ec 04             	sub    $0x4,%esp
   1089a:	50                   	push   %eax
   1089b:	ff 75 f4             	pushl  -0xc(%ebp)
   1089e:	68 60 3b 01 00       	push   $0x13b60
   108a3:	e8 aa 13 00 00       	call   11c52 <klog>
   108a8:	83 c4 10             	add    $0x10,%esp
        list_insert_first(&list, node);
   108ab:	83 ec 08             	sub    $0x8,%esp
   108ae:	ff 75 e0             	pushl  -0x20(%ebp)
   108b1:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   108b4:	50                   	push   %eax
   108b5:	e8 fe 10 00 00       	call   119b8 <list_insert_first>
   108ba:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<5; i++) {
   108bd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   108c1:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
   108c5:	7e bb                	jle    10882 <list_test+0x32>
    }
    show_list(list);
   108c7:	83 ec 04             	sub    $0x4,%esp
   108ca:	ff 75 dc             	pushl  -0x24(%ebp)
   108cd:	ff 75 d8             	pushl  -0x28(%ebp)
   108d0:	ff 75 d4             	pushl  -0x2c(%ebp)
   108d3:	e8 33 ff ff ff       	call   1080b <show_list>
   108d8:	83 c4 10             	add    $0x10,%esp

    list_init(&list);
   108db:	83 ec 0c             	sub    $0xc,%esp
   108de:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   108e1:	50                   	push   %eax
   108e2:	e8 ac 10 00 00       	call   11993 <list_init>
   108e7:	83 c4 10             	add    $0x10,%esp
    show_list(list);
   108ea:	83 ec 04             	sub    $0x4,%esp
   108ed:	ff 75 dc             	pushl  -0x24(%ebp)
   108f0:	ff 75 d8             	pushl  -0x28(%ebp)
   108f3:	ff 75 d4             	pushl  -0x2c(%ebp)
   108f6:	e8 10 ff ff ff       	call   1080b <show_list>
   108fb:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<5; i++) {
   108fe:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   10905:	eb 3f                	jmp    10946 <list_test+0xf6>
        list_node_t * node = nodes + i;
   10907:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1090a:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
   10911:	8d 45 ac             	lea    -0x54(%ebp),%eax
   10914:	01 d0                	add    %edx,%eax
   10916:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        klog("insert first to list: %d, 0x%x", i, (uint32_t)node);
   10919:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1091c:	83 ec 04             	sub    $0x4,%esp
   1091f:	50                   	push   %eax
   10920:	ff 75 f0             	pushl  -0x10(%ebp)
   10923:	68 60 3b 01 00       	push   $0x13b60
   10928:	e8 25 13 00 00       	call   11c52 <klog>
   1092d:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&list, node);
   10930:	83 ec 08             	sub    $0x8,%esp
   10933:	ff 75 e4             	pushl  -0x1c(%ebp)
   10936:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   10939:	50                   	push   %eax
   1093a:	e8 d8 10 00 00       	call   11a17 <list_insert_last>
   1093f:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<5; i++) {
   10942:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   10946:	83 7d f0 04          	cmpl   $0x4,-0x10(%ebp)
   1094a:	7e bb                	jle    10907 <list_test+0xb7>
    }
    show_list(list);
   1094c:	83 ec 04             	sub    $0x4,%esp
   1094f:	ff 75 dc             	pushl  -0x24(%ebp)
   10952:	ff 75 d8             	pushl  -0x28(%ebp)
   10955:	ff 75 d4             	pushl  -0x2c(%ebp)
   10958:	e8 ae fe ff ff       	call   1080b <show_list>
   1095d:	83 c4 10             	add    $0x10,%esp
    
    for(int i=0; i<5; i++) {
   10960:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   10967:	eb 2d                	jmp    10996 <list_test+0x146>
        list_node_t* node = list_delete_first(&list);
   10969:	83 ec 0c             	sub    $0xc,%esp
   1096c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
   1096f:	50                   	push   %eax
   10970:	e8 06 11 00 00       	call   11a7b <list_delete_first>
   10975:	83 c4 10             	add    $0x10,%esp
   10978:	89 45 e8             	mov    %eax,-0x18(%ebp)
        klog("delete first from list: %d, 0x%x", i, (uint32_t)node);
   1097b:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1097e:	83 ec 04             	sub    $0x4,%esp
   10981:	50                   	push   %eax
   10982:	ff 75 ec             	pushl  -0x14(%ebp)
   10985:	68 80 3b 01 00       	push   $0x13b80
   1098a:	e8 c3 12 00 00       	call   11c52 <klog>
   1098f:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<5; i++) {
   10992:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   10996:	83 7d ec 04          	cmpl   $0x4,-0x14(%ebp)
   1099a:	7e cd                	jle    10969 <list_test+0x119>
    }

    show_list(list);
   1099c:	83 ec 04             	sub    $0x4,%esp
   1099f:	ff 75 dc             	pushl  -0x24(%ebp)
   109a2:	ff 75 d8             	pushl  -0x28(%ebp)
   109a5:	ff 75 d4             	pushl  -0x2c(%ebp)
   109a8:	e8 5e fe ff ff       	call   1080b <show_list>
   109ad:	83 c4 10             	add    $0x10,%esp

}
   109b0:	90                   	nop
   109b1:	c9                   	leave  
   109b2:	c3                   	ret    

000109b3 <offset_test>:

void offset_test() {
   109b3:	55                   	push   %ebp
   109b4:	89 e5                	mov    %esp,%ebp
   109b6:	83 ec 28             	sub    $0x28,%esp
    struct type_t {
        int i;
        list_node_t node;
    }v = {0x123456};
   109b9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
   109c0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   109c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   109ce:	c7 45 e4 56 34 12 00 	movl   $0x123456,-0x1c(%ebp)

    list_node_t * v_node = &v.node;
   109d5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
   109d8:	83 c0 04             	add    $0x4,%eax
   109db:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct type_t* p = list_node_parent(v_node, struct type_t, node);
   109de:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   109e2:	74 08                	je     109ec <offset_test+0x39>
   109e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   109e7:	83 e8 04             	sub    $0x4,%eax
   109ea:	eb 05                	jmp    109f1 <offset_test+0x3e>
   109ec:	b8 00 00 00 00       	mov    $0x0,%eax
   109f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    
    if(p->i != 0x123456) {
   109f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   109f7:	8b 00                	mov    (%eax),%eax
   109f9:	3d 56 34 12 00       	cmp    $0x123456,%eax
   109fe:	74 10                	je     10a10 <offset_test+0x5d>
        klog("error");
   10a00:	83 ec 0c             	sub    $0xc,%esp
   10a03:	68 a1 3b 01 00       	push   $0x13ba1
   10a08:	e8 45 12 00 00       	call   11c52 <klog>
   10a0d:	83 c4 10             	add    $0x10,%esp
    }
}
   10a10:	90                   	nop
   10a11:	c9                   	leave  
   10a12:	c3                   	ret    

00010a13 <move_to_first_task>:



void move_to_first_task(void) {
   10a13:	55                   	push   %ebp
   10a14:	89 e5                	mov    %esp,%ebp
   10a16:	56                   	push   %esi
   10a17:	53                   	push   %ebx
   10a18:	83 ec 10             	sub    $0x10,%esp
    task_t * curr = task_current();
   10a1b:	e8 81 26 00 00       	call   130a1 <task_current>
   10a20:	89 45 f4             	mov    %eax,-0xc(%ebp)
    tss_t * tss = &(curr->tss);
   10a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
   10a26:	83 c0 54             	add    $0x54,%eax
   10a29:	89 45 f0             	mov    %eax,-0x10(%ebp)
        "push %[esp]\n\t"
        "push %[eflags]\n\t"
        "push %[cs]\n\t"
        "push %[eip]\n\t"
        "iret"
        ::[ss]"r"(tss->ss), 
   10a2c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   10a2f:	8b 40 50             	mov    0x50(%eax),%eax
        [esp]"r"(tss->esp),
   10a32:	8b 55 f0             	mov    -0x10(%ebp),%edx
   10a35:	8b 52 38             	mov    0x38(%edx),%edx
        [eflags]"r"(tss->eflags),
   10a38:	8b 4d f0             	mov    -0x10(%ebp),%ecx
   10a3b:	8b 49 24             	mov    0x24(%ecx),%ecx
        [cs]"r"(tss->cs),
   10a3e:	8b 5d f0             	mov    -0x10(%ebp),%ebx
   10a41:	8b 5b 4c             	mov    0x4c(%ebx),%ebx
        [eip]"r"(tss->eip)
   10a44:	8b 75 f0             	mov    -0x10(%ebp),%esi
   10a47:	8b 76 20             	mov    0x20(%esi),%esi
    __asm__ __volatile__( 
   10a4a:	50                   	push   %eax
   10a4b:	52                   	push   %edx
   10a4c:	51                   	push   %ecx
   10a4d:	53                   	push   %ebx
   10a4e:	56                   	push   %esi
   10a4f:	cf                   	iret   
    );
}
   10a50:	90                   	nop
   10a51:	83 c4 10             	add    $0x10,%esp
   10a54:	5b                   	pop    %ebx
   10a55:	5e                   	pop    %esi
   10a56:	5d                   	pop    %ebp
   10a57:	c3                   	ret    

00010a58 <init_main>:

void init_main() {
   10a58:	55                   	push   %ebp
   10a59:	89 e5                	mov    %esp,%ebp
   10a5b:	83 ec 08             	sub    $0x8,%esp
    klog("Kernal %s is running ... ", "1.0.0");
   10a5e:	83 ec 08             	sub    $0x8,%esp
   10a61:	68 a7 3b 01 00       	push   $0x13ba7
   10a66:	68 ad 3b 01 00       	push   $0x13bad
   10a6b:	e8 e2 11 00 00       	call   11c52 <klog>
   10a70:	83 c4 10             	add    $0x10,%esp

    task_manager_init();
   10a73:	e8 8f 24 00 00       	call   12f07 <task_manager_init>
    first_task_init();
   10a78:	e8 6f 25 00 00       	call   12fec <first_task_init>
    irq_enable_global();
   10a7d:	e8 63 07 00 00       	call   111e5 <irq_enable_global>
    
    move_to_first_task();
   10a82:	e8 8c ff ff ff       	call   10a13 <move_to_first_task>
   10a87:	90                   	nop
   10a88:	c9                   	leave  
   10a89:	c3                   	ret    

00010a8a <hlt>:
static inline void hlt() {
   10a8a:	55                   	push   %ebp
   10a8b:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("hlt");
   10a8d:	f4                   	hlt    
}
   10a8e:	90                   	nop
   10a8f:	5d                   	pop    %ebp
   10a90:	c3                   	ret    

00010a91 <cli>:
static inline void cli() {
   10a91:	55                   	push   %ebp
   10a92:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("cli");
   10a94:	fa                   	cli    
}
   10a95:	90                   	nop
   10a96:	5d                   	pop    %ebp
   10a97:	c3                   	ret    

00010a98 <sti>:
static inline void sti() {
   10a98:	55                   	push   %ebp
   10a99:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("sti");
   10a9b:	fb                   	sti    
}
   10a9c:	90                   	nop
   10a9d:	5d                   	pop    %ebp
   10a9e:	c3                   	ret    

00010a9f <lidt>:
static inline void lidt(uint32_t start, uint32_t size) {
   10a9f:	55                   	push   %ebp
   10aa0:	89 e5                	mov    %esp,%ebp
   10aa2:	83 ec 10             	sub    $0x10,%esp
	idt.start31_16 = start >> 16;
   10aa5:	8b 45 08             	mov    0x8(%ebp),%eax
   10aa8:	c1 e8 10             	shr    $0x10,%eax
   10aab:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
	idt.start15_0 = start & 0xFFFF;
   10aaf:	8b 45 08             	mov    0x8(%ebp),%eax
   10ab2:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
	idt.limit = size - 1;
   10ab6:	8b 45 0c             	mov    0xc(%ebp),%eax
   10ab9:	83 e8 01             	sub    $0x1,%eax
   10abc:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	__asm__ __volatile__("lidt %0"::"m"(idt));
   10ac0:	0f 01 5d fa          	lidtl  -0x6(%ebp)
}
   10ac4:	90                   	nop
   10ac5:	c9                   	leave  
   10ac6:	c3                   	ret    

00010ac7 <inb>:
static inline uint8_t inb(uint16_t  port) {
   10ac7:	55                   	push   %ebp
   10ac8:	89 e5                	mov    %esp,%ebp
   10aca:	83 ec 14             	sub    $0x14,%esp
   10acd:	8b 45 08             	mov    0x8(%ebp),%eax
   10ad0:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   10ad4:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   10ad8:	89 c2                	mov    %eax,%edx
   10ada:	ec                   	in     (%dx),%al
   10adb:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   10ade:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   10ae2:	c9                   	leave  
   10ae3:	c3                   	ret    

00010ae4 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   10ae4:	55                   	push   %ebp
   10ae5:	89 e5                	mov    %esp,%ebp
   10ae7:	83 ec 08             	sub    $0x8,%esp
   10aea:	8b 55 08             	mov    0x8(%ebp),%edx
   10aed:	8b 45 0c             	mov    0xc(%ebp),%eax
   10af0:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   10af4:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   10af7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10afb:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   10aff:	ee                   	out    %al,(%dx)
}
   10b00:	90                   	nop
   10b01:	c9                   	leave  
   10b02:	c3                   	ret    

00010b03 <read_cr2>:

static inline void write_cr0(uint32_t v) {
	__asm__ __volatile__("mov %[v], %%cr0"::[v]"r"(v));
}

static inline uint32_t read_cr2() {
   10b03:	55                   	push   %ebp
   10b04:	89 e5                	mov    %esp,%ebp
   10b06:	83 ec 10             	sub    $0x10,%esp
	uint32_t cr2;
	__asm__ __volatile__("mov %%cr2, %[v]":[v]"=r"(cr2));
   10b09:	0f 20 d0             	mov    %cr2,%eax
   10b0c:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return cr2;
   10b0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10b12:	c9                   	leave  
   10b13:	c3                   	ret    

00010b14 <read_eflags>:

static inline void write_tr (uint16_t tss_selector) {
    __asm__ __volatile__("ltr %%ax"::"a"(tss_selector));
}

static inline uint32_t read_eflags() {
   10b14:	55                   	push   %ebp
   10b15:	89 e5                	mov    %esp,%ebp
   10b17:	83 ec 10             	sub    $0x10,%esp
	uint32_t eflags;

	__asm__ __volatile__("pushf\n\tpop %%eax":"=a"(eflags));
   10b1a:	9c                   	pushf  
   10b1b:	58                   	pop    %eax
   10b1c:	89 45 fc             	mov    %eax,-0x4(%ebp)

	return eflags;
   10b1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   10b22:	c9                   	leave  
   10b23:	c3                   	ret    

00010b24 <write_eflags>:

static inline void write_eflags(uint32_t eflags) {
   10b24:	55                   	push   %ebp
   10b25:	89 e5                	mov    %esp,%ebp

	__asm__ __volatile__("push %%eax\n\tpopf"::"a"(eflags));
   10b27:	8b 45 08             	mov    0x8(%ebp),%eax
   10b2a:	50                   	push   %eax
   10b2b:	9d                   	popf   


}
   10b2c:	90                   	nop
   10b2d:	5d                   	pop    %ebp
   10b2e:	c3                   	ret    

00010b2f <default_handler>:

//  -----------------------------------------   中断相关    -------------------------------------------
#define IDT_TABLE_NR 128
static gate_desc_t idt_table[IDT_TABLE_NR];

static void default_handler (exception_frame_t * frame, const char * message) {
   10b2f:	55                   	push   %ebp
   10b30:	89 e5                	mov    %esp,%ebp
   10b32:	83 ec 08             	sub    $0x8,%esp
    klog("--------------------------------");
   10b35:	83 ec 0c             	sub    $0xc,%esp
   10b38:	68 c8 3b 01 00       	push   $0x13bc8
   10b3d:	e8 10 11 00 00       	call   11c52 <klog>
   10b42:	83 c4 10             	add    $0x10,%esp
    klog("IRQ/Exception happend: %s.", message);
   10b45:	83 ec 08             	sub    $0x8,%esp
   10b48:	ff 75 0c             	pushl  0xc(%ebp)
   10b4b:	68 e9 3b 01 00       	push   $0x13be9
   10b50:	e8 fd 10 00 00       	call   11c52 <klog>
   10b55:	83 c4 10             	add    $0x10,%esp
    for (;;) {
        hlt();
   10b58:	e8 2d ff ff ff       	call   10a8a <hlt>
   10b5d:	eb f9                	jmp    10b58 <default_handler+0x29>

00010b5f <handle_unknown>:
    }
}
void handle_unknown (exception_frame_t * frame) {
   10b5f:	55                   	push   %ebp
   10b60:	89 e5                	mov    %esp,%ebp
   10b62:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Unknown exception.");
   10b65:	83 ec 08             	sub    $0x8,%esp
   10b68:	68 04 3c 01 00       	push   $0x13c04
   10b6d:	ff 75 08             	pushl  0x8(%ebp)
   10b70:	e8 ba ff ff ff       	call   10b2f <default_handler>
   10b75:	83 c4 10             	add    $0x10,%esp
}
   10b78:	90                   	nop
   10b79:	c9                   	leave  
   10b7a:	c3                   	ret    

00010b7b <handle_divider>:
void handle_divider(exception_frame_t * frame) {
   10b7b:	55                   	push   %ebp
   10b7c:	89 e5                	mov    %esp,%ebp
   10b7e:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Divider Error.");
   10b81:	83 ec 08             	sub    $0x8,%esp
   10b84:	68 17 3c 01 00       	push   $0x13c17
   10b89:	ff 75 08             	pushl  0x8(%ebp)
   10b8c:	e8 9e ff ff ff       	call   10b2f <default_handler>
   10b91:	83 c4 10             	add    $0x10,%esp
}
   10b94:	90                   	nop
   10b95:	c9                   	leave  
   10b96:	c3                   	ret    

00010b97 <handle_Debug>:
void handle_Debug(exception_frame_t * frame) {
   10b97:	55                   	push   %ebp
   10b98:	89 e5                	mov    %esp,%ebp
   10b9a:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Debug Exception");
   10b9d:	83 ec 08             	sub    $0x8,%esp
   10ba0:	68 26 3c 01 00       	push   $0x13c26
   10ba5:	ff 75 08             	pushl  0x8(%ebp)
   10ba8:	e8 82 ff ff ff       	call   10b2f <default_handler>
   10bad:	83 c4 10             	add    $0x10,%esp
}
   10bb0:	90                   	nop
   10bb1:	c9                   	leave  
   10bb2:	c3                   	ret    

00010bb3 <handle_NMI>:
void handle_NMI(exception_frame_t * frame) {
   10bb3:	55                   	push   %ebp
   10bb4:	89 e5                	mov    %esp,%ebp
   10bb6:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "NMI Interrupt.");
   10bb9:	83 ec 08             	sub    $0x8,%esp
   10bbc:	68 36 3c 01 00       	push   $0x13c36
   10bc1:	ff 75 08             	pushl  0x8(%ebp)
   10bc4:	e8 66 ff ff ff       	call   10b2f <default_handler>
   10bc9:	83 c4 10             	add    $0x10,%esp
}
   10bcc:	90                   	nop
   10bcd:	c9                   	leave  
   10bce:	c3                   	ret    

00010bcf <handle_breakpoint>:
void handle_breakpoint(exception_frame_t * frame) {
   10bcf:	55                   	push   %ebp
   10bd0:	89 e5                	mov    %esp,%ebp
   10bd2:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Breakpoint.");
   10bd5:	83 ec 08             	sub    $0x8,%esp
   10bd8:	68 45 3c 01 00       	push   $0x13c45
   10bdd:	ff 75 08             	pushl  0x8(%ebp)
   10be0:	e8 4a ff ff ff       	call   10b2f <default_handler>
   10be5:	83 c4 10             	add    $0x10,%esp
}
   10be8:	90                   	nop
   10be9:	c9                   	leave  
   10bea:	c3                   	ret    

00010beb <handle_overflow>:
void handle_overflow(exception_frame_t * frame) {
   10beb:	55                   	push   %ebp
   10bec:	89 e5                	mov    %esp,%ebp
   10bee:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Overflow.");
   10bf1:	83 ec 08             	sub    $0x8,%esp
   10bf4:	68 51 3c 01 00       	push   $0x13c51
   10bf9:	ff 75 08             	pushl  0x8(%ebp)
   10bfc:	e8 2e ff ff ff       	call   10b2f <default_handler>
   10c01:	83 c4 10             	add    $0x10,%esp
}
   10c04:	90                   	nop
   10c05:	c9                   	leave  
   10c06:	c3                   	ret    

00010c07 <handle_bound_range>:
void handle_bound_range(exception_frame_t * frame) {
   10c07:	55                   	push   %ebp
   10c08:	89 e5                	mov    %esp,%ebp
   10c0a:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "BOUND Range Exceeded.");
   10c0d:	83 ec 08             	sub    $0x8,%esp
   10c10:	68 5b 3c 01 00       	push   $0x13c5b
   10c15:	ff 75 08             	pushl  0x8(%ebp)
   10c18:	e8 12 ff ff ff       	call   10b2f <default_handler>
   10c1d:	83 c4 10             	add    $0x10,%esp
}
   10c20:	90                   	nop
   10c21:	c9                   	leave  
   10c22:	c3                   	ret    

00010c23 <handle_invalid_opcode>:
void handle_invalid_opcode(exception_frame_t * frame) {
   10c23:	55                   	push   %ebp
   10c24:	89 e5                	mov    %esp,%ebp
   10c26:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Invalid Opcode.");
   10c29:	83 ec 08             	sub    $0x8,%esp
   10c2c:	68 71 3c 01 00       	push   $0x13c71
   10c31:	ff 75 08             	pushl  0x8(%ebp)
   10c34:	e8 f6 fe ff ff       	call   10b2f <default_handler>
   10c39:	83 c4 10             	add    $0x10,%esp
}
   10c3c:	90                   	nop
   10c3d:	c9                   	leave  
   10c3e:	c3                   	ret    

00010c3f <handle_device_unavailable>:
void handle_device_unavailable(exception_frame_t * frame) {
   10c3f:	55                   	push   %ebp
   10c40:	89 e5                	mov    %esp,%ebp
   10c42:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Device Not Available.");
   10c45:	83 ec 08             	sub    $0x8,%esp
   10c48:	68 81 3c 01 00       	push   $0x13c81
   10c4d:	ff 75 08             	pushl  0x8(%ebp)
   10c50:	e8 da fe ff ff       	call   10b2f <default_handler>
   10c55:	83 c4 10             	add    $0x10,%esp
}
   10c58:	90                   	nop
   10c59:	c9                   	leave  
   10c5a:	c3                   	ret    

00010c5b <handle_double_fault>:
void handle_double_fault(exception_frame_t * frame) {
   10c5b:	55                   	push   %ebp
   10c5c:	89 e5                	mov    %esp,%ebp
   10c5e:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Double Fault.");
   10c61:	83 ec 08             	sub    $0x8,%esp
   10c64:	68 97 3c 01 00       	push   $0x13c97
   10c69:	ff 75 08             	pushl  0x8(%ebp)
   10c6c:	e8 be fe ff ff       	call   10b2f <default_handler>
   10c71:	83 c4 10             	add    $0x10,%esp
}
   10c74:	90                   	nop
   10c75:	c9                   	leave  
   10c76:	c3                   	ret    

00010c77 <handle_invalid_tss>:
void handle_invalid_tss(exception_frame_t * frame) {
   10c77:	55                   	push   %ebp
   10c78:	89 e5                	mov    %esp,%ebp
   10c7a:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Invalid TSS");
   10c7d:	83 ec 08             	sub    $0x8,%esp
   10c80:	68 a5 3c 01 00       	push   $0x13ca5
   10c85:	ff 75 08             	pushl  0x8(%ebp)
   10c88:	e8 a2 fe ff ff       	call   10b2f <default_handler>
   10c8d:	83 c4 10             	add    $0x10,%esp
}
   10c90:	90                   	nop
   10c91:	c9                   	leave  
   10c92:	c3                   	ret    

00010c93 <handle_segment_not_present>:
void handle_segment_not_present(exception_frame_t * frame) {
   10c93:	55                   	push   %ebp
   10c94:	89 e5                	mov    %esp,%ebp
   10c96:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Segment Not Present.");
   10c99:	83 ec 08             	sub    $0x8,%esp
   10c9c:	68 b1 3c 01 00       	push   $0x13cb1
   10ca1:	ff 75 08             	pushl  0x8(%ebp)
   10ca4:	e8 86 fe ff ff       	call   10b2f <default_handler>
   10ca9:	83 c4 10             	add    $0x10,%esp
}
   10cac:	90                   	nop
   10cad:	c9                   	leave  
   10cae:	c3                   	ret    

00010caf <handle_stack_segment_fault>:
void handle_stack_segment_fault(exception_frame_t * frame) {
   10caf:	55                   	push   %ebp
   10cb0:	89 e5                	mov    %esp,%ebp
   10cb2:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Stack-Segment Fault.");
   10cb5:	83 ec 08             	sub    $0x8,%esp
   10cb8:	68 c6 3c 01 00       	push   $0x13cc6
   10cbd:	ff 75 08             	pushl  0x8(%ebp)
   10cc0:	e8 6a fe ff ff       	call   10b2f <default_handler>
   10cc5:	83 c4 10             	add    $0x10,%esp
}
   10cc8:	90                   	nop
   10cc9:	c9                   	leave  
   10cca:	c3                   	ret    

00010ccb <handle_general_protection>:
void handle_general_protection(exception_frame_t * frame) {
   10ccb:	55                   	push   %ebp
   10ccc:	89 e5                	mov    %esp,%ebp
   10cce:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "IRQ/Exception happend: General Protection.");
   10cd1:	83 ec 08             	sub    $0x8,%esp
   10cd4:	68 dc 3c 01 00       	push   $0x13cdc
   10cd9:	ff 75 08             	pushl  0x8(%ebp)
   10cdc:	e8 4e fe ff ff       	call   10b2f <default_handler>
   10ce1:	83 c4 10             	add    $0x10,%esp
}
   10ce4:	90                   	nop
   10ce5:	c9                   	leave  
   10ce6:	c3                   	ret    

00010ce7 <handle_page_fault>:
void handle_page_fault(exception_frame_t * frame) {
   10ce7:	55                   	push   %ebp
   10ce8:	89 e5                	mov    %esp,%ebp
   10cea:	83 ec 08             	sub    $0x8,%esp
    klog("--------------------------------");
   10ced:	83 ec 0c             	sub    $0xc,%esp
   10cf0:	68 c8 3b 01 00       	push   $0x13bc8
   10cf5:	e8 58 0f 00 00       	call   11c52 <klog>
   10cfa:	83 c4 10             	add    $0x10,%esp
    klog("IRQ/Exception happend: Page fault.");
   10cfd:	83 ec 0c             	sub    $0xc,%esp
   10d00:	68 08 3d 01 00       	push   $0x13d08
   10d05:	e8 48 0f 00 00       	call   11c52 <klog>
   10d0a:	83 c4 10             	add    $0x10,%esp
    if (frame->err_code & ERR_PAGE_P) {
   10d0d:	8b 45 08             	mov    0x8(%ebp),%eax
   10d10:	8b 40 34             	mov    0x34(%eax),%eax
   10d13:	83 e0 01             	and    $0x1,%eax
   10d16:	85 c0                	test   %eax,%eax
   10d18:	74 18                	je     10d32 <handle_page_fault+0x4b>
        klog("\tpage-level protection violation: 0x%x.", read_cr2());
   10d1a:	e8 e4 fd ff ff       	call   10b03 <read_cr2>
   10d1f:	83 ec 08             	sub    $0x8,%esp
   10d22:	50                   	push   %eax
   10d23:	68 2c 3d 01 00       	push   $0x13d2c
   10d28:	e8 25 0f 00 00       	call   11c52 <klog>
   10d2d:	83 c4 10             	add    $0x10,%esp
   10d30:	eb 16                	jmp    10d48 <handle_page_fault+0x61>
    } else {
         klog("\tPage doesn't present 0x%x", read_cr2());
   10d32:	e8 cc fd ff ff       	call   10b03 <read_cr2>
   10d37:	83 ec 08             	sub    $0x8,%esp
   10d3a:	50                   	push   %eax
   10d3b:	68 54 3d 01 00       	push   $0x13d54
   10d40:	e8 0d 0f 00 00       	call   11c52 <klog>
   10d45:	83 c4 10             	add    $0x10,%esp
   }
    
    if (frame->err_code & ERR_PAGE_WR) {
   10d48:	8b 45 08             	mov    0x8(%ebp),%eax
   10d4b:	8b 40 34             	mov    0x34(%eax),%eax
   10d4e:	83 e0 02             	and    $0x2,%eax
   10d51:	85 c0                	test   %eax,%eax
   10d53:	74 12                	je     10d67 <handle_page_fault+0x80>
        klog("\tThe access causing the fault was a read.");
   10d55:	83 ec 0c             	sub    $0xc,%esp
   10d58:	68 70 3d 01 00       	push   $0x13d70
   10d5d:	e8 f0 0e 00 00       	call   11c52 <klog>
   10d62:	83 c4 10             	add    $0x10,%esp
   10d65:	eb 10                	jmp    10d77 <handle_page_fault+0x90>
    } else {
        klog("\tThe access causing the fault was a write.");
   10d67:	83 ec 0c             	sub    $0xc,%esp
   10d6a:	68 9c 3d 01 00       	push   $0x13d9c
   10d6f:	e8 de 0e 00 00       	call   11c52 <klog>
   10d74:	83 c4 10             	add    $0x10,%esp
    }
    
    if (frame->err_code & ERR_PAGE_US) {
   10d77:	8b 45 08             	mov    0x8(%ebp),%eax
   10d7a:	8b 40 34             	mov    0x34(%eax),%eax
   10d7d:	83 e0 02             	and    $0x2,%eax
   10d80:	85 c0                	test   %eax,%eax
   10d82:	74 12                	je     10d96 <handle_page_fault+0xaf>
        klog("\tA supervisor-mode access caused the fault.");
   10d84:	83 ec 0c             	sub    $0xc,%esp
   10d87:	68 c8 3d 01 00       	push   $0x13dc8
   10d8c:	e8 c1 0e 00 00       	call   11c52 <klog>
   10d91:	83 c4 10             	add    $0x10,%esp
   10d94:	eb 10                	jmp    10da6 <handle_page_fault+0xbf>
    } else {
        klog("\tA user-mode access caused the fault.");
   10d96:	83 ec 0c             	sub    $0xc,%esp
   10d99:	68 f4 3d 01 00       	push   $0x13df4
   10d9e:	e8 af 0e 00 00       	call   11c52 <klog>
   10da3:	83 c4 10             	add    $0x10,%esp
    }

    while(1){hlt();}
   10da6:	e8 df fc ff ff       	call   10a8a <hlt>
   10dab:	eb f9                	jmp    10da6 <handle_page_fault+0xbf>

00010dad <handle_fpu_error>:

	//default_handler(frame, "IRQ/Exception happend: Page fault.");
}
void handle_fpu_error(exception_frame_t * frame) {
   10dad:	55                   	push   %ebp
   10dae:	89 e5                	mov    %esp,%ebp
   10db0:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "X87 FPU Floating Point Error.");
   10db3:	83 ec 08             	sub    $0x8,%esp
   10db6:	68 1a 3e 01 00       	push   $0x13e1a
   10dbb:	ff 75 08             	pushl  0x8(%ebp)
   10dbe:	e8 6c fd ff ff       	call   10b2f <default_handler>
   10dc3:	83 c4 10             	add    $0x10,%esp
}
   10dc6:	90                   	nop
   10dc7:	c9                   	leave  
   10dc8:	c3                   	ret    

00010dc9 <handle_alignment_check>:
void handle_alignment_check(exception_frame_t * frame) {
   10dc9:	55                   	push   %ebp
   10dca:	89 e5                	mov    %esp,%ebp
   10dcc:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Alignment Check.");
   10dcf:	83 ec 08             	sub    $0x8,%esp
   10dd2:	68 38 3e 01 00       	push   $0x13e38
   10dd7:	ff 75 08             	pushl  0x8(%ebp)
   10dda:	e8 50 fd ff ff       	call   10b2f <default_handler>
   10ddf:	83 c4 10             	add    $0x10,%esp
}
   10de2:	90                   	nop
   10de3:	c9                   	leave  
   10de4:	c3                   	ret    

00010de5 <handle_machine_check>:
void handle_machine_check(exception_frame_t * frame) {
   10de5:	55                   	push   %ebp
   10de6:	89 e5                	mov    %esp,%ebp
   10de8:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Machine Check.");
   10deb:	83 ec 08             	sub    $0x8,%esp
   10dee:	68 49 3e 01 00       	push   $0x13e49
   10df3:	ff 75 08             	pushl  0x8(%ebp)
   10df6:	e8 34 fd ff ff       	call   10b2f <default_handler>
   10dfb:	83 c4 10             	add    $0x10,%esp
}
   10dfe:	90                   	nop
   10dff:	c9                   	leave  
   10e00:	c3                   	ret    

00010e01 <handle_smd_exception>:
void handle_smd_exception(exception_frame_t * frame) {
   10e01:	55                   	push   %ebp
   10e02:	89 e5                	mov    %esp,%ebp
   10e04:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "SIMD Floating Point Exception.");
   10e07:	83 ec 08             	sub    $0x8,%esp
   10e0a:	68 58 3e 01 00       	push   $0x13e58
   10e0f:	ff 75 08             	pushl  0x8(%ebp)
   10e12:	e8 18 fd ff ff       	call   10b2f <default_handler>
   10e17:	83 c4 10             	add    $0x10,%esp
}
   10e1a:	90                   	nop
   10e1b:	c9                   	leave  
   10e1c:	c3                   	ret    

00010e1d <handle_virtual_exception>:
void handle_virtual_exception(exception_frame_t * frame) {
   10e1d:	55                   	push   %ebp
   10e1e:	89 e5                	mov    %esp,%ebp
   10e20:	83 ec 08             	sub    $0x8,%esp
	default_handler(frame, "Virtualization Exception.");
   10e23:	83 ec 08             	sub    $0x8,%esp
   10e26:	68 77 3e 01 00       	push   $0x13e77
   10e2b:	ff 75 08             	pushl  0x8(%ebp)
   10e2e:	e8 fc fc ff ff       	call   10b2f <default_handler>
   10e33:	83 c4 10             	add    $0x10,%esp
}
   10e36:	90                   	nop
   10e37:	c9                   	leave  
   10e38:	c3                   	ret    

00010e39 <gate_desc_set>:

void gate_desc_set(gate_desc_t * desc, uint16_t selector, uint32_t offset, uint16_t attr) {
   10e39:	55                   	push   %ebp
   10e3a:	89 e5                	mov    %esp,%ebp
   10e3c:	83 ec 08             	sub    $0x8,%esp
   10e3f:	8b 55 0c             	mov    0xc(%ebp),%edx
   10e42:	8b 45 14             	mov    0x14(%ebp),%eax
   10e45:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   10e49:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
	desc->offset15_0 = offset & 0xffff;
   10e4d:	8b 45 10             	mov    0x10(%ebp),%eax
   10e50:	89 c2                	mov    %eax,%edx
   10e52:	8b 45 08             	mov    0x8(%ebp),%eax
   10e55:	66 89 10             	mov    %dx,(%eax)
	desc->selector = selector;
   10e58:	8b 45 08             	mov    0x8(%ebp),%eax
   10e5b:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   10e5f:	66 89 50 02          	mov    %dx,0x2(%eax)
	desc->attr = attr;
   10e63:	8b 45 08             	mov    0x8(%ebp),%eax
   10e66:	0f b7 55 f8          	movzwl -0x8(%ebp),%edx
   10e6a:	66 89 50 04          	mov    %dx,0x4(%eax)
	desc->offset31_16 = (offset >> 16) & 0xffff;
   10e6e:	8b 45 10             	mov    0x10(%ebp),%eax
   10e71:	c1 e8 10             	shr    $0x10,%eax
   10e74:	89 c2                	mov    %eax,%edx
   10e76:	8b 45 08             	mov    0x8(%ebp),%eax
   10e79:	66 89 50 06          	mov    %dx,0x6(%eax)
}
   10e7d:	90                   	nop
   10e7e:	c9                   	leave  
   10e7f:	c3                   	ret    

00010e80 <irq_install>:

int irq_install(int irq_num, uint32_t handler) {
   10e80:	55                   	push   %ebp
   10e81:	89 e5                	mov    %esp,%ebp
    if(irq_num >= IDT_TABLE_NR) {
   10e83:	83 7d 08 7f          	cmpl   $0x7f,0x8(%ebp)
   10e87:	7e 07                	jle    10e90 <irq_install+0x10>
        return -1;
   10e89:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   10e8e:	eb 1e                	jmp    10eae <irq_install+0x2e>
    }

    gate_desc_set(idt_table + irq_num, KERNEL_SELECTOR_CS, (uint32_t)handler, 
   10e90:	8b 45 08             	mov    0x8(%ebp),%eax
   10e93:	c1 e0 03             	shl    $0x3,%eax
   10e96:	05 60 f8 02 00       	add    $0x2f860,%eax
   10e9b:	68 00 8e 00 00       	push   $0x8e00
   10ea0:	ff 75 0c             	pushl  0xc(%ebp)
   10ea3:	6a 08                	push   $0x8
   10ea5:	50                   	push   %eax
   10ea6:	e8 8e ff ff ff       	call   10e39 <gate_desc_set>
   10eab:	83 c4 10             	add    $0x10,%esp
        GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);
}
   10eae:	c9                   	leave  
   10eaf:	c3                   	ret    

00010eb0 <init_pic>:

static void init_pic() {
   10eb0:	55                   	push   %ebp
   10eb1:	89 e5                	mov    %esp,%ebp
    outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 | PIC_ICW1_ICW4);
   10eb3:	6a 11                	push   $0x11
   10eb5:	6a 20                	push   $0x20
   10eb7:	e8 28 fc ff ff       	call   10ae4 <outb>
   10ebc:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW2, IRQ_PIC_START);
   10ebf:	6a 20                	push   $0x20
   10ec1:	6a 21                	push   $0x21
   10ec3:	e8 1c fc ff ff       	call   10ae4 <outb>
   10ec8:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW3, 1 << 2);
   10ecb:	6a 04                	push   $0x4
   10ecd:	6a 21                	push   $0x21
   10ecf:	e8 10 fc ff ff       	call   10ae4 <outb>
   10ed4:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_ICW4, PIC_ICW4_8086);
   10ed7:	6a 01                	push   $0x1
   10ed9:	6a 21                	push   $0x21
   10edb:	e8 04 fc ff ff       	call   10ae4 <outb>
   10ee0:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW1, PIC_ICW1_ICW4 | PIC_ICW1_ALWAYS_1);
   10ee3:	6a 11                	push   $0x11
   10ee5:	68 a0 00 00 00       	push   $0xa0
   10eea:	e8 f5 fb ff ff       	call   10ae4 <outb>
   10eef:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW2, IRQ_PIC_START + 8);
   10ef2:	6a 28                	push   $0x28
   10ef4:	68 a1 00 00 00       	push   $0xa1
   10ef9:	e8 e6 fb ff ff       	call   10ae4 <outb>
   10efe:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW3, 2);
   10f01:	6a 02                	push   $0x2
   10f03:	68 a1 00 00 00       	push   $0xa1
   10f08:	e8 d7 fb ff ff       	call   10ae4 <outb>
   10f0d:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_ICW4, PIC_ICW4_8086);
   10f10:	6a 01                	push   $0x1
   10f12:	68 a1 00 00 00       	push   $0xa1
   10f17:	e8 c8 fb ff ff       	call   10ae4 <outb>
   10f1c:	83 c4 08             	add    $0x8,%esp
    outb(PIC0_IMR, 0xFF & ~(1 << 2));
   10f1f:	68 fb 00 00 00       	push   $0xfb
   10f24:	6a 21                	push   $0x21
   10f26:	e8 b9 fb ff ff       	call   10ae4 <outb>
   10f2b:	83 c4 08             	add    $0x8,%esp
    outb(PIC1_IMR, 0xFF);
   10f2e:	68 ff 00 00 00       	push   $0xff
   10f33:	68 a1 00 00 00       	push   $0xa1
   10f38:	e8 a7 fb ff ff       	call   10ae4 <outb>
   10f3d:	83 c4 08             	add    $0x8,%esp
}
   10f40:	90                   	nop
   10f41:	c9                   	leave  
   10f42:	c3                   	ret    

00010f43 <irq_init>:

void irq_init () {
   10f43:	55                   	push   %ebp
   10f44:	89 e5                	mov    %esp,%ebp
   10f46:	83 ec 10             	sub    $0x10,%esp
    for (uint32_t i = 0; i < IDT_TABLE_NR; i++) 
   10f49:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
   10f50:	eb 25                	jmp    10f77 <irq_init+0x34>
    	gate_desc_set(idt_table + i, KERNEL_SELECTOR_CS, (uint32_t) exception_handler_unknown,
   10f52:	ba 28 00 01 00       	mov    $0x10028,%edx
   10f57:	8b 45 fc             	mov    -0x4(%ebp),%eax
   10f5a:	c1 e0 03             	shl    $0x3,%eax
   10f5d:	05 60 f8 02 00       	add    $0x2f860,%eax
   10f62:	68 00 8e 00 00       	push   $0x8e00
   10f67:	52                   	push   %edx
   10f68:	6a 08                	push   $0x8
   10f6a:	50                   	push   %eax
   10f6b:	e8 c9 fe ff ff       	call   10e39 <gate_desc_set>
   10f70:	83 c4 10             	add    $0x10,%esp
    for (uint32_t i = 0; i < IDT_TABLE_NR; i++) 
   10f73:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
   10f77:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%ebp)
   10f7b:	76 d5                	jbe    10f52 <irq_init+0xf>
            GATE_P_PRESENT | GATE_DPL0 | GATE_TYPE_IDT);

    lidt((uint32_t)idt_table, sizeof(idt_table));
   10f7d:	b8 60 f8 02 00       	mov    $0x2f860,%eax
   10f82:	68 00 04 00 00       	push   $0x400
   10f87:	50                   	push   %eax
   10f88:	e8 12 fb ff ff       	call   10a9f <lidt>
   10f8d:	83 c4 08             	add    $0x8,%esp

    // 设置异常处理接口
    irq_install(IRQ0_DE, (uint32_t)exception_handler_divider);
   10f90:	b8 47 00 01 00       	mov    $0x10047,%eax
   10f95:	50                   	push   %eax
   10f96:	6a 00                	push   $0x0
   10f98:	e8 e3 fe ff ff       	call   10e80 <irq_install>
   10f9d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ1_DB, (uint32_t)exception_handler_Debug);
   10fa0:	b8 66 00 01 00       	mov    $0x10066,%eax
   10fa5:	50                   	push   %eax
   10fa6:	6a 01                	push   $0x1
   10fa8:	e8 d3 fe ff ff       	call   10e80 <irq_install>
   10fad:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ2_NMI, (uint32_t)exception_handler_NMI);
   10fb0:	b8 85 00 01 00       	mov    $0x10085,%eax
   10fb5:	50                   	push   %eax
   10fb6:	6a 02                	push   $0x2
   10fb8:	e8 c3 fe ff ff       	call   10e80 <irq_install>
   10fbd:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ3_BP, (uint32_t)exception_handler_breakpoint);
   10fc0:	b8 a4 00 01 00       	mov    $0x100a4,%eax
   10fc5:	50                   	push   %eax
   10fc6:	6a 03                	push   $0x3
   10fc8:	e8 b3 fe ff ff       	call   10e80 <irq_install>
   10fcd:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ4_OF, (uint32_t)exception_handler_overflow);
   10fd0:	b8 c3 00 01 00       	mov    $0x100c3,%eax
   10fd5:	50                   	push   %eax
   10fd6:	6a 04                	push   $0x4
   10fd8:	e8 a3 fe ff ff       	call   10e80 <irq_install>
   10fdd:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ5_BR, (uint32_t)exception_handler_bound_range);
   10fe0:	b8 e2 00 01 00       	mov    $0x100e2,%eax
   10fe5:	50                   	push   %eax
   10fe6:	6a 05                	push   $0x5
   10fe8:	e8 93 fe ff ff       	call   10e80 <irq_install>
   10fed:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ6_UD, (uint32_t)exception_handler_invalid_opcode);
   10ff0:	b8 01 01 01 00       	mov    $0x10101,%eax
   10ff5:	50                   	push   %eax
   10ff6:	6a 06                	push   $0x6
   10ff8:	e8 83 fe ff ff       	call   10e80 <irq_install>
   10ffd:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ7_NM, (uint32_t)exception_handler_device_unavailable);
   11000:	b8 20 01 01 00       	mov    $0x10120,%eax
   11005:	50                   	push   %eax
   11006:	6a 07                	push   $0x7
   11008:	e8 73 fe ff ff       	call   10e80 <irq_install>
   1100d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ8_DF, (uint32_t)exception_handler_double_fault);
   11010:	b8 3f 01 01 00       	mov    $0x1013f,%eax
   11015:	50                   	push   %eax
   11016:	6a 08                	push   $0x8
   11018:	e8 63 fe ff ff       	call   10e80 <irq_install>
   1101d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ10_TS, (uint32_t)exception_handler_invalid_tss);
   11020:	b8 5c 01 01 00       	mov    $0x1015c,%eax
   11025:	50                   	push   %eax
   11026:	6a 0a                	push   $0xa
   11028:	e8 53 fe ff ff       	call   10e80 <irq_install>
   1102d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ11_NP, (uint32_t)exception_handler_segment_not_present);
   11030:	b8 79 01 01 00       	mov    $0x10179,%eax
   11035:	50                   	push   %eax
   11036:	6a 0b                	push   $0xb
   11038:	e8 43 fe ff ff       	call   10e80 <irq_install>
   1103d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ12_SS, (uint32_t)exception_handler_stack_segment_fault);
   11040:	b8 96 01 01 00       	mov    $0x10196,%eax
   11045:	50                   	push   %eax
   11046:	6a 0c                	push   $0xc
   11048:	e8 33 fe ff ff       	call   10e80 <irq_install>
   1104d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ13_GP, (uint32_t)exception_handler_general_protection);
   11050:	b8 b3 01 01 00       	mov    $0x101b3,%eax
   11055:	50                   	push   %eax
   11056:	6a 0d                	push   $0xd
   11058:	e8 23 fe ff ff       	call   10e80 <irq_install>
   1105d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ14_PF, (uint32_t)exception_handler_page_fault);
   11060:	b8 d0 01 01 00       	mov    $0x101d0,%eax
   11065:	50                   	push   %eax
   11066:	6a 0e                	push   $0xe
   11068:	e8 13 fe ff ff       	call   10e80 <irq_install>
   1106d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ16_MF, (uint32_t)exception_handler_fpu_error);
   11070:	b8 ed 01 01 00       	mov    $0x101ed,%eax
   11075:	50                   	push   %eax
   11076:	6a 10                	push   $0x10
   11078:	e8 03 fe ff ff       	call   10e80 <irq_install>
   1107d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ17_AC, (uint32_t)exception_handler_alignment_check);
   11080:	b8 0c 02 01 00       	mov    $0x1020c,%eax
   11085:	50                   	push   %eax
   11086:	6a 11                	push   $0x11
   11088:	e8 f3 fd ff ff       	call   10e80 <irq_install>
   1108d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ18_MC, (uint32_t)exception_handler_machine_check);
   11090:	b8 29 02 01 00       	mov    $0x10229,%eax
   11095:	50                   	push   %eax
   11096:	6a 12                	push   $0x12
   11098:	e8 e3 fd ff ff       	call   10e80 <irq_install>
   1109d:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ19_XM, (uint32_t)exception_handler_smd_exception);
   110a0:	b8 48 02 01 00       	mov    $0x10248,%eax
   110a5:	50                   	push   %eax
   110a6:	6a 13                	push   $0x13
   110a8:	e8 d3 fd ff ff       	call   10e80 <irq_install>
   110ad:	83 c4 08             	add    $0x8,%esp
	irq_install(IRQ20_VE, (uint32_t)exception_handler_virtual_exception);
   110b0:	b8 67 02 01 00       	mov    $0x10267,%eax
   110b5:	50                   	push   %eax
   110b6:	6a 14                	push   $0x14
   110b8:	e8 c3 fd ff ff       	call   10e80 <irq_install>
   110bd:	83 c4 08             	add    $0x8,%esp

    init_pic();
   110c0:	e8 eb fd ff ff       	call   10eb0 <init_pic>
}
   110c5:	90                   	nop
   110c6:	c9                   	leave  
   110c7:	c3                   	ret    

000110c8 <irq_enable>:


// 中断的打开与关闭
void irq_enable(int irq_num) {
   110c8:	55                   	push   %ebp
   110c9:	89 e5                	mov    %esp,%ebp
   110cb:	53                   	push   %ebx
   110cc:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START) {
   110cf:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   110d3:	7e 78                	jle    1114d <irq_enable+0x85>
        return;
    }

    irq_num -= IRQ_PIC_START;
   110d5:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8) {
   110d9:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   110dd:	7f 32                	jg     11111 <irq_enable+0x49>
        uint8_t mask = inb(PIC0_IMR) & ~(1 << irq_num);
   110df:	6a 21                	push   $0x21
   110e1:	e8 e1 f9 ff ff       	call   10ac7 <inb>
   110e6:	83 c4 04             	add    $0x4,%esp
   110e9:	89 c2                	mov    %eax,%edx
   110eb:	8b 45 08             	mov    0x8(%ebp),%eax
   110ee:	bb 01 00 00 00       	mov    $0x1,%ebx
   110f3:	89 c1                	mov    %eax,%ecx
   110f5:	d3 e3                	shl    %cl,%ebx
   110f7:	89 d8                	mov    %ebx,%eax
   110f9:	f7 d0                	not    %eax
   110fb:	21 d0                	and    %edx,%eax
   110fd:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   11100:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   11104:	50                   	push   %eax
   11105:	6a 21                	push   $0x21
   11107:	e8 d8 f9 ff ff       	call   10ae4 <outb>
   1110c:	83 c4 08             	add    $0x8,%esp
   1110f:	eb 3d                	jmp    1114e <irq_enable+0x86>
    } else {
        irq_num -= 8;
   11111:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) & ~(1 << irq_num);
   11115:	68 a1 00 00 00       	push   $0xa1
   1111a:	e8 a8 f9 ff ff       	call   10ac7 <inb>
   1111f:	83 c4 04             	add    $0x4,%esp
   11122:	89 c2                	mov    %eax,%edx
   11124:	8b 45 08             	mov    0x8(%ebp),%eax
   11127:	bb 01 00 00 00       	mov    $0x1,%ebx
   1112c:	89 c1                	mov    %eax,%ecx
   1112e:	d3 e3                	shl    %cl,%ebx
   11130:	89 d8                	mov    %ebx,%eax
   11132:	f7 d0                	not    %eax
   11134:	21 d0                	and    %edx,%eax
   11136:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   11139:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   1113d:	50                   	push   %eax
   1113e:	68 a1 00 00 00       	push   $0xa1
   11143:	e8 9c f9 ff ff       	call   10ae4 <outb>
   11148:	83 c4 08             	add    $0x8,%esp
   1114b:	eb 01                	jmp    1114e <irq_enable+0x86>
        return;
   1114d:	90                   	nop
    }
}
   1114e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11151:	c9                   	leave  
   11152:	c3                   	ret    

00011153 <irq_disable>:

void irq_disable(int irq_num) {
   11153:	55                   	push   %ebp
   11154:	89 e5                	mov    %esp,%ebp
   11156:	53                   	push   %ebx
   11157:	83 ec 10             	sub    $0x10,%esp
    if (irq_num < IRQ_PIC_START) {
   1115a:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
   1115e:	7e 74                	jle    111d4 <irq_disable+0x81>
        return;
    }

    irq_num -= IRQ_PIC_START;
   11160:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num < 8) {
   11164:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   11168:	7f 30                	jg     1119a <irq_disable+0x47>
        uint8_t mask = inb(PIC0_IMR) | (1 << irq_num);
   1116a:	6a 21                	push   $0x21
   1116c:	e8 56 f9 ff ff       	call   10ac7 <inb>
   11171:	83 c4 04             	add    $0x4,%esp
   11174:	89 c3                	mov    %eax,%ebx
   11176:	8b 45 08             	mov    0x8(%ebp),%eax
   11179:	ba 01 00 00 00       	mov    $0x1,%edx
   1117e:	89 c1                	mov    %eax,%ecx
   11180:	d3 e2                	shl    %cl,%edx
   11182:	89 d0                	mov    %edx,%eax
   11184:	09 d8                	or     %ebx,%eax
   11186:	88 45 fa             	mov    %al,-0x6(%ebp)
        outb(PIC0_IMR, mask);
   11189:	0f b6 45 fa          	movzbl -0x6(%ebp),%eax
   1118d:	50                   	push   %eax
   1118e:	6a 21                	push   $0x21
   11190:	e8 4f f9 ff ff       	call   10ae4 <outb>
   11195:	83 c4 08             	add    $0x8,%esp
   11198:	eb 3b                	jmp    111d5 <irq_disable+0x82>
    } else {
        irq_num -= 8;
   1119a:	83 6d 08 08          	subl   $0x8,0x8(%ebp)
        uint8_t mask = inb(PIC1_IMR) | (1 << irq_num);
   1119e:	68 a1 00 00 00       	push   $0xa1
   111a3:	e8 1f f9 ff ff       	call   10ac7 <inb>
   111a8:	83 c4 04             	add    $0x4,%esp
   111ab:	89 c3                	mov    %eax,%ebx
   111ad:	8b 45 08             	mov    0x8(%ebp),%eax
   111b0:	ba 01 00 00 00       	mov    $0x1,%edx
   111b5:	89 c1                	mov    %eax,%ecx
   111b7:	d3 e2                	shl    %cl,%edx
   111b9:	89 d0                	mov    %edx,%eax
   111bb:	09 d8                	or     %ebx,%eax
   111bd:	88 45 fb             	mov    %al,-0x5(%ebp)
        outb(PIC1_IMR, mask);
   111c0:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
   111c4:	50                   	push   %eax
   111c5:	68 a1 00 00 00       	push   $0xa1
   111ca:	e8 15 f9 ff ff       	call   10ae4 <outb>
   111cf:	83 c4 08             	add    $0x8,%esp
   111d2:	eb 01                	jmp    111d5 <irq_disable+0x82>
        return;
   111d4:	90                   	nop
    }
}
   111d5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   111d8:	c9                   	leave  
   111d9:	c3                   	ret    

000111da <irq_disable_global>:

void irq_disable_global(void) {
   111da:	55                   	push   %ebp
   111db:	89 e5                	mov    %esp,%ebp
    cli();
   111dd:	e8 af f8 ff ff       	call   10a91 <cli>
}
   111e2:	90                   	nop
   111e3:	5d                   	pop    %ebp
   111e4:	c3                   	ret    

000111e5 <irq_enable_global>:

void irq_enable_global(void) {
   111e5:	55                   	push   %ebp
   111e6:	89 e5                	mov    %esp,%ebp
    sti();
   111e8:	e8 ab f8 ff ff       	call   10a98 <sti>
}
   111ed:	90                   	nop
   111ee:	5d                   	pop    %ebp
   111ef:	c3                   	ret    

000111f0 <pic_send_eoi>:

void pic_send_eoi(int irq_num) {
   111f0:	55                   	push   %ebp
   111f1:	89 e5                	mov    %esp,%ebp
    irq_num -= IRQ_PIC_START;
   111f3:	83 6d 08 20          	subl   $0x20,0x8(%ebp)
    if (irq_num >= 8) 
   111f7:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
   111fb:	7e 0f                	jle    1120c <pic_send_eoi+0x1c>
        outb(PIC1_OCW2, PIC_OCW2_EOI);
   111fd:	6a 20                	push   $0x20
   111ff:	68 a0 00 00 00       	push   $0xa0
   11204:	e8 db f8 ff ff       	call   10ae4 <outb>
   11209:	83 c4 08             	add    $0x8,%esp
    
    outb(PIC0_OCW2, PIC_OCW2_EOI);
   1120c:	6a 20                	push   $0x20
   1120e:	6a 20                	push   $0x20
   11210:	e8 cf f8 ff ff       	call   10ae4 <outb>
   11215:	83 c4 08             	add    $0x8,%esp
}
   11218:	90                   	nop
   11219:	c9                   	leave  
   1121a:	c3                   	ret    

0001121b <irq_enter_proection>:


irq_state_t irq_enter_proection() {
   1121b:	55                   	push   %ebp
   1121c:	89 e5                	mov    %esp,%ebp
   1121e:	83 ec 10             	sub    $0x10,%esp
    irq_state_t  state = read_eflags();
   11221:	e8 ee f8 ff ff       	call   10b14 <read_eflags>
   11226:	89 45 fc             	mov    %eax,-0x4(%ebp)
    irq_disable_global();
   11229:	e8 ac ff ff ff       	call   111da <irq_disable_global>

    return state;
   1122e:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11231:	c9                   	leave  
   11232:	c3                   	ret    

00011233 <irq_leave_proection>:


void irq_leave_proection(irq_state_t state) {
   11233:	55                   	push   %ebp
   11234:	89 e5                	mov    %esp,%ebp

    write_eflags(state);
   11236:	ff 75 08             	pushl  0x8(%ebp)
   11239:	e8 e6 f8 ff ff       	call   10b24 <write_eflags>
   1123e:	83 c4 04             	add    $0x4,%esp
}
   11241:	90                   	nop
   11242:	c9                   	leave  
   11243:	c3                   	ret    

00011244 <bitmap_byte_count>:
#include <bitmap.h>
#include <klib.h>

int bitmap_byte_count (int bit_count) {
   11244:	55                   	push   %ebp
   11245:	89 e5                	mov    %esp,%ebp
    return (bit_count + 8 - 1) / 8;         
   11247:	8b 45 08             	mov    0x8(%ebp),%eax
   1124a:	83 c0 07             	add    $0x7,%eax
   1124d:	8d 50 07             	lea    0x7(%eax),%edx
   11250:	85 c0                	test   %eax,%eax
   11252:	0f 48 c2             	cmovs  %edx,%eax
   11255:	c1 f8 03             	sar    $0x3,%eax
}
   11258:	5d                   	pop    %ebp
   11259:	c3                   	ret    

0001125a <bitmap_init>:

void bitmap_init (bitmap_t * bitmap, uint8_t * bits, int count, int init_bit) {
   1125a:	55                   	push   %ebp
   1125b:	89 e5                	mov    %esp,%ebp
   1125d:	83 ec 18             	sub    $0x18,%esp
    bitmap->bit_count = count;
   11260:	8b 45 08             	mov    0x8(%ebp),%eax
   11263:	8b 55 10             	mov    0x10(%ebp),%edx
   11266:	89 10                	mov    %edx,(%eax)
    bitmap->bits = bits;
   11268:	8b 45 08             	mov    0x8(%ebp),%eax
   1126b:	8b 55 0c             	mov    0xc(%ebp),%edx
   1126e:	89 50 04             	mov    %edx,0x4(%eax)

    int bytes = bitmap_byte_count(bitmap->bit_count);
   11271:	8b 45 08             	mov    0x8(%ebp),%eax
   11274:	8b 00                	mov    (%eax),%eax
   11276:	50                   	push   %eax
   11277:	e8 c8 ff ff ff       	call   11244 <bitmap_byte_count>
   1127c:	83 c4 04             	add    $0x4,%esp
   1127f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    k_memset(bitmap->bits, init_bit ? 0xFF: 0, bytes);
   11282:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   11286:	74 07                	je     1128f <bitmap_init+0x35>
   11288:	ba ff 00 00 00       	mov    $0xff,%edx
   1128d:	eb 05                	jmp    11294 <bitmap_init+0x3a>
   1128f:	ba 00 00 00 00       	mov    $0x0,%edx
   11294:	8b 45 08             	mov    0x8(%ebp),%eax
   11297:	8b 40 04             	mov    0x4(%eax),%eax
   1129a:	83 ec 04             	sub    $0x4,%esp
   1129d:	ff 75 f4             	pushl  -0xc(%ebp)
   112a0:	52                   	push   %edx
   112a1:	50                   	push   %eax
   112a2:	e8 10 04 00 00       	call   116b7 <k_memset>
   112a7:	83 c4 10             	add    $0x10,%esp
}
   112aa:	90                   	nop
   112ab:	c9                   	leave  
   112ac:	c3                   	ret    

000112ad <bitmap_get_bit>:


int bitmap_get_bit (bitmap_t * bitmap, int index) {
   112ad:	55                   	push   %ebp
   112ae:	89 e5                	mov    %esp,%ebp
   112b0:	53                   	push   %ebx

    return (bitmap->bits[index / 8] & (1 << (index % 8))) ? 1 : 0;
   112b1:	8b 45 08             	mov    0x8(%ebp),%eax
   112b4:	8b 50 04             	mov    0x4(%eax),%edx
   112b7:	8b 45 0c             	mov    0xc(%ebp),%eax
   112ba:	8d 48 07             	lea    0x7(%eax),%ecx
   112bd:	85 c0                	test   %eax,%eax
   112bf:	0f 48 c1             	cmovs  %ecx,%eax
   112c2:	c1 f8 03             	sar    $0x3,%eax
   112c5:	01 d0                	add    %edx,%eax
   112c7:	0f b6 00             	movzbl (%eax),%eax
   112ca:	0f b6 d8             	movzbl %al,%ebx
   112cd:	8b 45 0c             	mov    0xc(%ebp),%eax
   112d0:	99                   	cltd   
   112d1:	c1 ea 1d             	shr    $0x1d,%edx
   112d4:	01 d0                	add    %edx,%eax
   112d6:	83 e0 07             	and    $0x7,%eax
   112d9:	29 d0                	sub    %edx,%eax
   112db:	89 c1                	mov    %eax,%ecx
   112dd:	d3 fb                	sar    %cl,%ebx
   112df:	89 d8                	mov    %ebx,%eax
   112e1:	83 e0 01             	and    $0x1,%eax
}
   112e4:	5b                   	pop    %ebx
   112e5:	5d                   	pop    %ebp
   112e6:	c3                   	ret    

000112e7 <bitmap_is_set>:

int bitmap_is_set (bitmap_t * bitmap, int index) {
   112e7:	55                   	push   %ebp
   112e8:	89 e5                	mov    %esp,%ebp
    
    return bitmap_get_bit(bitmap, index) ? 1 : 0;
   112ea:	ff 75 0c             	pushl  0xc(%ebp)
   112ed:	ff 75 08             	pushl  0x8(%ebp)
   112f0:	e8 b8 ff ff ff       	call   112ad <bitmap_get_bit>
   112f5:	83 c4 08             	add    $0x8,%esp
   112f8:	85 c0                	test   %eax,%eax
   112fa:	0f 95 c0             	setne  %al
   112fd:	0f b6 c0             	movzbl %al,%eax
}
   11300:	c9                   	leave  
   11301:	c3                   	ret    

00011302 <bitmap_set_bit>:



void bitmap_set_bit (bitmap_t * bitmap, int index, int count, int bit) {
   11302:	55                   	push   %ebp
   11303:	89 e5                	mov    %esp,%ebp
   11305:	56                   	push   %esi
   11306:	53                   	push   %ebx
   11307:	83 ec 10             	sub    $0x10,%esp
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++) {
   1130a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11311:	e9 a2 00 00 00       	jmp    113b8 <bitmap_set_bit+0xb6>
        if (bit) {
   11316:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   1131a:	74 4a                	je     11366 <bitmap_set_bit+0x64>
            bitmap->bits[index / 8] |= 1 << (index % 8);
   1131c:	8b 45 08             	mov    0x8(%ebp),%eax
   1131f:	8b 50 04             	mov    0x4(%eax),%edx
   11322:	8b 45 0c             	mov    0xc(%ebp),%eax
   11325:	8d 48 07             	lea    0x7(%eax),%ecx
   11328:	85 c0                	test   %eax,%eax
   1132a:	0f 48 c1             	cmovs  %ecx,%eax
   1132d:	c1 f8 03             	sar    $0x3,%eax
   11330:	89 c3                	mov    %eax,%ebx
   11332:	89 d8                	mov    %ebx,%eax
   11334:	01 d0                	add    %edx,%eax
   11336:	0f b6 00             	movzbl (%eax),%eax
   11339:	89 c6                	mov    %eax,%esi
   1133b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1133e:	99                   	cltd   
   1133f:	c1 ea 1d             	shr    $0x1d,%edx
   11342:	01 d0                	add    %edx,%eax
   11344:	83 e0 07             	and    $0x7,%eax
   11347:	29 d0                	sub    %edx,%eax
   11349:	ba 01 00 00 00       	mov    $0x1,%edx
   1134e:	89 c1                	mov    %eax,%ecx
   11350:	d3 e2                	shl    %cl,%edx
   11352:	89 d0                	mov    %edx,%eax
   11354:	89 f2                	mov    %esi,%edx
   11356:	09 c2                	or     %eax,%edx
   11358:	8b 45 08             	mov    0x8(%ebp),%eax
   1135b:	8b 40 04             	mov    0x4(%eax),%eax
   1135e:	89 d9                	mov    %ebx,%ecx
   11360:	01 c8                	add    %ecx,%eax
   11362:	88 10                	mov    %dl,(%eax)
   11364:	eb 4a                	jmp    113b0 <bitmap_set_bit+0xae>
        } else {
            bitmap->bits[index / 8] &= ~(1 << (index % 8));
   11366:	8b 45 08             	mov    0x8(%ebp),%eax
   11369:	8b 50 04             	mov    0x4(%eax),%edx
   1136c:	8b 45 0c             	mov    0xc(%ebp),%eax
   1136f:	8d 48 07             	lea    0x7(%eax),%ecx
   11372:	85 c0                	test   %eax,%eax
   11374:	0f 48 c1             	cmovs  %ecx,%eax
   11377:	c1 f8 03             	sar    $0x3,%eax
   1137a:	89 c3                	mov    %eax,%ebx
   1137c:	89 d8                	mov    %ebx,%eax
   1137e:	01 d0                	add    %edx,%eax
   11380:	0f b6 00             	movzbl (%eax),%eax
   11383:	89 c6                	mov    %eax,%esi
   11385:	8b 45 0c             	mov    0xc(%ebp),%eax
   11388:	99                   	cltd   
   11389:	c1 ea 1d             	shr    $0x1d,%edx
   1138c:	01 d0                	add    %edx,%eax
   1138e:	83 e0 07             	and    $0x7,%eax
   11391:	29 d0                	sub    %edx,%eax
   11393:	ba 01 00 00 00       	mov    $0x1,%edx
   11398:	89 c1                	mov    %eax,%ecx
   1139a:	d3 e2                	shl    %cl,%edx
   1139c:	89 d0                	mov    %edx,%eax
   1139e:	f7 d0                	not    %eax
   113a0:	89 f2                	mov    %esi,%edx
   113a2:	21 c2                	and    %eax,%edx
   113a4:	8b 45 08             	mov    0x8(%ebp),%eax
   113a7:	8b 40 04             	mov    0x4(%eax),%eax
   113aa:	89 d9                	mov    %ebx,%ecx
   113ac:	01 c8                	add    %ecx,%eax
   113ae:	88 10                	mov    %dl,(%eax)
    for (int i = 0; (i < count) && (index < bitmap->bit_count); i++, index++) {
   113b0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   113b4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
   113b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   113bb:	3b 45 10             	cmp    0x10(%ebp),%eax
   113be:	7d 0e                	jge    113ce <bitmap_set_bit+0xcc>
   113c0:	8b 45 08             	mov    0x8(%ebp),%eax
   113c3:	8b 00                	mov    (%eax),%eax
   113c5:	39 45 0c             	cmp    %eax,0xc(%ebp)
   113c8:	0f 8c 48 ff ff ff    	jl     11316 <bitmap_set_bit+0x14>
        }
    }
} 
   113ce:	90                   	nop
   113cf:	83 c4 10             	add    $0x10,%esp
   113d2:	5b                   	pop    %ebx
   113d3:	5e                   	pop    %esi
   113d4:	5d                   	pop    %ebp
   113d5:	c3                   	ret    

000113d6 <bitmap_alloc_nbits>:



int bitmap_alloc_nbits (bitmap_t * bitmap, int bit, int count) {
   113d6:	55                   	push   %ebp
   113d7:	89 e5                	mov    %esp,%ebp
   113d9:	83 ec 10             	sub    $0x10,%esp
    int search_idx = 0;
   113dc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    int ok_idx = -1;
   113e3:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)

    while (search_idx < bitmap->bit_count) {
   113ea:	e9 85 00 00 00       	jmp    11474 <bitmap_alloc_nbits+0x9e>
        if (bitmap_get_bit(bitmap, search_idx) != bit) {
   113ef:	ff 75 fc             	pushl  -0x4(%ebp)
   113f2:	ff 75 08             	pushl  0x8(%ebp)
   113f5:	e8 b3 fe ff ff       	call   112ad <bitmap_get_bit>
   113fa:	83 c4 08             	add    $0x8,%esp
   113fd:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11400:	74 06                	je     11408 <bitmap_alloc_nbits+0x32>
            search_idx++;
   11402:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
            continue;
   11406:	eb 6c                	jmp    11474 <bitmap_alloc_nbits+0x9e>
        }

        ok_idx = search_idx;
   11408:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1140b:	89 45 f8             	mov    %eax,-0x8(%ebp)

        int i;
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   1140e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
   11415:	eb 27                	jmp    1143e <bitmap_alloc_nbits+0x68>
            if (bitmap_get_bit(bitmap, search_idx++) != bit) {
   11417:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1141a:	8d 50 01             	lea    0x1(%eax),%edx
   1141d:	89 55 fc             	mov    %edx,-0x4(%ebp)
   11420:	50                   	push   %eax
   11421:	ff 75 08             	pushl  0x8(%ebp)
   11424:	e8 84 fe ff ff       	call   112ad <bitmap_get_bit>
   11429:	83 c4 08             	add    $0x8,%esp
   1142c:	39 45 0c             	cmp    %eax,0xc(%ebp)
   1142f:	74 09                	je     1143a <bitmap_alloc_nbits+0x64>
                ok_idx = -1;
   11431:	c7 45 f8 ff ff ff ff 	movl   $0xffffffff,-0x8(%ebp)
                break;
   11438:	eb 16                	jmp    11450 <bitmap_alloc_nbits+0x7a>
        for (i = 1; (i < count) && (search_idx < bitmap->bit_count); i++) {
   1143a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1143e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11441:	3b 45 10             	cmp    0x10(%ebp),%eax
   11444:	7d 0a                	jge    11450 <bitmap_alloc_nbits+0x7a>
   11446:	8b 45 08             	mov    0x8(%ebp),%eax
   11449:	8b 00                	mov    (%eax),%eax
   1144b:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   1144e:	7c c7                	jl     11417 <bitmap_alloc_nbits+0x41>
            }
        }

        if (i >= count) {
   11450:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11453:	3b 45 10             	cmp    0x10(%ebp),%eax
   11456:	7c 1c                	jl     11474 <bitmap_alloc_nbits+0x9e>
            bitmap_set_bit(bitmap, ok_idx, count, ~bit);
   11458:	8b 45 0c             	mov    0xc(%ebp),%eax
   1145b:	f7 d0                	not    %eax
   1145d:	50                   	push   %eax
   1145e:	ff 75 10             	pushl  0x10(%ebp)
   11461:	ff 75 f8             	pushl  -0x8(%ebp)
   11464:	ff 75 08             	pushl  0x8(%ebp)
   11467:	e8 96 fe ff ff       	call   11302 <bitmap_set_bit>
   1146c:	83 c4 10             	add    $0x10,%esp
            return ok_idx;
   1146f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11472:	eb 13                	jmp    11487 <bitmap_alloc_nbits+0xb1>
    while (search_idx < bitmap->bit_count) {
   11474:	8b 45 08             	mov    0x8(%ebp),%eax
   11477:	8b 00                	mov    (%eax),%eax
   11479:	39 45 fc             	cmp    %eax,-0x4(%ebp)
   1147c:	0f 8c 6d ff ff ff    	jl     113ef <bitmap_alloc_nbits+0x19>
        }
    }

    return -1;
   11482:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   11487:	c9                   	leave  
   11488:	c3                   	ret    

00011489 <strings_count>:
#include <klib.h>


int strings_count (char ** start) {
   11489:	55                   	push   %ebp
   1148a:	89 e5                	mov    %esp,%ebp
   1148c:	83 ec 10             	sub    $0x10,%esp
    int count = 0;
   1148f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if (start) {
   11496:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1149a:	74 15                	je     114b1 <strings_count+0x28>
        while (*start++) {
   1149c:	eb 04                	jmp    114a2 <strings_count+0x19>
            count++;
   1149e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        while (*start++) {
   114a2:	8b 45 08             	mov    0x8(%ebp),%eax
   114a5:	8d 50 04             	lea    0x4(%eax),%edx
   114a8:	89 55 08             	mov    %edx,0x8(%ebp)
   114ab:	8b 00                	mov    (%eax),%eax
   114ad:	85 c0                	test   %eax,%eax
   114af:	75 ed                	jne    1149e <strings_count+0x15>
        }
    }
    return count;
   114b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   114b4:	c9                   	leave  
   114b5:	c3                   	ret    

000114b6 <get_file_name>:


char * get_file_name (char * name) {
   114b6:	55                   	push   %ebp
   114b7:	89 e5                	mov    %esp,%ebp
   114b9:	83 ec 10             	sub    $0x10,%esp
    char * s = name;
   114bc:	8b 45 08             	mov    0x8(%ebp),%eax
   114bf:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (*s != '\0') {
   114c2:	eb 04                	jmp    114c8 <get_file_name+0x12>
        s++;
   114c4:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while (*s != '\0') {
   114c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   114cb:	0f b6 00             	movzbl (%eax),%eax
   114ce:	84 c0                	test   %al,%al
   114d0:	75 f2                	jne    114c4 <get_file_name+0xe>
    }

    while ((*s != '\\') && (*s != '/') && (s >= name)) {
   114d2:	eb 04                	jmp    114d8 <get_file_name+0x22>
        s--;
   114d4:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
    while ((*s != '\\') && (*s != '/') && (s >= name)) {
   114d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   114db:	0f b6 00             	movzbl (%eax),%eax
   114de:	3c 5c                	cmp    $0x5c,%al
   114e0:	74 12                	je     114f4 <get_file_name+0x3e>
   114e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   114e5:	0f b6 00             	movzbl (%eax),%eax
   114e8:	3c 2f                	cmp    $0x2f,%al
   114ea:	74 08                	je     114f4 <get_file_name+0x3e>
   114ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
   114ef:	3b 45 08             	cmp    0x8(%ebp),%eax
   114f2:	73 e0                	jae    114d4 <get_file_name+0x1e>
    }
    return s + 1;
   114f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
   114f7:	83 c0 01             	add    $0x1,%eax
}
   114fa:	c9                   	leave  
   114fb:	c3                   	ret    

000114fc <k_strcpy>:

void k_strcpy(char * dest, const char * src) {
   114fc:	55                   	push   %ebp
   114fd:	89 e5                	mov    %esp,%ebp
    if (!dest || !src) {
   114ff:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11503:	74 3b                	je     11540 <k_strcpy+0x44>
   11505:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11509:	74 35                	je     11540 <k_strcpy+0x44>
        return;
    }
    while (*dest && *src) {
   1150b:	eb 17                	jmp    11524 <k_strcpy+0x28>
        *dest++ = *src++;
   1150d:	8b 55 0c             	mov    0xc(%ebp),%edx
   11510:	8d 42 01             	lea    0x1(%edx),%eax
   11513:	89 45 0c             	mov    %eax,0xc(%ebp)
   11516:	8b 45 08             	mov    0x8(%ebp),%eax
   11519:	8d 48 01             	lea    0x1(%eax),%ecx
   1151c:	89 4d 08             	mov    %ecx,0x8(%ebp)
   1151f:	0f b6 12             	movzbl (%edx),%edx
   11522:	88 10                	mov    %dl,(%eax)
    while (*dest && *src) {
   11524:	8b 45 08             	mov    0x8(%ebp),%eax
   11527:	0f b6 00             	movzbl (%eax),%eax
   1152a:	84 c0                	test   %al,%al
   1152c:	74 0a                	je     11538 <k_strcpy+0x3c>
   1152e:	8b 45 0c             	mov    0xc(%ebp),%eax
   11531:	0f b6 00             	movzbl (%eax),%eax
   11534:	84 c0                	test   %al,%al
   11536:	75 d5                	jne    1150d <k_strcpy+0x11>
    }
    *dest = '\0'; 
   11538:	8b 45 08             	mov    0x8(%ebp),%eax
   1153b:	c6 00 00             	movb   $0x0,(%eax)
   1153e:	eb 01                	jmp    11541 <k_strcpy+0x45>
        return;
   11540:	90                   	nop
}
   11541:	5d                   	pop    %ebp
   11542:	c3                   	ret    

00011543 <k_strncpy>:
void k_strncpy(char * dest, const char * src, int size) {
   11543:	55                   	push   %ebp
   11544:	89 e5                	mov    %esp,%ebp
   11546:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size) {
   11549:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   1154d:	74 61                	je     115b0 <k_strncpy+0x6d>
   1154f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11553:	74 5b                	je     115b0 <k_strncpy+0x6d>
   11555:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   11559:	74 55                	je     115b0 <k_strncpy+0x6d>
        return;
    }
    char* d = dest;
   1155b:	8b 45 08             	mov    0x8(%ebp),%eax
   1155e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    const char* s = src;
   11561:	8b 45 0c             	mov    0xc(%ebp),%eax
   11564:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size-- > 0 && (*s)) {
   11567:	eb 17                	jmp    11580 <k_strncpy+0x3d>
        *d++ = *s++;
   11569:	8b 55 f8             	mov    -0x8(%ebp),%edx
   1156c:	8d 42 01             	lea    0x1(%edx),%eax
   1156f:	89 45 f8             	mov    %eax,-0x8(%ebp)
   11572:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11575:	8d 48 01             	lea    0x1(%eax),%ecx
   11578:	89 4d fc             	mov    %ecx,-0x4(%ebp)
   1157b:	0f b6 12             	movzbl (%edx),%edx
   1157e:	88 10                	mov    %dl,(%eax)
    while(size-- > 0 && (*s)) {
   11580:	8b 45 10             	mov    0x10(%ebp),%eax
   11583:	8d 50 ff             	lea    -0x1(%eax),%edx
   11586:	89 55 10             	mov    %edx,0x10(%ebp)
   11589:	85 c0                	test   %eax,%eax
   1158b:	7e 0a                	jle    11597 <k_strncpy+0x54>
   1158d:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11590:	0f b6 00             	movzbl (%eax),%eax
   11593:	84 c0                	test   %al,%al
   11595:	75 d2                	jne    11569 <k_strncpy+0x26>
    } 
    if (size == 0) {
   11597:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1159b:	75 0b                	jne    115a8 <k_strncpy+0x65>
        *(d - 1) = '\0';
   1159d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   115a0:	83 e8 01             	sub    $0x1,%eax
   115a3:	c6 00 00             	movb   $0x0,(%eax)
   115a6:	eb 09                	jmp    115b1 <k_strncpy+0x6e>
    } else {
        *d = '\0';
   115a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
   115ab:	c6 00 00             	movb   $0x0,(%eax)
   115ae:	eb 01                	jmp    115b1 <k_strncpy+0x6e>
        return;
   115b0:	90                   	nop
    }
}
   115b1:	c9                   	leave  
   115b2:	c3                   	ret    

000115b3 <k_strncmp>:
int k_strncmp(const char * s1, const char * s2, int size) {
   115b3:	55                   	push   %ebp
   115b4:	89 e5                	mov    %esp,%ebp
    if (!s1 || !s2) return -1;
   115b6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   115ba:	74 06                	je     115c2 <k_strncmp+0xf>
   115bc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   115c0:	75 0f                	jne    115d1 <k_strncmp+0x1e>
   115c2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   115c7:	eb 62                	jmp    1162b <k_strncmp+0x78>

    while(*s1 && *s2 && (*s1 == *s2) && size) {
        s1 ++;
   115c9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        s2 ++;
   115cd:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
    while(*s1 && *s2 && (*s1 == *s2) && size) {
   115d1:	8b 45 08             	mov    0x8(%ebp),%eax
   115d4:	0f b6 00             	movzbl (%eax),%eax
   115d7:	84 c0                	test   %al,%al
   115d9:	74 20                	je     115fb <k_strncmp+0x48>
   115db:	8b 45 0c             	mov    0xc(%ebp),%eax
   115de:	0f b6 00             	movzbl (%eax),%eax
   115e1:	84 c0                	test   %al,%al
   115e3:	74 16                	je     115fb <k_strncmp+0x48>
   115e5:	8b 45 08             	mov    0x8(%ebp),%eax
   115e8:	0f b6 10             	movzbl (%eax),%edx
   115eb:	8b 45 0c             	mov    0xc(%ebp),%eax
   115ee:	0f b6 00             	movzbl (%eax),%eax
   115f1:	38 c2                	cmp    %al,%dl
   115f3:	75 06                	jne    115fb <k_strncmp+0x48>
   115f5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   115f9:	75 ce                	jne    115c9 <k_strncmp+0x16>
    }

    return !((*s1 == '\0') || (*s2 == '\0') || (*s1 == *s2));
   115fb:	8b 45 08             	mov    0x8(%ebp),%eax
   115fe:	0f b6 00             	movzbl (%eax),%eax
   11601:	84 c0                	test   %al,%al
   11603:	74 21                	je     11626 <k_strncmp+0x73>
   11605:	8b 45 0c             	mov    0xc(%ebp),%eax
   11608:	0f b6 00             	movzbl (%eax),%eax
   1160b:	84 c0                	test   %al,%al
   1160d:	74 17                	je     11626 <k_strncmp+0x73>
   1160f:	8b 45 08             	mov    0x8(%ebp),%eax
   11612:	0f b6 10             	movzbl (%eax),%edx
   11615:	8b 45 0c             	mov    0xc(%ebp),%eax
   11618:	0f b6 00             	movzbl (%eax),%eax
   1161b:	38 c2                	cmp    %al,%dl
   1161d:	74 07                	je     11626 <k_strncmp+0x73>
   1161f:	b8 01 00 00 00       	mov    $0x1,%eax
   11624:	eb 05                	jmp    1162b <k_strncmp+0x78>
   11626:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1162b:	5d                   	pop    %ebp
   1162c:	c3                   	ret    

0001162d <k_strlen>:
int k_strlen(const char *str) {
   1162d:	55                   	push   %ebp
   1162e:	89 e5                	mov    %esp,%ebp
   11630:	83 ec 10             	sub    $0x10,%esp
    if (!str) {
   11633:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11637:	75 07                	jne    11640 <k_strlen+0x13>
        return 0;
   11639:	b8 00 00 00 00       	mov    $0x0,%eax
   1163e:	eb 26                	jmp    11666 <k_strlen+0x39>
    }

    int len = 0;
   11640:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    const char * c = str;
   11647:	8b 45 08             	mov    0x8(%ebp),%eax
   1164a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(*c ++ ) {
   1164d:	eb 04                	jmp    11653 <k_strlen+0x26>
        len++;
   1164f:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
    while(*c ++ ) {
   11653:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11656:	8d 50 01             	lea    0x1(%eax),%edx
   11659:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1165c:	0f b6 00             	movzbl (%eax),%eax
   1165f:	84 c0                	test   %al,%al
   11661:	75 ec                	jne    1164f <k_strlen+0x22>
    }

    return len;
   11663:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11666:	c9                   	leave  
   11667:	c3                   	ret    

00011668 <k_memcpy>:

void k_memcpy(void* dest, void* src, int size) {
   11668:	55                   	push   %ebp
   11669:	89 e5                	mov    %esp,%ebp
   1166b:	83 ec 10             	sub    $0x10,%esp
    if (!dest || !src || !size) {
   1166e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11672:	74 40                	je     116b4 <k_memcpy+0x4c>
   11674:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11678:	74 3a                	je     116b4 <k_memcpy+0x4c>
   1167a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1167e:	74 34                	je     116b4 <k_memcpy+0x4c>
        return;
    }
    uint8_t * s = (uint8_t *)src;
   11680:	8b 45 0c             	mov    0xc(%ebp),%eax
   11683:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t * d = (uint8_t *)dest;
   11686:	8b 45 08             	mov    0x8(%ebp),%eax
   11689:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while (size--) {
   1168c:	eb 17                	jmp    116a5 <k_memcpy+0x3d>
        *d++ = *s++;
   1168e:	8b 55 fc             	mov    -0x4(%ebp),%edx
   11691:	8d 42 01             	lea    0x1(%edx),%eax
   11694:	89 45 fc             	mov    %eax,-0x4(%ebp)
   11697:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1169a:	8d 48 01             	lea    0x1(%eax),%ecx
   1169d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   116a0:	0f b6 12             	movzbl (%edx),%edx
   116a3:	88 10                	mov    %dl,(%eax)
    while (size--) {
   116a5:	8b 45 10             	mov    0x10(%ebp),%eax
   116a8:	8d 50 ff             	lea    -0x1(%eax),%edx
   116ab:	89 55 10             	mov    %edx,0x10(%ebp)
   116ae:	85 c0                	test   %eax,%eax
   116b0:	75 dc                	jne    1168e <k_memcpy+0x26>
   116b2:	eb 01                	jmp    116b5 <k_memcpy+0x4d>
        return;
   116b4:	90                   	nop
    }
}
   116b5:	c9                   	leave  
   116b6:	c3                   	ret    

000116b7 <k_memset>:


void k_memset(void* dest, uint8_t v, int size) {
   116b7:	55                   	push   %ebp
   116b8:	89 e5                	mov    %esp,%ebp
   116ba:	83 ec 14             	sub    $0x14,%esp
   116bd:	8b 45 0c             	mov    0xc(%ebp),%eax
   116c0:	88 45 ec             	mov    %al,-0x14(%ebp)
    if(!dest || !size) return;
   116c3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   116c7:	74 2c                	je     116f5 <k_memset+0x3e>
   116c9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   116cd:	74 26                	je     116f5 <k_memset+0x3e>

    uint8_t* d = (uint8_t*) dest;
   116cf:	8b 45 08             	mov    0x8(%ebp),%eax
   116d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while(size--) {
   116d5:	eb 0f                	jmp    116e6 <k_memset+0x2f>
        *d++ = v;
   116d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
   116da:	8d 50 01             	lea    0x1(%eax),%edx
   116dd:	89 55 fc             	mov    %edx,-0x4(%ebp)
   116e0:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
   116e4:	88 10                	mov    %dl,(%eax)
    while(size--) {
   116e6:	8b 45 10             	mov    0x10(%ebp),%eax
   116e9:	8d 50 ff             	lea    -0x1(%eax),%edx
   116ec:	89 55 10             	mov    %edx,0x10(%ebp)
   116ef:	85 c0                	test   %eax,%eax
   116f1:	75 e4                	jne    116d7 <k_memset+0x20>
   116f3:	eb 01                	jmp    116f6 <k_memset+0x3f>
    if(!dest || !size) return;
   116f5:	90                   	nop
    }
}
   116f6:	c9                   	leave  
   116f7:	c3                   	ret    

000116f8 <k_memcmp>:

int k_memcmp(void* d1, void* d2, int size) {
   116f8:	55                   	push   %ebp
   116f9:	89 e5                	mov    %esp,%ebp
   116fb:	83 ec 10             	sub    $0x10,%esp
    if (!d1 || !d2 || size) {
   116fe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
   11702:	74 0c                	je     11710 <k_memcmp+0x18>
   11704:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11708:	74 06                	je     11710 <k_memcmp+0x18>
   1170a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1170e:	74 07                	je     11717 <k_memcmp+0x1f>
        return 1;
   11710:	b8 01 00 00 00       	mov    $0x1,%eax
   11715:	eb 43                	jmp    1175a <k_memcmp+0x62>
    }
    uint8_t *p_d1 = (uint8_t*)d1;
   11717:	8b 45 08             	mov    0x8(%ebp),%eax
   1171a:	89 45 fc             	mov    %eax,-0x4(%ebp)
    uint8_t *p_d2= (uint8_t*)d2;
   1171d:	8b 45 0c             	mov    0xc(%ebp),%eax
   11720:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(size--) {
   11723:	eb 23                	jmp    11748 <k_memcmp+0x50>
        if (*p_d1 ++ != *p_d2++)
   11725:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11728:	8d 50 01             	lea    0x1(%eax),%edx
   1172b:	89 55 fc             	mov    %edx,-0x4(%ebp)
   1172e:	0f b6 08             	movzbl (%eax),%ecx
   11731:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11734:	8d 50 01             	lea    0x1(%eax),%edx
   11737:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1173a:	0f b6 00             	movzbl (%eax),%eax
   1173d:	38 c1                	cmp    %al,%cl
   1173f:	74 07                	je     11748 <k_memcmp+0x50>
        return 1;
   11741:	b8 01 00 00 00       	mov    $0x1,%eax
   11746:	eb 12                	jmp    1175a <k_memcmp+0x62>
    while(size--) {
   11748:	8b 45 10             	mov    0x10(%ebp),%eax
   1174b:	8d 50 ff             	lea    -0x1(%eax),%edx
   1174e:	89 55 10             	mov    %edx,0x10(%ebp)
   11751:	85 c0                	test   %eax,%eax
   11753:	75 d0                	jne    11725 <k_memcmp+0x2d>
    }

    return 0;
   11755:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1175a:	c9                   	leave  
   1175b:	c3                   	ret    

0001175c <k_itoa>:

void k_itoa(char * buf, int num, int base) {
   1175c:	55                   	push   %ebp
   1175d:	89 e5                	mov    %esp,%ebp
   1175f:	83 ec 10             	sub    $0x10,%esp
    static const char * num2ch = {"FEDCBA9876543210123456789ABCDEF"};
    char *p = buf;
   11762:	8b 45 08             	mov    0x8(%ebp),%eax
   11765:	89 45 fc             	mov    %eax,-0x4(%ebp)
    int old_num = num;
   11768:	8b 45 0c             	mov    0xc(%ebp),%eax
   1176b:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if ( (base != 2) && (base != 8) && (base != 10) && (base != 16) ){
   1176e:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
   11772:	74 1d                	je     11791 <k_itoa+0x35>
   11774:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
   11778:	74 17                	je     11791 <k_itoa+0x35>
   1177a:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   1177e:	74 11                	je     11791 <k_itoa+0x35>
   11780:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
   11784:	74 0b                	je     11791 <k_itoa+0x35>
        *p = '\0';
   11786:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11789:	c6 00 00             	movb   $0x0,(%eax)
        return;
   1178c:	e9 a0 00 00 00       	jmp    11831 <k_itoa+0xd5>
    }
    if ( (num < 0) && (base == 10)) {
   11791:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   11795:	79 12                	jns    117a9 <k_itoa+0x4d>
   11797:	83 7d 10 0a          	cmpl   $0xa,0x10(%ebp)
   1179b:	75 0c                	jne    117a9 <k_itoa+0x4d>
        *p++ = '-';
   1179d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   117a0:	8d 50 01             	lea    0x1(%eax),%edx
   117a3:	89 55 fc             	mov    %edx,-0x4(%ebp)
   117a6:	c6 00 2d             	movb   $0x2d,(%eax)
    }

    do {
        char ch = num2ch[ num % base +15 ];
   117a9:	8b 0d 00 50 01 00    	mov    0x15000,%ecx
   117af:	8b 45 0c             	mov    0xc(%ebp),%eax
   117b2:	99                   	cltd   
   117b3:	f7 7d 10             	idivl  0x10(%ebp)
   117b6:	89 d0                	mov    %edx,%eax
   117b8:	83 c0 0f             	add    $0xf,%eax
   117bb:	01 c8                	add    %ecx,%eax
   117bd:	0f b6 00             	movzbl (%eax),%eax
   117c0:	88 45 f3             	mov    %al,-0xd(%ebp)
        *p++ = ch;
   117c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
   117c6:	8d 50 01             	lea    0x1(%eax),%edx
   117c9:	89 55 fc             	mov    %edx,-0x4(%ebp)
   117cc:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
   117d0:	88 10                	mov    %dl,(%eax)
        num /= base;
   117d2:	8b 45 0c             	mov    0xc(%ebp),%eax
   117d5:	99                   	cltd   
   117d6:	f7 7d 10             	idivl  0x10(%ebp)
   117d9:	89 45 0c             	mov    %eax,0xc(%ebp)
    } while(num);
   117dc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   117e0:	75 c7                	jne    117a9 <k_itoa+0x4d>

    *p-- = '\0';
   117e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
   117e5:	8d 50 ff             	lea    -0x1(%eax),%edx
   117e8:	89 55 fc             	mov    %edx,-0x4(%ebp)
   117eb:	c6 00 00             	movb   $0x0,(%eax)

    char *start = (old_num > 0) ? buf : buf + 1;
   117ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   117f2:	7f 08                	jg     117fc <k_itoa+0xa0>
   117f4:	8b 45 08             	mov    0x8(%ebp),%eax
   117f7:	83 c0 01             	add    $0x1,%eax
   117fa:	eb 03                	jmp    117ff <k_itoa+0xa3>
   117fc:	8b 45 08             	mov    0x8(%ebp),%eax
   117ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
    while(start < p) {
   11802:	eb 25                	jmp    11829 <k_itoa+0xcd>
        char ch = *start;
   11804:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11807:	0f b6 00             	movzbl (%eax),%eax
   1180a:	88 45 f2             	mov    %al,-0xe(%ebp)
        *start = *p;
   1180d:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11810:	0f b6 10             	movzbl (%eax),%edx
   11813:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11816:	88 10                	mov    %dl,(%eax)
        *p = ch;
   11818:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1181b:	0f b6 55 f2          	movzbl -0xe(%ebp),%edx
   1181f:	88 10                	mov    %dl,(%eax)

        p--;
   11821:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
        start++;
   11825:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
    while(start < p) {
   11829:	8b 45 f8             	mov    -0x8(%ebp),%eax
   1182c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
   1182f:	72 d3                	jb     11804 <k_itoa+0xa8>
    }
}
   11831:	c9                   	leave  
   11832:	c3                   	ret    

00011833 <k_vsprint>:

void k_vsprint(char *buf, const char *fmt, va_list args) {
   11833:	55                   	push   %ebp
   11834:	89 e5                	mov    %esp,%ebp
   11836:	83 ec 20             	sub    $0x20,%esp
    enum {NORMAL, READ_FMT} state = NORMAL;
   11839:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    char* curr = buf;
   11840:	8b 45 08             	mov    0x8(%ebp),%eax
   11843:	89 45 f8             	mov    %eax,-0x8(%ebp)
    char ch;
    while((ch = *fmt++)) {
   11846:	e9 19 01 00 00       	jmp    11964 <k_vsprint+0x131>
        switch (state) {
   1184b:	8b 45 fc             	mov    -0x4(%ebp),%eax
   1184e:	85 c0                	test   %eax,%eax
   11850:	74 0a                	je     1185c <k_vsprint+0x29>
   11852:	83 f8 01             	cmp    $0x1,%eax
   11855:	74 2b                	je     11882 <k_vsprint+0x4f>
   11857:	e9 07 01 00 00       	jmp    11963 <k_vsprint+0x130>
        case NORMAL:
            if(ch == '%') {
   1185c:	80 7d ef 25          	cmpb   $0x25,-0x11(%ebp)
   11860:	75 0c                	jne    1186e <k_vsprint+0x3b>
                state = READ_FMT;
   11862:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
   11869:	e9 f6 00 00 00       	jmp    11964 <k_vsprint+0x131>
            } else {
                *curr++ = ch;
   1186e:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11871:	8d 50 01             	lea    0x1(%eax),%edx
   11874:	89 55 f8             	mov    %edx,-0x8(%ebp)
   11877:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx
   1187b:	88 10                	mov    %dl,(%eax)
            }
            break;
   1187d:	e9 e2 00 00 00       	jmp    11964 <k_vsprint+0x131>
        case READ_FMT:
            if (ch == 'd') {
   11882:	80 7d ef 64          	cmpb   $0x64,-0x11(%ebp)
   11886:	75 31                	jne    118b9 <k_vsprint+0x86>
                int num  = va_arg(args, int);
   11888:	8b 45 10             	mov    0x10(%ebp),%eax
   1188b:	8d 50 04             	lea    0x4(%eax),%edx
   1188e:	89 55 10             	mov    %edx,0x10(%ebp)
   11891:	8b 00                	mov    (%eax),%eax
   11893:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                k_itoa(curr, num, 10);
   11896:	6a 0a                	push   $0xa
   11898:	ff 75 e4             	pushl  -0x1c(%ebp)
   1189b:	ff 75 f8             	pushl  -0x8(%ebp)
   1189e:	e8 b9 fe ff ff       	call   1175c <k_itoa>
   118a3:	83 c4 0c             	add    $0xc,%esp
                curr += k_strlen(curr);
   118a6:	ff 75 f8             	pushl  -0x8(%ebp)
   118a9:	e8 7f fd ff ff       	call   1162d <k_strlen>
   118ae:	83 c4 04             	add    $0x4,%esp
   118b1:	01 45 f8             	add    %eax,-0x8(%ebp)
   118b4:	e9 a1 00 00 00       	jmp    1195a <k_vsprint+0x127>
                
            }else if (ch == 'x') {
   118b9:	80 7d ef 78          	cmpb   $0x78,-0x11(%ebp)
   118bd:	75 2e                	jne    118ed <k_vsprint+0xba>
                int num  = va_arg(args, int);
   118bf:	8b 45 10             	mov    0x10(%ebp),%eax
   118c2:	8d 50 04             	lea    0x4(%eax),%edx
   118c5:	89 55 10             	mov    %edx,0x10(%ebp)
   118c8:	8b 00                	mov    (%eax),%eax
   118ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
                k_itoa(curr, num, 16);
   118cd:	6a 10                	push   $0x10
   118cf:	ff 75 e8             	pushl  -0x18(%ebp)
   118d2:	ff 75 f8             	pushl  -0x8(%ebp)
   118d5:	e8 82 fe ff ff       	call   1175c <k_itoa>
   118da:	83 c4 0c             	add    $0xc,%esp
                curr += k_strlen(curr);
   118dd:	ff 75 f8             	pushl  -0x8(%ebp)
   118e0:	e8 48 fd ff ff       	call   1162d <k_strlen>
   118e5:	83 c4 04             	add    $0x4,%esp
   118e8:	01 45 f8             	add    %eax,-0x8(%ebp)
   118eb:	eb 6d                	jmp    1195a <k_vsprint+0x127>

            }else if (ch == 'c') {
   118ed:	80 7d ef 63          	cmpb   $0x63,-0x11(%ebp)
   118f1:	75 1f                	jne    11912 <k_vsprint+0xdf>
                char c  = va_arg(args, int);
   118f3:	8b 45 10             	mov    0x10(%ebp),%eax
   118f6:	8d 50 04             	lea    0x4(%eax),%edx
   118f9:	89 55 10             	mov    %edx,0x10(%ebp)
   118fc:	8b 00                	mov    (%eax),%eax
   118fe:	88 45 ee             	mov    %al,-0x12(%ebp)
                *curr++ = c;
   11901:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11904:	8d 50 01             	lea    0x1(%eax),%edx
   11907:	89 55 f8             	mov    %edx,-0x8(%ebp)
   1190a:	0f b6 55 ee          	movzbl -0x12(%ebp),%edx
   1190e:	88 10                	mov    %dl,(%eax)
   11910:	eb 48                	jmp    1195a <k_vsprint+0x127>

            }else if (ch == 's') {
   11912:	80 7d ef 73          	cmpb   $0x73,-0x11(%ebp)
   11916:	75 42                	jne    1195a <k_vsprint+0x127>
                const char* str = va_arg(args, char*);
   11918:	8b 45 10             	mov    0x10(%ebp),%eax
   1191b:	8d 50 04             	lea    0x4(%eax),%edx
   1191e:	89 55 10             	mov    %edx,0x10(%ebp)
   11921:	8b 00                	mov    (%eax),%eax
   11923:	89 45 f4             	mov    %eax,-0xc(%ebp)
                int len = k_strlen(str);
   11926:	ff 75 f4             	pushl  -0xc(%ebp)
   11929:	e8 ff fc ff ff       	call   1162d <k_strlen>
   1192e:	83 c4 04             	add    $0x4,%esp
   11931:	89 45 f0             	mov    %eax,-0x10(%ebp)
                while(len--) {
   11934:	eb 17                	jmp    1194d <k_vsprint+0x11a>
                    *curr++ = *str++;
   11936:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11939:	8d 42 01             	lea    0x1(%edx),%eax
   1193c:	89 45 f4             	mov    %eax,-0xc(%ebp)
   1193f:	8b 45 f8             	mov    -0x8(%ebp),%eax
   11942:	8d 48 01             	lea    0x1(%eax),%ecx
   11945:	89 4d f8             	mov    %ecx,-0x8(%ebp)
   11948:	0f b6 12             	movzbl (%edx),%edx
   1194b:	88 10                	mov    %dl,(%eax)
                while(len--) {
   1194d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11950:	8d 50 ff             	lea    -0x1(%eax),%edx
   11953:	89 55 f0             	mov    %edx,-0x10(%ebp)
   11956:	85 c0                	test   %eax,%eax
   11958:	75 dc                	jne    11936 <k_vsprint+0x103>
                }
            }
            state = NORMAL;
   1195a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
            break;
   11961:	eb 01                	jmp    11964 <k_vsprint+0x131>
        
        default:
            break;
   11963:	90                   	nop
    while((ch = *fmt++)) {
   11964:	8b 45 0c             	mov    0xc(%ebp),%eax
   11967:	8d 50 01             	lea    0x1(%eax),%edx
   1196a:	89 55 0c             	mov    %edx,0xc(%ebp)
   1196d:	0f b6 00             	movzbl (%eax),%eax
   11970:	88 45 ef             	mov    %al,-0x11(%ebp)
   11973:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
   11977:	0f 85 ce fe ff ff    	jne    1184b <k_vsprint+0x18>
        }
    }
   1197d:	90                   	nop
   1197e:	c9                   	leave  
   1197f:	c3                   	ret    

00011980 <list_is_empty>:
static inline int list_is_empty (list_t* list) {
   11980:	55                   	push   %ebp
   11981:	89 e5                	mov    %esp,%ebp
    return list->count == 0;
   11983:	8b 45 08             	mov    0x8(%ebp),%eax
   11986:	8b 40 08             	mov    0x8(%eax),%eax
   11989:	85 c0                	test   %eax,%eax
   1198b:	0f 94 c0             	sete   %al
   1198e:	0f b6 c0             	movzbl %al,%eax
}
   11991:	5d                   	pop    %ebp
   11992:	c3                   	ret    

00011993 <list_init>:
#include <list.h>

void list_init(list_t* list) {
   11993:	55                   	push   %ebp
   11994:	89 e5                	mov    %esp,%ebp
    list->first = list->last = (list_node_t*)0;
   11996:	8b 45 08             	mov    0x8(%ebp),%eax
   11999:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   119a0:	8b 45 08             	mov    0x8(%ebp),%eax
   119a3:	8b 50 04             	mov    0x4(%eax),%edx
   119a6:	8b 45 08             	mov    0x8(%ebp),%eax
   119a9:	89 10                	mov    %edx,(%eax)
    list->count = 0;
   119ab:	8b 45 08             	mov    0x8(%ebp),%eax
   119ae:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
}
   119b5:	90                   	nop
   119b6:	5d                   	pop    %ebp
   119b7:	c3                   	ret    

000119b8 <list_insert_first>:

void list_insert_first (list_t* list, list_node_t* node) {
   119b8:	55                   	push   %ebp
   119b9:	89 e5                	mov    %esp,%ebp
    node->next = list->first;
   119bb:	8b 45 08             	mov    0x8(%ebp),%eax
   119be:	8b 10                	mov    (%eax),%edx
   119c0:	8b 45 0c             	mov    0xc(%ebp),%eax
   119c3:	89 50 04             	mov    %edx,0x4(%eax)
    node->pre = (list_node_t*)0;
   119c6:	8b 45 0c             	mov    0xc(%ebp),%eax
   119c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    if(list_is_empty(list)) {
   119cf:	ff 75 08             	pushl  0x8(%ebp)
   119d2:	e8 a9 ff ff ff       	call   11980 <list_is_empty>
   119d7:	83 c4 04             	add    $0x4,%esp
   119da:	85 c0                	test   %eax,%eax
   119dc:	74 15                	je     119f3 <list_insert_first+0x3b>
        list->last = list->first = node;
   119de:	8b 45 08             	mov    0x8(%ebp),%eax
   119e1:	8b 55 0c             	mov    0xc(%ebp),%edx
   119e4:	89 10                	mov    %edx,(%eax)
   119e6:	8b 45 08             	mov    0x8(%ebp),%eax
   119e9:	8b 10                	mov    (%eax),%edx
   119eb:	8b 45 08             	mov    0x8(%ebp),%eax
   119ee:	89 50 04             	mov    %edx,0x4(%eax)
   119f1:	eb 12                	jmp    11a05 <list_insert_first+0x4d>
    } else {
        list->first->pre = node;
   119f3:	8b 45 08             	mov    0x8(%ebp),%eax
   119f6:	8b 00                	mov    (%eax),%eax
   119f8:	8b 55 0c             	mov    0xc(%ebp),%edx
   119fb:	89 10                	mov    %edx,(%eax)
        list->first = node;
   119fd:	8b 45 08             	mov    0x8(%ebp),%eax
   11a00:	8b 55 0c             	mov    0xc(%ebp),%edx
   11a03:	89 10                	mov    %edx,(%eax)
    }

    list->count++;
   11a05:	8b 45 08             	mov    0x8(%ebp),%eax
   11a08:	8b 40 08             	mov    0x8(%eax),%eax
   11a0b:	8d 50 01             	lea    0x1(%eax),%edx
   11a0e:	8b 45 08             	mov    0x8(%ebp),%eax
   11a11:	89 50 08             	mov    %edx,0x8(%eax)
}
   11a14:	90                   	nop
   11a15:	c9                   	leave  
   11a16:	c3                   	ret    

00011a17 <list_insert_last>:

void list_insert_last (list_t* list, list_node_t* node) {
   11a17:	55                   	push   %ebp
   11a18:	89 e5                	mov    %esp,%ebp
    node->pre = list->last;
   11a1a:	8b 45 08             	mov    0x8(%ebp),%eax
   11a1d:	8b 50 04             	mov    0x4(%eax),%edx
   11a20:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a23:	89 10                	mov    %edx,(%eax)
    node->next = (list_node_t*)0;
   11a25:	8b 45 0c             	mov    0xc(%ebp),%eax
   11a28:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    if(list_is_empty(list)) {
   11a2f:	ff 75 08             	pushl  0x8(%ebp)
   11a32:	e8 49 ff ff ff       	call   11980 <list_is_empty>
   11a37:	83 c4 04             	add    $0x4,%esp
   11a3a:	85 c0                	test   %eax,%eax
   11a3c:	74 16                	je     11a54 <list_insert_last+0x3d>
        list->first = list->last = node;
   11a3e:	8b 45 08             	mov    0x8(%ebp),%eax
   11a41:	8b 55 0c             	mov    0xc(%ebp),%edx
   11a44:	89 50 04             	mov    %edx,0x4(%eax)
   11a47:	8b 45 08             	mov    0x8(%ebp),%eax
   11a4a:	8b 50 04             	mov    0x4(%eax),%edx
   11a4d:	8b 45 08             	mov    0x8(%ebp),%eax
   11a50:	89 10                	mov    %edx,(%eax)
   11a52:	eb 15                	jmp    11a69 <list_insert_last+0x52>
    } else {
        list->last->next = node;
   11a54:	8b 45 08             	mov    0x8(%ebp),%eax
   11a57:	8b 40 04             	mov    0x4(%eax),%eax
   11a5a:	8b 55 0c             	mov    0xc(%ebp),%edx
   11a5d:	89 50 04             	mov    %edx,0x4(%eax)
        list->last = node;
   11a60:	8b 45 08             	mov    0x8(%ebp),%eax
   11a63:	8b 55 0c             	mov    0xc(%ebp),%edx
   11a66:	89 50 04             	mov    %edx,0x4(%eax)
    }

    list->count++;
   11a69:	8b 45 08             	mov    0x8(%ebp),%eax
   11a6c:	8b 40 08             	mov    0x8(%eax),%eax
   11a6f:	8d 50 01             	lea    0x1(%eax),%edx
   11a72:	8b 45 08             	mov    0x8(%ebp),%eax
   11a75:	89 50 08             	mov    %edx,0x8(%eax)
}
   11a78:	90                   	nop
   11a79:	c9                   	leave  
   11a7a:	c3                   	ret    

00011a7b <list_delete_first>:


list_node_t* list_delete_first (list_t* list) {
   11a7b:	55                   	push   %ebp
   11a7c:	89 e5                	mov    %esp,%ebp
   11a7e:	83 ec 10             	sub    $0x10,%esp
    if(list_is_empty(list)) {
   11a81:	ff 75 08             	pushl  0x8(%ebp)
   11a84:	e8 f7 fe ff ff       	call   11980 <list_is_empty>
   11a89:	83 c4 04             	add    $0x4,%esp
   11a8c:	85 c0                	test   %eax,%eax
   11a8e:	74 07                	je     11a97 <list_delete_first+0x1c>
        return (list_node_t*)0;
   11a90:	b8 00 00 00 00       	mov    $0x0,%eax
   11a95:	eb 5b                	jmp    11af2 <list_delete_first+0x77>
    }

    list_node_t* remove_node = list->first;
   11a97:	8b 45 08             	mov    0x8(%ebp),%eax
   11a9a:	8b 00                	mov    (%eax),%eax
   11a9c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    list->first = remove_node->next;
   11a9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11aa2:	8b 50 04             	mov    0x4(%eax),%edx
   11aa5:	8b 45 08             	mov    0x8(%ebp),%eax
   11aa8:	89 10                	mov    %edx,(%eax)

    if( list->first == (list_node_t*)0 ) {
   11aaa:	8b 45 08             	mov    0x8(%ebp),%eax
   11aad:	8b 00                	mov    (%eax),%eax
   11aaf:	85 c0                	test   %eax,%eax
   11ab1:	75 0c                	jne    11abf <list_delete_first+0x44>
        list->last = (list_node_t*)0;
   11ab3:	8b 45 08             	mov    0x8(%ebp),%eax
   11ab6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11abd:	eb 0c                	jmp    11acb <list_delete_first+0x50>
    } else {
        remove_node->next->pre = (list_node_t*)0;
   11abf:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ac2:	8b 40 04             	mov    0x4(%eax),%eax
   11ac5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        //list->first->pre = (list_node_t*)0;
    }

    remove_node->pre = remove_node->next = (list_node_t*)0;
   11acb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ace:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11ad5:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ad8:	8b 50 04             	mov    0x4(%eax),%edx
   11adb:	8b 45 fc             	mov    -0x4(%ebp),%eax
   11ade:	89 10                	mov    %edx,(%eax)
    list->count--;
   11ae0:	8b 45 08             	mov    0x8(%ebp),%eax
   11ae3:	8b 40 08             	mov    0x8(%eax),%eax
   11ae6:	8d 50 ff             	lea    -0x1(%eax),%edx
   11ae9:	8b 45 08             	mov    0x8(%ebp),%eax
   11aec:	89 50 08             	mov    %edx,0x8(%eax)

    return remove_node;
   11aef:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11af2:	c9                   	leave  
   11af3:	c3                   	ret    

00011af4 <list_delete>:

list_node_t* list_delete (list_t* list, list_node_t* node) {
   11af4:	55                   	push   %ebp
   11af5:	89 e5                	mov    %esp,%ebp
    if(node == list->first) {
   11af7:	8b 45 08             	mov    0x8(%ebp),%eax
   11afa:	8b 00                	mov    (%eax),%eax
   11afc:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11aff:	75 0b                	jne    11b0c <list_delete+0x18>
        list->first = node->next;
   11b01:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b04:	8b 50 04             	mov    0x4(%eax),%edx
   11b07:	8b 45 08             	mov    0x8(%ebp),%eax
   11b0a:	89 10                	mov    %edx,(%eax)
    }
    if(node == list->last) {
   11b0c:	8b 45 08             	mov    0x8(%ebp),%eax
   11b0f:	8b 40 04             	mov    0x4(%eax),%eax
   11b12:	39 45 0c             	cmp    %eax,0xc(%ebp)
   11b15:	75 0b                	jne    11b22 <list_delete+0x2e>
        list->last = node->pre;
   11b17:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b1a:	8b 10                	mov    (%eax),%edx
   11b1c:	8b 45 08             	mov    0x8(%ebp),%eax
   11b1f:	89 50 04             	mov    %edx,0x4(%eax)
    }

    if(node->pre) {
   11b22:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b25:	8b 00                	mov    (%eax),%eax
   11b27:	85 c0                	test   %eax,%eax
   11b29:	74 0e                	je     11b39 <list_delete+0x45>
        node->pre->next = node->next;
   11b2b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b2e:	8b 00                	mov    (%eax),%eax
   11b30:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b33:	8b 52 04             	mov    0x4(%edx),%edx
   11b36:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if(node->next) {
   11b39:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b3c:	8b 40 04             	mov    0x4(%eax),%eax
   11b3f:	85 c0                	test   %eax,%eax
   11b41:	74 0d                	je     11b50 <list_delete+0x5c>
        node->next->pre = node->pre;
   11b43:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b46:	8b 40 04             	mov    0x4(%eax),%eax
   11b49:	8b 55 0c             	mov    0xc(%ebp),%edx
   11b4c:	8b 12                	mov    (%edx),%edx
   11b4e:	89 10                	mov    %edx,(%eax)
    }

    node->pre = node->next = (list_node_t*)0;
   11b50:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b53:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   11b5a:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b5d:	8b 50 04             	mov    0x4(%eax),%edx
   11b60:	8b 45 0c             	mov    0xc(%ebp),%eax
   11b63:	89 10                	mov    %edx,(%eax)

    list->count--;
   11b65:	8b 45 08             	mov    0x8(%ebp),%eax
   11b68:	8b 40 08             	mov    0x8(%eax),%eax
   11b6b:	8d 50 ff             	lea    -0x1(%eax),%edx
   11b6e:	8b 45 08             	mov    0x8(%ebp),%eax
   11b71:	89 50 08             	mov    %edx,0x8(%eax)
    return node;
   11b74:	8b 45 0c             	mov    0xc(%ebp),%eax
}
   11b77:	5d                   	pop    %ebp
   11b78:	c3                   	ret    

00011b79 <inb>:
static inline uint8_t inb(uint16_t  port) {
   11b79:	55                   	push   %ebp
   11b7a:	89 e5                	mov    %esp,%ebp
   11b7c:	83 ec 14             	sub    $0x14,%esp
   11b7f:	8b 45 08             	mov    0x8(%ebp),%eax
   11b82:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	__asm__ __volatile__("inb %[p], %[v]" : [v]"=a" (rv) : [p]"d"(port));
   11b86:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
   11b8a:	89 c2                	mov    %eax,%edx
   11b8c:	ec                   	in     (%dx),%al
   11b8d:	88 45 ff             	mov    %al,-0x1(%ebp)
	return rv;
   11b90:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
   11b94:	c9                   	leave  
   11b95:	c3                   	ret    

00011b96 <outb>:
static inline void outb(uint16_t port, uint8_t data) {
   11b96:	55                   	push   %ebp
   11b97:	89 e5                	mov    %esp,%ebp
   11b99:	83 ec 08             	sub    $0x8,%esp
   11b9c:	8b 55 08             	mov    0x8(%ebp),%edx
   11b9f:	8b 45 0c             	mov    0xc(%ebp),%eax
   11ba2:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
   11ba6:	88 45 f8             	mov    %al,-0x8(%ebp)
	__asm__ __volatile__("outb %[v], %[p]" : : [p]"d" (port), [v]"a" (data));
   11ba9:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
   11bad:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
   11bb1:	ee                   	out    %al,(%dx)
}
   11bb2:	90                   	nop
   11bb3:	c9                   	leave  
   11bb4:	c3                   	ret    

00011bb5 <log_init>:

#define COM1_PORT       0x3f8

static mutex_t mutex;

void log_init() {
   11bb5:	55                   	push   %ebp
   11bb6:	89 e5                	mov    %esp,%ebp
   11bb8:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&mutex);
   11bbb:	83 ec 0c             	sub    $0xc,%esp
   11bbe:	68 60 fc 02 00       	push   $0x2fc60
   11bc3:	e8 b1 0c 00 00       	call   12879 <mutex_init>
   11bc8:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT + 1, 0x00);
   11bcb:	83 ec 08             	sub    $0x8,%esp
   11bce:	6a 00                	push   $0x0
   11bd0:	68 f9 03 00 00       	push   $0x3f9
   11bd5:	e8 bc ff ff ff       	call   11b96 <outb>
   11bda:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT + 3, 0x80);
   11bdd:	83 ec 08             	sub    $0x8,%esp
   11be0:	68 80 00 00 00       	push   $0x80
   11be5:	68 fb 03 00 00       	push   $0x3fb
   11bea:	e8 a7 ff ff ff       	call   11b96 <outb>
   11bef:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT + 0, 0x3);
   11bf2:	83 ec 08             	sub    $0x8,%esp
   11bf5:	6a 03                	push   $0x3
   11bf7:	68 f8 03 00 00       	push   $0x3f8
   11bfc:	e8 95 ff ff ff       	call   11b96 <outb>
   11c01:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT + 1, 0x00);
   11c04:	83 ec 08             	sub    $0x8,%esp
   11c07:	6a 00                	push   $0x0
   11c09:	68 f9 03 00 00       	push   $0x3f9
   11c0e:	e8 83 ff ff ff       	call   11b96 <outb>
   11c13:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT + 3, 0x03);
   11c16:	83 ec 08             	sub    $0x8,%esp
   11c19:	6a 03                	push   $0x3
   11c1b:	68 fb 03 00 00       	push   $0x3fb
   11c20:	e8 71 ff ff ff       	call   11b96 <outb>
   11c25:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT + 2, 0xc7);
   11c28:	83 ec 08             	sub    $0x8,%esp
   11c2b:	68 c7 00 00 00       	push   $0xc7
   11c30:	68 fa 03 00 00       	push   $0x3fa
   11c35:	e8 5c ff ff ff       	call   11b96 <outb>
   11c3a:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT + 4, 0x0f);
   11c3d:	83 ec 08             	sub    $0x8,%esp
   11c40:	6a 0f                	push   $0xf
   11c42:	68 fc 03 00 00       	push   $0x3fc
   11c47:	e8 4a ff ff ff       	call   11b96 <outb>
   11c4c:	83 c4 10             	add    $0x10,%esp
}
   11c4f:	90                   	nop
   11c50:	c9                   	leave  
   11c51:	c3                   	ret    

00011c52 <klog>:


void klog(const char* fmt, ...) {
   11c52:	55                   	push   %ebp
   11c53:	89 e5                	mov    %esp,%ebp
   11c55:	81 ec 98 00 00 00    	sub    $0x98,%esp
    char buf[128];
    k_memset(buf, 0, 128);
   11c5b:	83 ec 04             	sub    $0x4,%esp
   11c5e:	68 80 00 00 00       	push   $0x80
   11c63:	6a 00                	push   $0x0
   11c65:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   11c6b:	50                   	push   %eax
   11c6c:	e8 46 fa ff ff       	call   116b7 <k_memset>
   11c71:	83 c4 10             	add    $0x10,%esp
    va_list args;
    va_start(args, fmt);
   11c74:	8d 45 0c             	lea    0xc(%ebp),%eax
   11c77:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
    k_vsprint(buf, fmt, args);
   11c7d:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
   11c83:	83 ec 04             	sub    $0x4,%esp
   11c86:	50                   	push   %eax
   11c87:	ff 75 08             	pushl  0x8(%ebp)
   11c8a:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   11c90:	50                   	push   %eax
   11c91:	e8 9d fb ff ff       	call   11833 <k_vsprint>
   11c96:	83 c4 10             	add    $0x10,%esp
    va_end(args);

    mutex_lock(&mutex);
   11c99:	83 ec 0c             	sub    $0xc,%esp
   11c9c:	68 60 fc 02 00       	push   $0x2fc60
   11ca1:	e8 01 0c 00 00       	call   128a7 <mutex_lock>
   11ca6:	83 c4 10             	add    $0x10,%esp
    // irq_state_t state = irq_enter_proection();

    const char *p = buf;
   11ca9:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
   11caf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while(*p != '\0') {
   11cb2:	eb 3b                	jmp    11cef <klog+0x9d>
        while( (inb(COM1_PORT + 5) & (1 << 6)) == 0);
   11cb4:	90                   	nop
   11cb5:	83 ec 0c             	sub    $0xc,%esp
   11cb8:	68 fd 03 00 00       	push   $0x3fd
   11cbd:	e8 b7 fe ff ff       	call   11b79 <inb>
   11cc2:	83 c4 10             	add    $0x10,%esp
   11cc5:	0f b6 c0             	movzbl %al,%eax
   11cc8:	83 e0 40             	and    $0x40,%eax
   11ccb:	85 c0                	test   %eax,%eax
   11ccd:	74 e6                	je     11cb5 <klog+0x63>
        outb(COM1_PORT, *p++);
   11ccf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cd2:	8d 50 01             	lea    0x1(%eax),%edx
   11cd5:	89 55 f4             	mov    %edx,-0xc(%ebp)
   11cd8:	0f b6 00             	movzbl (%eax),%eax
   11cdb:	0f b6 c0             	movzbl %al,%eax
   11cde:	83 ec 08             	sub    $0x8,%esp
   11ce1:	50                   	push   %eax
   11ce2:	68 f8 03 00 00       	push   $0x3f8
   11ce7:	e8 aa fe ff ff       	call   11b96 <outb>
   11cec:	83 c4 10             	add    $0x10,%esp
    while(*p != '\0') {
   11cef:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11cf2:	0f b6 00             	movzbl (%eax),%eax
   11cf5:	84 c0                	test   %al,%al
   11cf7:	75 bb                	jne    11cb4 <klog+0x62>
    }
    outb(COM1_PORT, '\r');  // 回到0列
   11cf9:	83 ec 08             	sub    $0x8,%esp
   11cfc:	6a 0d                	push   $0xd
   11cfe:	68 f8 03 00 00       	push   $0x3f8
   11d03:	e8 8e fe ff ff       	call   11b96 <outb>
   11d08:	83 c4 10             	add    $0x10,%esp
    outb(COM1_PORT, '\n');  // 向下一行
   11d0b:	83 ec 08             	sub    $0x8,%esp
   11d0e:	6a 0a                	push   $0xa
   11d10:	68 f8 03 00 00       	push   $0x3f8
   11d15:	e8 7c fe ff ff       	call   11b96 <outb>
   11d1a:	83 c4 10             	add    $0x10,%esp

    mutex_unlock(&mutex);
   11d1d:	83 ec 0c             	sub    $0xc,%esp
   11d20:	68 60 fc 02 00       	push   $0x2fc60
   11d25:	e8 11 0c 00 00       	call   1293b <mutex_unlock>
   11d2a:	83 c4 10             	add    $0x10,%esp
    // irq_leave_proection(state);

}
   11d2d:	90                   	nop
   11d2e:	c9                   	leave  
   11d2f:	c3                   	ret    

00011d30 <down2>:

uint32_t memory_create_uvm();

void memory_init (boot_info_t* boot_info);

static inline uint32_t down2(uint32_t size, uint32_t bound) {
   11d30:	55                   	push   %ebp
   11d31:	89 e5                	mov    %esp,%ebp
    return size & ~ (bound - 1);
   11d33:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d36:	f7 d8                	neg    %eax
   11d38:	23 45 08             	and    0x8(%ebp),%eax
}
   11d3b:	5d                   	pop    %ebp
   11d3c:	c3                   	ret    

00011d3d <up2>:
static inline uint32_t up2(uint32_t size, uint32_t bound) {
   11d3d:	55                   	push   %ebp
   11d3e:	89 e5                	mov    %esp,%ebp
    return (size + bound - 1) & ~ (bound - 1);
   11d40:	8b 55 08             	mov    0x8(%ebp),%edx
   11d43:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d46:	01 d0                	add    %edx,%eax
   11d48:	8d 50 ff             	lea    -0x1(%eax),%edx
   11d4b:	8b 45 0c             	mov    0xc(%ebp),%eax
   11d4e:	f7 d8                	neg    %eax
   11d50:	21 d0                	and    %edx,%eax
}
   11d52:	5d                   	pop    %ebp
   11d53:	c3                   	ret    

00011d54 <write_cr3>:
static inline void write_cr3(uint32_t v) {
   11d54:	55                   	push   %ebp
   11d55:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3"::[v]"r"(v));
   11d57:	8b 45 08             	mov    0x8(%ebp),%eax
   11d5a:	0f 22 d8             	mov    %eax,%cr3
}
   11d5d:	90                   	nop
   11d5e:	5d                   	pop    %ebp
   11d5f:	c3                   	ret    

00011d60 <mmu_set_page_dir>:
    };
}pte_t;
#pragma pack()


static inline void mmu_set_page_dir(uint32_t paddr) {
   11d60:	55                   	push   %ebp
   11d61:	89 e5                	mov    %esp,%ebp
    write_cr3(paddr);
   11d63:	ff 75 08             	pushl  0x8(%ebp)
   11d66:	e8 e9 ff ff ff       	call   11d54 <write_cr3>
   11d6b:	83 c4 04             	add    $0x4,%esp
}
   11d6e:	90                   	nop
   11d6f:	c9                   	leave  
   11d70:	c3                   	ret    

00011d71 <pde_index>:

static inline uint32_t pde_index (uint32_t vaddr) {
   11d71:	55                   	push   %ebp
   11d72:	89 e5                	mov    %esp,%ebp
   11d74:	83 ec 10             	sub    $0x10,%esp
    int index = (vaddr >> 22);      // 只取高10位
   11d77:	8b 45 08             	mov    0x8(%ebp),%eax
   11d7a:	c1 e8 16             	shr    $0x16,%eax
   11d7d:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return index;
   11d80:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   11d83:	c9                   	leave  
   11d84:	c3                   	ret    

00011d85 <pde_paddr>:


static inline uint32_t pde_paddr (pde_t * pde) {
   11d85:	55                   	push   %ebp
   11d86:	89 e5                	mov    %esp,%ebp
    return pde->phy_pt_addr << 12;
   11d88:	8b 45 08             	mov    0x8(%ebp),%eax
   11d8b:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   11d8f:	c0 ea 04             	shr    $0x4,%dl
   11d92:	0f b6 d2             	movzbl %dl,%edx
   11d95:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   11d99:	c1 e1 04             	shl    $0x4,%ecx
   11d9c:	09 ca                	or     %ecx,%edx
   11d9e:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   11da2:	c1 e0 0c             	shl    $0xc,%eax
   11da5:	09 d0                	or     %edx,%eax
   11da7:	c1 e0 0c             	shl    $0xc,%eax
}
   11daa:	5d                   	pop    %ebp
   11dab:	c3                   	ret    

00011dac <pte_index>:


static inline int pte_index (uint32_t vaddr) {
   11dac:	55                   	push   %ebp
   11dad:	89 e5                	mov    %esp,%ebp
    return (vaddr >> 12) & 0x3FF;   // 取中间10位
   11daf:	8b 45 08             	mov    0x8(%ebp),%eax
   11db2:	c1 e8 0c             	shr    $0xc,%eax
   11db5:	25 ff 03 00 00       	and    $0x3ff,%eax
}
   11dba:	5d                   	pop    %ebp
   11dbb:	c3                   	ret    

00011dbc <pte_paddr>:


static inline uint32_t pte_paddr (pte_t * pte) {
   11dbc:	55                   	push   %ebp
   11dbd:	89 e5                	mov    %esp,%ebp
    return pte->phy_page_addr << 12;
   11dbf:	8b 45 08             	mov    0x8(%ebp),%eax
   11dc2:	0f b6 50 01          	movzbl 0x1(%eax),%edx
   11dc6:	c0 ea 04             	shr    $0x4,%dl
   11dc9:	0f b6 d2             	movzbl %dl,%edx
   11dcc:	0f b6 48 02          	movzbl 0x2(%eax),%ecx
   11dd0:	c1 e1 04             	shl    $0x4,%ecx
   11dd3:	09 ca                	or     %ecx,%edx
   11dd5:	0f b6 40 03          	movzbl 0x3(%eax),%eax
   11dd9:	c1 e0 0c             	shl    $0xc,%eax
   11ddc:	09 d0                	or     %edx,%eax
   11dde:	c1 e0 0c             	shl    $0xc,%eax
}
   11de1:	5d                   	pop    %ebp
   11de2:	c3                   	ret    

00011de3 <get_pte_perm>:

static inline uint32_t get_pte_perm (pte_t * pte) {
   11de3:	55                   	push   %ebp
   11de4:	89 e5                	mov    %esp,%ebp
    return (pte->v & 0x1FF);                   
   11de6:	8b 45 08             	mov    0x8(%ebp),%eax
   11de9:	8b 00                	mov    (%eax),%eax
   11deb:	25 ff 01 00 00       	and    $0x1ff,%eax
}
   11df0:	5d                   	pop    %ebp
   11df1:	c3                   	ret    

00011df2 <addr_alloc_init>:
static pde_t g_kernel_page_dir[PDE_CNT] __attribute__( (aligned(MEM_PAGE_SIZE)) );


static void 
addr_alloc_init(addr_alloc_t * alloc, uint8_t* bits, uint32_t start, 
uint32_t size, uint32_t page_size) {
   11df2:	55                   	push   %ebp
   11df3:	89 e5                	mov    %esp,%ebp
   11df5:	83 ec 08             	sub    $0x8,%esp
    mutex_init(&alloc->mutex);
   11df8:	8b 45 08             	mov    0x8(%ebp),%eax
   11dfb:	83 ec 0c             	sub    $0xc,%esp
   11dfe:	50                   	push   %eax
   11dff:	e8 75 0a 00 00       	call   12879 <mutex_init>
   11e04:	83 c4 10             	add    $0x10,%esp
    alloc->start = start;
   11e07:	8b 45 08             	mov    0x8(%ebp),%eax
   11e0a:	8b 55 10             	mov    0x10(%ebp),%edx
   11e0d:	89 50 1c             	mov    %edx,0x1c(%eax)
    alloc->size = size;
   11e10:	8b 45 08             	mov    0x8(%ebp),%eax
   11e13:	8b 55 14             	mov    0x14(%ebp),%edx
   11e16:	89 50 20             	mov    %edx,0x20(%eax)
    alloc->page_size = page_size;
   11e19:	8b 45 08             	mov    0x8(%ebp),%eax
   11e1c:	8b 55 18             	mov    0x18(%ebp),%edx
   11e1f:	89 50 24             	mov    %edx,0x24(%eax)
    bitmap_init(&alloc->bitmap, bits, alloc->size / page_size, 0);
   11e22:	8b 45 08             	mov    0x8(%ebp),%eax
   11e25:	8b 40 20             	mov    0x20(%eax),%eax
   11e28:	ba 00 00 00 00       	mov    $0x0,%edx
   11e2d:	f7 75 18             	divl   0x18(%ebp)
   11e30:	89 c2                	mov    %eax,%edx
   11e32:	8b 45 08             	mov    0x8(%ebp),%eax
   11e35:	83 c0 14             	add    $0x14,%eax
   11e38:	6a 00                	push   $0x0
   11e3a:	52                   	push   %edx
   11e3b:	ff 75 0c             	pushl  0xc(%ebp)
   11e3e:	50                   	push   %eax
   11e3f:	e8 16 f4 ff ff       	call   1125a <bitmap_init>
   11e44:	83 c4 10             	add    $0x10,%esp
}
   11e47:	90                   	nop
   11e48:	c9                   	leave  
   11e49:	c3                   	ret    

00011e4a <addr_alloc_page>:


static uint32_t 
addr_alloc_page (addr_alloc_t * alloc, int page_count) {
   11e4a:	55                   	push   %ebp
   11e4b:	89 e5                	mov    %esp,%ebp
   11e4d:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr = 0;
   11e50:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    mutex_lock(&alloc->mutex);
   11e57:	8b 45 08             	mov    0x8(%ebp),%eax
   11e5a:	83 ec 0c             	sub    $0xc,%esp
   11e5d:	50                   	push   %eax
   11e5e:	e8 44 0a 00 00       	call   128a7 <mutex_lock>
   11e63:	83 c4 10             	add    $0x10,%esp

    int page_index = bitmap_alloc_nbits(&alloc->bitmap, 0, page_count);
   11e66:	8b 45 08             	mov    0x8(%ebp),%eax
   11e69:	83 c0 14             	add    $0x14,%eax
   11e6c:	83 ec 04             	sub    $0x4,%esp
   11e6f:	ff 75 0c             	pushl  0xc(%ebp)
   11e72:	6a 00                	push   $0x0
   11e74:	50                   	push   %eax
   11e75:	e8 5c f5 ff ff       	call   113d6 <bitmap_alloc_nbits>
   11e7a:	83 c4 10             	add    $0x10,%esp
   11e7d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (page_index >= 0) {
   11e80:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   11e84:	78 17                	js     11e9d <addr_alloc_page+0x53>
        addr = alloc->start + page_index * alloc->page_size;
   11e86:	8b 45 08             	mov    0x8(%ebp),%eax
   11e89:	8b 50 1c             	mov    0x1c(%eax),%edx
   11e8c:	8b 45 08             	mov    0x8(%ebp),%eax
   11e8f:	8b 48 24             	mov    0x24(%eax),%ecx
   11e92:	8b 45 f0             	mov    -0x10(%ebp),%eax
   11e95:	0f af c1             	imul   %ecx,%eax
   11e98:	01 d0                	add    %edx,%eax
   11e9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    mutex_unlock(&alloc->mutex);
   11e9d:	8b 45 08             	mov    0x8(%ebp),%eax
   11ea0:	83 ec 0c             	sub    $0xc,%esp
   11ea3:	50                   	push   %eax
   11ea4:	e8 92 0a 00 00       	call   1293b <mutex_unlock>
   11ea9:	83 c4 10             	add    $0x10,%esp
    return addr;
   11eac:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   11eaf:	c9                   	leave  
   11eb0:	c3                   	ret    

00011eb1 <addr_free_page>:


static uint32_t
addr_free_page(addr_alloc_t * alloc, uint32_t addr, int page_count) {
   11eb1:	55                   	push   %ebp
   11eb2:	89 e5                	mov    %esp,%ebp
   11eb4:	53                   	push   %ebx
   11eb5:	83 ec 14             	sub    $0x14,%esp
    mutex_lock(&alloc->mutex);
   11eb8:	8b 45 08             	mov    0x8(%ebp),%eax
   11ebb:	83 ec 0c             	sub    $0xc,%esp
   11ebe:	50                   	push   %eax
   11ebf:	e8 e3 09 00 00       	call   128a7 <mutex_lock>
   11ec4:	83 c4 10             	add    $0x10,%esp
    uint32_t pg_index = (addr - alloc->start) / alloc->page_size;
   11ec7:	8b 45 08             	mov    0x8(%ebp),%eax
   11eca:	8b 40 1c             	mov    0x1c(%eax),%eax
   11ecd:	8b 55 0c             	mov    0xc(%ebp),%edx
   11ed0:	89 d1                	mov    %edx,%ecx
   11ed2:	29 c1                	sub    %eax,%ecx
   11ed4:	8b 45 08             	mov    0x8(%ebp),%eax
   11ed7:	8b 58 24             	mov    0x24(%eax),%ebx
   11eda:	89 c8                	mov    %ecx,%eax
   11edc:	ba 00 00 00 00       	mov    $0x0,%edx
   11ee1:	f7 f3                	div    %ebx
   11ee3:	89 45 f4             	mov    %eax,-0xc(%ebp)
    bitmap_set_bit(&alloc->bitmap, pg_index, page_count, 0);
   11ee6:	8b 45 f4             	mov    -0xc(%ebp),%eax
   11ee9:	8b 55 08             	mov    0x8(%ebp),%edx
   11eec:	83 c2 14             	add    $0x14,%edx
   11eef:	6a 00                	push   $0x0
   11ef1:	ff 75 10             	pushl  0x10(%ebp)
   11ef4:	50                   	push   %eax
   11ef5:	52                   	push   %edx
   11ef6:	e8 07 f4 ff ff       	call   11302 <bitmap_set_bit>
   11efb:	83 c4 10             	add    $0x10,%esp

    mutex_unlock(&alloc->mutex);
   11efe:	8b 45 08             	mov    0x8(%ebp),%eax
   11f01:	83 ec 0c             	sub    $0xc,%esp
   11f04:	50                   	push   %eax
   11f05:	e8 31 0a 00 00       	call   1293b <mutex_unlock>
   11f0a:	83 c4 10             	add    $0x10,%esp
}
   11f0d:	90                   	nop
   11f0e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   11f11:	c9                   	leave  
   11f12:	c3                   	ret    

00011f13 <some_test>:


static void 
some_test() {
   11f13:	55                   	push   %ebp
   11f14:	89 e5                	mov    %esp,%ebp
   11f16:	83 ec 48             	sub    $0x48,%esp
    addr_alloc_t addr_alloc;
    uint8_t bits[8];
    addr_alloc_init(&addr_alloc, bits, 0x1000, 64*4096, 4096);
   11f19:	83 ec 0c             	sub    $0xc,%esp
   11f1c:	68 00 10 00 00       	push   $0x1000
   11f21:	68 00 00 04 00       	push   $0x40000
   11f26:	68 00 10 00 00       	push   $0x1000
   11f2b:	8d 45 b8             	lea    -0x48(%ebp),%eax
   11f2e:	50                   	push   %eax
   11f2f:	8d 45 c0             	lea    -0x40(%ebp),%eax
   11f32:	50                   	push   %eax
   11f33:	e8 ba fe ff ff       	call   11df2 <addr_alloc_init>
   11f38:	83 c4 20             	add    $0x20,%esp
    for(int i=0; i<32; i++) {
   11f3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11f42:	eb 2b                	jmp    11f6f <some_test+0x5c>
        uint32_t addr = addr_alloc_page(&addr_alloc, 2);
   11f44:	83 ec 08             	sub    $0x8,%esp
   11f47:	6a 02                	push   $0x2
   11f49:	8d 45 c0             	lea    -0x40(%ebp),%eax
   11f4c:	50                   	push   %eax
   11f4d:	e8 f8 fe ff ff       	call   11e4a <addr_alloc_page>
   11f52:	83 c4 10             	add    $0x10,%esp
   11f55:	89 45 e8             	mov    %eax,-0x18(%ebp)
        klog("alloc addr: 0x%x", addr);
   11f58:	83 ec 08             	sub    $0x8,%esp
   11f5b:	ff 75 e8             	pushl  -0x18(%ebp)
   11f5e:	68 b4 3e 01 00       	push   $0x13eb4
   11f63:	e8 ea fc ff ff       	call   11c52 <klog>
   11f68:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<32; i++) {
   11f6b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   11f6f:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%ebp)
   11f73:	7e cf                	jle    11f44 <some_test+0x31>
    }
    uint32_t addr = 0x1000;
   11f75:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
    for(int i=0; i<32; i++) {
   11f7c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
   11f83:	eb 32                	jmp    11fb7 <some_test+0xa4>
        addr_free_page(&addr_alloc, addr, 2);
   11f85:	83 ec 04             	sub    $0x4,%esp
   11f88:	6a 02                	push   $0x2
   11f8a:	ff 75 f0             	pushl  -0x10(%ebp)
   11f8d:	8d 45 c0             	lea    -0x40(%ebp),%eax
   11f90:	50                   	push   %eax
   11f91:	e8 1b ff ff ff       	call   11eb1 <addr_free_page>
   11f96:	83 c4 10             	add    $0x10,%esp
        addr += 8192;
   11f99:	81 45 f0 00 20 00 00 	addl   $0x2000,-0x10(%ebp)
        klog("free addr: 0x%x", addr);
   11fa0:	83 ec 08             	sub    $0x8,%esp
   11fa3:	ff 75 f0             	pushl  -0x10(%ebp)
   11fa6:	68 c5 3e 01 00       	push   $0x13ec5
   11fab:	e8 a2 fc ff ff       	call   11c52 <klog>
   11fb0:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<32; i++) {
   11fb3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
   11fb7:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
   11fbb:	7e c8                	jle    11f85 <some_test+0x72>
    }
}
   11fbd:	90                   	nop
   11fbe:	c9                   	leave  
   11fbf:	c3                   	ret    

00011fc0 <show_mem_info>:


static void        
show_mem_info(boot_info_t* boot_info) {
   11fc0:	55                   	push   %ebp
   11fc1:	89 e5                	mov    %esp,%ebp
   11fc3:	83 ec 18             	sub    $0x18,%esp
    klog("mem region");
   11fc6:	83 ec 0c             	sub    $0xc,%esp
   11fc9:	68 d5 3e 01 00       	push   $0x13ed5
   11fce:	e8 7f fc ff ff       	call   11c52 <klog>
   11fd3:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<boot_info->ram_region_count; i++) {
   11fd6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   11fdd:	eb 29                	jmp    12008 <show_mem_info+0x48>
        klog("[%d]: 0x%x - 0x%x", i, 
   11fdf:	8b 45 08             	mov    0x8(%ebp),%eax
   11fe2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   11fe5:	8b 54 d0 04          	mov    0x4(%eax,%edx,8),%edx
   11fe9:	8b 45 08             	mov    0x8(%ebp),%eax
   11fec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   11fef:	8b 04 c8             	mov    (%eax,%ecx,8),%eax
   11ff2:	52                   	push   %edx
   11ff3:	50                   	push   %eax
   11ff4:	ff 75 f4             	pushl  -0xc(%ebp)
   11ff7:	68 e0 3e 01 00       	push   $0x13ee0
   11ffc:	e8 51 fc ff ff       	call   11c52 <klog>
   12001:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<boot_info->ram_region_count; i++) {
   12004:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12008:	8b 45 08             	mov    0x8(%ebp),%eax
   1200b:	8b 40 50             	mov    0x50(%eax),%eax
   1200e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   12011:	7c cc                	jl     11fdf <show_mem_info+0x1f>
            boot_info->ram_region_cfg[i].start, 
            boot_info->ram_region_cfg[i].size );
    }
    klog("");
   12013:	83 ec 0c             	sub    $0xc,%esp
   12016:	68 f2 3e 01 00       	push   $0x13ef2
   1201b:	e8 32 fc ff ff       	call   11c52 <klog>
   12020:	83 c4 10             	add    $0x10,%esp
}
   12023:	90                   	nop
   12024:	c9                   	leave  
   12025:	c3                   	ret    

00012026 <total_mem_size>:


static uint32_t 
total_mem_size(boot_info_t* boot_info) {
   12026:	55                   	push   %ebp
   12027:	89 e5                	mov    %esp,%ebp
   12029:	83 ec 10             	sub    $0x10,%esp
    uint32_t mem_size = 0;
   1202c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
    for(int i=0; i<boot_info->ram_region_count; i++) {
   12033:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
   1203a:	eb 11                	jmp    1204d <total_mem_size+0x27>
        mem_size += boot_info->ram_region_cfg[i].size;
   1203c:	8b 45 08             	mov    0x8(%ebp),%eax
   1203f:	8b 55 f8             	mov    -0x8(%ebp),%edx
   12042:	8b 44 d0 04          	mov    0x4(%eax,%edx,8),%eax
   12046:	01 45 fc             	add    %eax,-0x4(%ebp)
    for(int i=0; i<boot_info->ram_region_count; i++) {
   12049:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
   1204d:	8b 45 08             	mov    0x8(%ebp),%eax
   12050:	8b 40 50             	mov    0x50(%eax),%eax
   12053:	39 45 f8             	cmp    %eax,-0x8(%ebp)
   12056:	7c e4                	jl     1203c <total_mem_size+0x16>
    }
    return mem_size;
   12058:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
   1205b:	c9                   	leave  
   1205c:	c3                   	ret    

0001205d <find_pte>:




pte_t * find_pte (pde_t * page_dir, uint32_t vaddr, int alloc) {
   1205d:	55                   	push   %ebp
   1205e:	89 e5                	mov    %esp,%ebp
   12060:	83 ec 18             	sub    $0x18,%esp
    pte_t * page_table;

    pde_t *pde = page_dir + pde_index(vaddr);
   12063:	ff 75 0c             	pushl  0xc(%ebp)
   12066:	e8 06 fd ff ff       	call   11d71 <pde_index>
   1206b:	83 c4 04             	add    $0x4,%esp
   1206e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12075:	8b 45 08             	mov    0x8(%ebp),%eax
   12078:	01 d0                	add    %edx,%eax
   1207a:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (pde->present) {
   1207d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12080:	0f b6 00             	movzbl (%eax),%eax
   12083:	83 e0 01             	and    $0x1,%eax
   12086:	84 c0                	test   %al,%al
   12088:	74 10                	je     1209a <find_pte+0x3d>
        page_table = (pte_t *)pde_paddr(pde);
   1208a:	ff 75 f0             	pushl  -0x10(%ebp)
   1208d:	e8 f3 fc ff ff       	call   11d85 <pde_paddr>
   12092:	83 c4 04             	add    $0x4,%esp
   12095:	89 45 f4             	mov    %eax,-0xc(%ebp)
   12098:	eb 57                	jmp    120f1 <find_pte+0x94>
    } else {
        if (alloc == 0) {
   1209a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   1209e:	75 07                	jne    120a7 <find_pte+0x4a>
            return (pte_t *)0;
   120a0:	b8 00 00 00 00       	mov    $0x0,%eax
   120a5:	eb 64                	jmp    1210b <find_pte+0xae>
        }
        uint32_t pg_paddr = addr_alloc_page(&g_paddr_alloc, 1);
   120a7:	83 ec 08             	sub    $0x8,%esp
   120aa:	6a 01                	push   $0x1
   120ac:	68 00 00 03 00       	push   $0x30000
   120b1:	e8 94 fd ff ff       	call   11e4a <addr_alloc_page>
   120b6:	83 c4 10             	add    $0x10,%esp
   120b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (pg_paddr == 0) {
   120bc:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   120c0:	75 07                	jne    120c9 <find_pte+0x6c>
            return (pte_t *)0;
   120c2:	b8 00 00 00 00       	mov    $0x0,%eax
   120c7:	eb 42                	jmp    1210b <find_pte+0xae>
        }
        pde->v = pg_paddr | PDE_P | PDE_W | PDE_U;
   120c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120cc:	83 c8 07             	or     $0x7,%eax
   120cf:	89 c2                	mov    %eax,%edx
   120d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
   120d4:	89 10                	mov    %edx,(%eax)

        page_table = (pte_t *)(pg_paddr);
   120d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   120d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
        k_memset(page_table, 0, MEM_PAGE_SIZE);
   120dc:	83 ec 04             	sub    $0x4,%esp
   120df:	68 00 10 00 00       	push   $0x1000
   120e4:	6a 00                	push   $0x0
   120e6:	ff 75 f4             	pushl  -0xc(%ebp)
   120e9:	e8 c9 f5 ff ff       	call   116b7 <k_memset>
   120ee:	83 c4 10             	add    $0x10,%esp
    }

    return page_table + pte_index(vaddr);
   120f1:	83 ec 0c             	sub    $0xc,%esp
   120f4:	ff 75 0c             	pushl  0xc(%ebp)
   120f7:	e8 b0 fc ff ff       	call   11dac <pte_index>
   120fc:	83 c4 10             	add    $0x10,%esp
   120ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   12106:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12109:	01 d0                	add    %edx,%eax
}
   1210b:	c9                   	leave  
   1210c:	c3                   	ret    

0001210d <memory_create_map>:

// 创建映射
int memory_create_map (pde_t * page_dir, uint32_t vaddr, uint32_t paddr, int count, uint32_t perm) {
   1210d:	55                   	push   %ebp
   1210e:	89 e5                	mov    %esp,%ebp
   12110:	83 ec 18             	sub    $0x18,%esp
    for (int i = 0; i < count; i++) {
   12113:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1211a:	eb 62                	jmp    1217e <memory_create_map+0x71>
        // klog("create map: v-0x%x p-0x%x, perm: 0x%x", vaddr, paddr, perm);

        pte_t * pte = find_pte(page_dir, vaddr, 1);
   1211c:	83 ec 04             	sub    $0x4,%esp
   1211f:	6a 01                	push   $0x1
   12121:	ff 75 0c             	pushl  0xc(%ebp)
   12124:	ff 75 08             	pushl  0x8(%ebp)
   12127:	e8 31 ff ff ff       	call   1205d <find_pte>
   1212c:	83 c4 10             	add    $0x10,%esp
   1212f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (pte == (pte_t *)0) {
   12132:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12136:	75 07                	jne    1213f <memory_create_map+0x32>
            return -1;
   12138:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   1213d:	eb 4c                	jmp    1218b <memory_create_map+0x7e>
        }
        if (pte->present != 0) klog("error");
   1213f:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12142:	0f b6 00             	movzbl (%eax),%eax
   12145:	83 e0 01             	and    $0x1,%eax
   12148:	84 c0                	test   %al,%al
   1214a:	74 10                	je     1215c <memory_create_map+0x4f>
   1214c:	83 ec 0c             	sub    $0xc,%esp
   1214f:	68 f3 3e 01 00       	push   $0x13ef3
   12154:	e8 f9 fa ff ff       	call   11c52 <klog>
   12159:	83 c4 10             	add    $0x10,%esp

        // klog("pte addr: 0x%x", (uint32_t)pte);

        pte->v = paddr | perm | PTE_P;
   1215c:	8b 45 10             	mov    0x10(%ebp),%eax
   1215f:	0b 45 18             	or     0x18(%ebp),%eax
   12162:	83 c8 01             	or     $0x1,%eax
   12165:	89 c2                	mov    %eax,%edx
   12167:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1216a:	89 10                	mov    %edx,(%eax)
        vaddr += MEM_PAGE_SIZE;
   1216c:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        paddr += MEM_PAGE_SIZE;
   12173:	81 45 10 00 10 00 00 	addl   $0x1000,0x10(%ebp)
    for (int i = 0; i < count; i++) {
   1217a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1217e:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12181:	3b 45 14             	cmp    0x14(%ebp),%eax
   12184:	7c 96                	jl     1211c <memory_create_map+0xf>
    }

    return 0;
   12186:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1218b:	c9                   	leave  
   1218c:	c3                   	ret    

0001218d <create_kernel_table>:


void create_kernel_table (void) {
   1218d:	55                   	push   %ebp
   1218e:	89 e5                	mov    %esp,%ebp
   12190:	83 ec 28             	sub    $0x28,%esp
        {s_text,                e_text,                         s_text,                 0    },      // 内核代码区
        {s_data,                (void *)(MEM_EBDA_START),       s_data,                 PTE_W},      // 内核数据区
        {(void*)MEM_EXT_START,  (void*)MEM_EXT_END,             (void*)MEM_EXT_START,   PTE_W},
    };

    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++) {
   12193:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1219a:	eb 7d                	jmp    12219 <create_kernel_table+0x8c>
        memory_map_t * map = kernel_map + i;
   1219c:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1219f:	c1 e0 04             	shl    $0x4,%eax
   121a2:	05 20 50 01 00       	add    $0x15020,%eax
   121a7:	89 45 f0             	mov    %eax,-0x10(%ebp)

        int vstart = down2((uint32_t)map->vstart, MEM_PAGE_SIZE);
   121aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121ad:	8b 00                	mov    (%eax),%eax
   121af:	68 00 10 00 00       	push   $0x1000
   121b4:	50                   	push   %eax
   121b5:	e8 76 fb ff ff       	call   11d30 <down2>
   121ba:	83 c4 08             	add    $0x8,%esp
   121bd:	89 45 ec             	mov    %eax,-0x14(%ebp)
        int vend   = up2  ((uint32_t)map->vend, MEM_PAGE_SIZE);
   121c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121c3:	8b 40 04             	mov    0x4(%eax),%eax
   121c6:	68 00 10 00 00       	push   $0x1000
   121cb:	50                   	push   %eax
   121cc:	e8 6c fb ff ff       	call   11d3d <up2>
   121d1:	83 c4 08             	add    $0x8,%esp
   121d4:	89 45 e8             	mov    %eax,-0x18(%ebp)
        int page_count = (vend - vstart) / MEM_PAGE_SIZE;
   121d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
   121da:	2b 45 ec             	sub    -0x14(%ebp),%eax
   121dd:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
   121e3:	85 c0                	test   %eax,%eax
   121e5:	0f 48 c2             	cmovs  %edx,%eax
   121e8:	c1 f8 0c             	sar    $0xc,%eax
   121eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        memory_create_map(g_kernel_page_dir, vstart, (uint32_t)map->pstart, page_count, map->perm);
   121ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121f1:	8b 50 0c             	mov    0xc(%eax),%edx
   121f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
   121f7:	8b 40 08             	mov    0x8(%eax),%eax
   121fa:	89 c1                	mov    %eax,%ecx
   121fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
   121ff:	83 ec 0c             	sub    $0xc,%esp
   12202:	52                   	push   %edx
   12203:	ff 75 e4             	pushl  -0x1c(%ebp)
   12206:	51                   	push   %ecx
   12207:	50                   	push   %eax
   12208:	68 00 10 03 00       	push   $0x31000
   1220d:	e8 fb fe ff ff       	call   1210d <memory_create_map>
   12212:	83 c4 20             	add    $0x20,%esp
    for (int i = 0; i < sizeof(kernel_map) / sizeof(memory_map_t); i++) {
   12215:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   12219:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1221c:	83 f8 03             	cmp    $0x3,%eax
   1221f:	0f 86 77 ff ff ff    	jbe    1219c <create_kernel_table+0xf>
    }
}
   12225:	90                   	nop
   12226:	c9                   	leave  
   12227:	c3                   	ret    

00012228 <memory_init>:


void memory_init (boot_info_t* boot_info) {
   12228:	55                   	push   %ebp
   12229:	89 e5                	mov    %esp,%ebp
   1222b:	83 ec 18             	sub    $0x18,%esp
    extern uint8_t * mem_free_start;
    uint8_t * mem_free = (uint8_t*)&mem_free_start;
   1222e:	c7 45 f4 14 c4 03 00 	movl   $0x3c414,-0xc(%ebp)
    klog("memory init");
   12235:	83 ec 0c             	sub    $0xc,%esp
   12238:	68 f9 3e 01 00       	push   $0x13ef9
   1223d:	e8 10 fa ff ff       	call   11c52 <klog>
   12242:	83 c4 10             	add    $0x10,%esp
    show_mem_info(boot_info);
   12245:	83 ec 0c             	sub    $0xc,%esp
   12248:	ff 75 08             	pushl  0x8(%ebp)
   1224b:	e8 70 fd ff ff       	call   11fc0 <show_mem_info>
   12250:	83 c4 10             	add    $0x10,%esp

    
    uint32_t mem_up1MB_free = total_mem_size(boot_info) - MEM_EXT_START;
   12253:	83 ec 0c             	sub    $0xc,%esp
   12256:	ff 75 08             	pushl  0x8(%ebp)
   12259:	e8 c8 fd ff ff       	call   12026 <total_mem_size>
   1225e:	83 c4 10             	add    $0x10,%esp
   12261:	2d 00 00 10 00       	sub    $0x100000,%eax
   12266:	89 45 f0             	mov    %eax,-0x10(%ebp)
    mem_up1MB_free = down2(mem_up1MB_free, MEM_PAGE_SIZE);
   12269:	83 ec 08             	sub    $0x8,%esp
   1226c:	68 00 10 00 00       	push   $0x1000
   12271:	ff 75 f0             	pushl  -0x10(%ebp)
   12274:	e8 b7 fa ff ff       	call   11d30 <down2>
   12279:	83 c4 10             	add    $0x10,%esp
   1227c:	89 45 f0             	mov    %eax,-0x10(%ebp)

    klog("free memory: 0x%x, size: 0x%x", MEM_EXT_START, mem_up1MB_free);
   1227f:	83 ec 04             	sub    $0x4,%esp
   12282:	ff 75 f0             	pushl  -0x10(%ebp)
   12285:	68 00 00 10 00       	push   $0x100000
   1228a:	68 05 3f 01 00       	push   $0x13f05
   1228f:	e8 be f9 ff ff       	call   11c52 <klog>
   12294:	83 c4 10             	add    $0x10,%esp
    addr_alloc_init(&g_paddr_alloc, mem_free, MEM_EXT_START, mem_up1MB_free, MEM_PAGE_SIZE);
   12297:	83 ec 0c             	sub    $0xc,%esp
   1229a:	68 00 10 00 00       	push   $0x1000
   1229f:	ff 75 f0             	pushl  -0x10(%ebp)
   122a2:	68 00 00 10 00       	push   $0x100000
   122a7:	ff 75 f4             	pushl  -0xc(%ebp)
   122aa:	68 00 00 03 00       	push   $0x30000
   122af:	e8 3e fb ff ff       	call   11df2 <addr_alloc_init>
   122b4:	83 c4 20             	add    $0x20,%esp

    mem_free += bitmap_byte_count(g_paddr_alloc.size / MEM_PAGE_SIZE);
   122b7:	a1 20 00 03 00       	mov    0x30020,%eax
   122bc:	c1 e8 0c             	shr    $0xc,%eax
   122bf:	83 ec 0c             	sub    $0xc,%esp
   122c2:	50                   	push   %eax
   122c3:	e8 7c ef ff ff       	call   11244 <bitmap_byte_count>
   122c8:	83 c4 10             	add    $0x10,%esp
   122cb:	01 45 f4             	add    %eax,-0xc(%ebp)
    if (mem_free < (uint8_t *)0x800000) {
   122ce:	81 7d f4 ff ff 7f 00 	cmpl   $0x7fffff,-0xc(%ebp)
   122d5:	77 10                	ja     122e7 <memory_init+0xbf>
        klog("simple test ok!");
   122d7:	83 ec 0c             	sub    $0xc,%esp
   122da:	68 23 3f 01 00       	push   $0x13f23
   122df:	e8 6e f9 ff ff       	call   11c52 <klog>
   122e4:	83 c4 10             	add    $0x10,%esp
    }

    k_memset(g_kernel_page_dir, 0, sizeof(g_kernel_page_dir));  // 清空内核表
   122e7:	83 ec 04             	sub    $0x4,%esp
   122ea:	68 00 10 00 00       	push   $0x1000
   122ef:	6a 00                	push   $0x0
   122f1:	68 00 10 03 00       	push   $0x31000
   122f6:	e8 bc f3 ff ff       	call   116b7 <k_memset>
   122fb:	83 c4 10             	add    $0x10,%esp

    create_kernel_table();
   122fe:	e8 8a fe ff ff       	call   1218d <create_kernel_table>

    mmu_set_page_dir((uint32_t)g_kernel_page_dir);            // 重新设置页表
   12303:	b8 00 10 03 00       	mov    $0x31000,%eax
   12308:	83 ec 0c             	sub    $0xc,%esp
   1230b:	50                   	push   %eax
   1230c:	e8 4f fa ff ff       	call   11d60 <mmu_set_page_dir>
   12311:	83 c4 10             	add    $0x10,%esp
    
}
   12314:	90                   	nop
   12315:	c9                   	leave  
   12316:	c3                   	ret    

00012317 <memory_create_uvm>:


uint32_t memory_create_uvm() {
   12317:	55                   	push   %ebp
   12318:	89 e5                	mov    %esp,%ebp
   1231a:	83 ec 18             	sub    $0x18,%esp
    pde_t* page_dir = (pde_t*)addr_alloc_page(&g_paddr_alloc, 1);
   1231d:	83 ec 08             	sub    $0x8,%esp
   12320:	6a 01                	push   $0x1
   12322:	68 00 00 03 00       	push   $0x30000
   12327:	e8 1e fb ff ff       	call   11e4a <addr_alloc_page>
   1232c:	83 c4 10             	add    $0x10,%esp
   1232f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(page_dir == (pde_t*)0) {
   12332:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12336:	75 07                	jne    1233f <memory_create_uvm+0x28>
        return 0;  // error
   12338:	b8 00 00 00 00       	mov    $0x0,%eax
   1233d:	eb 5b                	jmp    1239a <memory_create_uvm+0x83>
    }

    k_memset((void*)page_dir, 0, MEM_PAGE_SIZE);
   1233f:	83 ec 04             	sub    $0x4,%esp
   12342:	68 00 10 00 00       	push   $0x1000
   12347:	6a 00                	push   $0x0
   12349:	ff 75 f0             	pushl  -0x10(%ebp)
   1234c:	e8 66 f3 ff ff       	call   116b7 <k_memset>
   12351:	83 c4 10             	add    $0x10,%esp
    uint32_t user_pde_start = pde_index( MEMORY_TASK_BASE );
   12354:	83 ec 0c             	sub    $0xc,%esp
   12357:	68 00 00 00 80       	push   $0x80000000
   1235c:	e8 10 fa ff ff       	call   11d71 <pde_index>
   12361:	83 c4 10             	add    $0x10,%esp
   12364:	89 45 ec             	mov    %eax,-0x14(%ebp)
    
    for(int i=0; i<user_pde_start; i++) {
   12367:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   1236e:	eb 1f                	jmp    1238f <memory_create_uvm+0x78>
        page_dir[i].v = g_kernel_page_dir[i].v;
   12370:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12373:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   1237a:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1237d:	01 c2                	add    %eax,%edx
   1237f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12382:	8b 04 85 00 10 03 00 	mov    0x31000(,%eax,4),%eax
   12389:	89 02                	mov    %eax,(%edx)
    for(int i=0; i<user_pde_start; i++) {
   1238b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   1238f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12392:	39 45 ec             	cmp    %eax,-0x14(%ebp)
   12395:	77 d9                	ja     12370 <memory_create_uvm+0x59>
    }

    return (uint32_t)page_dir;
   12397:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
   1239a:	c9                   	leave  
   1239b:	c3                   	ret    

0001239c <memory_alloc_for_page_dir>:


uint32_t memory_alloc_for_page_dir (uint32_t page_dir, uint32_t vaddr, uint32_t size, int perm) {
   1239c:	55                   	push   %ebp
   1239d:	89 e5                	mov    %esp,%ebp
   1239f:	83 ec 28             	sub    $0x28,%esp
    uint32_t curr_vaddr = vaddr;
   123a2:	8b 45 0c             	mov    0xc(%ebp),%eax
   123a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int page_count = up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE;
   123a8:	68 00 10 00 00       	push   $0x1000
   123ad:	ff 75 10             	pushl  0x10(%ebp)
   123b0:	e8 88 f9 ff ff       	call   11d3d <up2>
   123b5:	83 c4 08             	add    $0x8,%esp
   123b8:	c1 e8 0c             	shr    $0xc,%eax
   123bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    vaddr = down2(vaddr, MEM_PAGE_SIZE);
   123be:	68 00 10 00 00       	push   $0x1000
   123c3:	ff 75 0c             	pushl  0xc(%ebp)
   123c6:	e8 65 f9 ff ff       	call   11d30 <down2>
   123cb:	83 c4 08             	add    $0x8,%esp
   123ce:	89 45 0c             	mov    %eax,0xc(%ebp)

    for (int i = 0; i < page_count; i++) {
   123d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   123d8:	e9 95 00 00 00       	jmp    12472 <memory_alloc_for_page_dir+0xd6>
        uint32_t paddr = addr_alloc_page(&g_paddr_alloc, 1);
   123dd:	83 ec 08             	sub    $0x8,%esp
   123e0:	6a 01                	push   $0x1
   123e2:	68 00 00 03 00       	push   $0x30000
   123e7:	e8 5e fa ff ff       	call   11e4a <addr_alloc_page>
   123ec:	83 c4 10             	add    $0x10,%esp
   123ef:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (paddr == 0) {
   123f2:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   123f6:	75 17                	jne    1240f <memory_alloc_for_page_dir+0x73>
            klog("mem alloc failed. no memory");
   123f8:	83 ec 0c             	sub    $0xc,%esp
   123fb:	68 33 3f 01 00       	push   $0x13f33
   12400:	e8 4d f8 ff ff       	call   11c52 <klog>
   12405:	83 c4 10             	add    $0x10,%esp
            return 0;
   12408:	b8 00 00 00 00       	mov    $0x0,%eax
   1240d:	eb 74                	jmp    12483 <memory_alloc_for_page_dir+0xe7>
        }

        int err = memory_create_map((pde_t *)page_dir, curr_vaddr, paddr, 1, perm);
   1240f:	8b 55 14             	mov    0x14(%ebp),%edx
   12412:	8b 45 08             	mov    0x8(%ebp),%eax
   12415:	83 ec 0c             	sub    $0xc,%esp
   12418:	52                   	push   %edx
   12419:	6a 01                	push   $0x1
   1241b:	ff 75 e8             	pushl  -0x18(%ebp)
   1241e:	ff 75 f4             	pushl  -0xc(%ebp)
   12421:	50                   	push   %eax
   12422:	e8 e6 fc ff ff       	call   1210d <memory_create_map>
   12427:	83 c4 20             	add    $0x20,%esp
   1242a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0) {
   1242d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12431:	79 34                	jns    12467 <memory_alloc_for_page_dir+0xcb>
            klog("create memory map failed. err = %d", err);
   12433:	83 ec 08             	sub    $0x8,%esp
   12436:	ff 75 e4             	pushl  -0x1c(%ebp)
   12439:	68 50 3f 01 00       	push   $0x13f50
   1243e:	e8 0f f8 ff ff       	call   11c52 <klog>
   12443:	83 c4 10             	add    $0x10,%esp
            addr_free_page(&g_paddr_alloc, vaddr, i + 1);
   12446:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12449:	83 c0 01             	add    $0x1,%eax
   1244c:	83 ec 04             	sub    $0x4,%esp
   1244f:	50                   	push   %eax
   12450:	ff 75 0c             	pushl  0xc(%ebp)
   12453:	68 00 00 03 00       	push   $0x30000
   12458:	e8 54 fa ff ff       	call   11eb1 <addr_free_page>
   1245d:	83 c4 10             	add    $0x10,%esp
            return -1;
   12460:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12465:	eb 1c                	jmp    12483 <memory_alloc_for_page_dir+0xe7>
        }

        curr_vaddr += MEM_PAGE_SIZE;
   12467:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
    for (int i = 0; i < page_count; i++) {
   1246e:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   12472:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12475:	3b 45 ec             	cmp    -0x14(%ebp),%eax
   12478:	0f 8c 5f ff ff ff    	jl     123dd <memory_alloc_for_page_dir+0x41>
    }

    return 0;
   1247e:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12483:	c9                   	leave  
   12484:	c3                   	ret    

00012485 <memory_alloc_page_for>:


int memory_alloc_page_for(uint32_t addr, uint32_t size, int perm) {
   12485:	55                   	push   %ebp
   12486:	89 e5                	mov    %esp,%ebp
   12488:	83 ec 18             	sub    $0x18,%esp
    uint32_t cr3 = task_current()->tss.cr3;
   1248b:	e8 11 0c 00 00       	call   130a1 <task_current>
   12490:	8b 40 70             	mov    0x70(%eax),%eax
   12493:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return memory_alloc_for_page_dir(cr3, addr, size, perm);
   12496:	ff 75 10             	pushl  0x10(%ebp)
   12499:	ff 75 0c             	pushl  0xc(%ebp)
   1249c:	ff 75 08             	pushl  0x8(%ebp)
   1249f:	ff 75 f4             	pushl  -0xc(%ebp)
   124a2:	e8 f5 fe ff ff       	call   1239c <memory_alloc_for_page_dir>
   124a7:	83 c4 10             	add    $0x10,%esp
}
   124aa:	c9                   	leave  
   124ab:	c3                   	ret    

000124ac <memory_alloc_page>:


// 0x80000000 以下
uint32_t memory_alloc_page() {
   124ac:	55                   	push   %ebp
   124ad:	89 e5                	mov    %esp,%ebp
   124af:	83 ec 18             	sub    $0x18,%esp
    uint32_t addr = addr_alloc_page(&g_paddr_alloc, 1);
   124b2:	83 ec 08             	sub    $0x8,%esp
   124b5:	6a 01                	push   $0x1
   124b7:	68 00 00 03 00       	push   $0x30000
   124bc:	e8 89 f9 ff ff       	call   11e4a <addr_alloc_page>
   124c1:	83 c4 10             	add    $0x10,%esp
   124c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    return addr;
   124c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   124ca:	c9                   	leave  
   124cb:	c3                   	ret    

000124cc <curr_page_dir>:


static pde_t* curr_page_dir() {
   124cc:	55                   	push   %ebp
   124cd:	89 e5                	mov    %esp,%ebp
   124cf:	83 ec 08             	sub    $0x8,%esp
    return (pde_t*)( task_current()->tss.cr3 );
   124d2:	e8 ca 0b 00 00       	call   130a1 <task_current>
   124d7:	8b 40 70             	mov    0x70(%eax),%eax
}
   124da:	c9                   	leave  
   124db:	c3                   	ret    

000124dc <memory_free_page>:


void memory_free_page(uint32_t addr) {
   124dc:	55                   	push   %ebp
   124dd:	89 e5                	mov    %esp,%ebp
   124df:	83 ec 18             	sub    $0x18,%esp
    if( addr < MEMORY_TASK_BASE ) {
   124e2:	8b 45 08             	mov    0x8(%ebp),%eax
   124e5:	85 c0                	test   %eax,%eax
   124e7:	78 17                	js     12500 <memory_free_page+0x24>
        addr_free_page(&g_paddr_alloc, addr, 1);
   124e9:	83 ec 04             	sub    $0x4,%esp
   124ec:	6a 01                	push   $0x1
   124ee:	ff 75 08             	pushl  0x8(%ebp)
   124f1:	68 00 00 03 00       	push   $0x30000
   124f6:	e8 b6 f9 ff ff       	call   11eb1 <addr_free_page>
   124fb:	83 c4 10             	add    $0x10,%esp
        if(pte == 0 && !pte->present) klog("free err");

        addr_free_page(&g_paddr_alloc, pte_paddr(pte), 1);
        pte->v = 0;
    }
}
   124fe:	eb 66                	jmp    12566 <memory_free_page+0x8a>
        pte_t* pte = find_pte(curr_page_dir(), addr, 0);
   12500:	e8 c7 ff ff ff       	call   124cc <curr_page_dir>
   12505:	83 ec 04             	sub    $0x4,%esp
   12508:	6a 00                	push   $0x0
   1250a:	ff 75 08             	pushl  0x8(%ebp)
   1250d:	50                   	push   %eax
   1250e:	e8 4a fb ff ff       	call   1205d <find_pte>
   12513:	83 c4 10             	add    $0x10,%esp
   12516:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if(pte == 0 && !pte->present) klog("free err");
   12519:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1251d:	75 1d                	jne    1253c <memory_free_page+0x60>
   1251f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12522:	0f b6 00             	movzbl (%eax),%eax
   12525:	83 e0 01             	and    $0x1,%eax
   12528:	84 c0                	test   %al,%al
   1252a:	75 10                	jne    1253c <memory_free_page+0x60>
   1252c:	83 ec 0c             	sub    $0xc,%esp
   1252f:	68 73 3f 01 00       	push   $0x13f73
   12534:	e8 19 f7 ff ff       	call   11c52 <klog>
   12539:	83 c4 10             	add    $0x10,%esp
        addr_free_page(&g_paddr_alloc, pte_paddr(pte), 1);
   1253c:	83 ec 0c             	sub    $0xc,%esp
   1253f:	ff 75 f4             	pushl  -0xc(%ebp)
   12542:	e8 75 f8 ff ff       	call   11dbc <pte_paddr>
   12547:	83 c4 10             	add    $0x10,%esp
   1254a:	83 ec 04             	sub    $0x4,%esp
   1254d:	6a 01                	push   $0x1
   1254f:	50                   	push   %eax
   12550:	68 00 00 03 00       	push   $0x30000
   12555:	e8 57 f9 ff ff       	call   11eb1 <addr_free_page>
   1255a:	83 c4 10             	add    $0x10,%esp
        pte->v = 0;
   1255d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12560:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
   12566:	90                   	nop
   12567:	c9                   	leave  
   12568:	c3                   	ret    

00012569 <memory_get_paddr>:


uint32_t memory_get_paddr (uint32_t page_dir, uint32_t vaddr) {
   12569:	55                   	push   %ebp
   1256a:	89 e5                	mov    %esp,%ebp
   1256c:	83 ec 18             	sub    $0x18,%esp
    pte_t * pte = find_pte((pde_t *)page_dir, vaddr, 0);
   1256f:	8b 45 08             	mov    0x8(%ebp),%eax
   12572:	83 ec 04             	sub    $0x4,%esp
   12575:	6a 00                	push   $0x0
   12577:	ff 75 0c             	pushl  0xc(%ebp)
   1257a:	50                   	push   %eax
   1257b:	e8 dd fa ff ff       	call   1205d <find_pte>
   12580:	83 c4 10             	add    $0x10,%esp
   12583:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (pte == (pte_t *)0) {
   12586:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1258a:	75 07                	jne    12593 <memory_get_paddr+0x2a>
        return 0;
   1258c:	b8 00 00 00 00       	mov    $0x0,%eax
   12591:	eb 1a                	jmp    125ad <memory_get_paddr+0x44>
    }

    return pte_paddr(pte) + (vaddr & (MEM_PAGE_SIZE - 1));
   12593:	83 ec 0c             	sub    $0xc,%esp
   12596:	ff 75 f4             	pushl  -0xc(%ebp)
   12599:	e8 1e f8 ff ff       	call   11dbc <pte_paddr>
   1259e:	83 c4 10             	add    $0x10,%esp
   125a1:	89 c2                	mov    %eax,%edx
   125a3:	8b 45 0c             	mov    0xc(%ebp),%eax
   125a6:	25 ff 0f 00 00       	and    $0xfff,%eax
   125ab:	01 d0                	add    %edx,%eax
}
   125ad:	c9                   	leave  
   125ae:	c3                   	ret    

000125af <memory_destory_uvm>:


void memory_destory_uvm (uint32_t page_dir) {
   125af:	55                   	push   %ebp
   125b0:	89 e5                	mov    %esp,%ebp
   125b2:	83 ec 28             	sub    $0x28,%esp
    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   125b5:	68 00 00 00 80       	push   $0x80000000
   125ba:	e8 b2 f7 ff ff       	call   11d71 <pde_index>
   125bf:	83 c4 04             	add    $0x4,%esp
   125c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    pde_t * pde = (pde_t *)page_dir + user_pde_start;
   125c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   125c8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   125cf:	8b 45 08             	mov    0x8(%ebp),%eax
   125d2:	01 d0                	add    %edx,%eax
   125d4:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   125d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   125da:	89 45 f0             	mov    %eax,-0x10(%ebp)
   125dd:	e9 8f 00 00 00       	jmp    12671 <memory_destory_uvm+0xc2>
        if (!pde->present) {
   125e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
   125e5:	0f b6 00             	movzbl (%eax),%eax
   125e8:	83 e0 01             	and    $0x1,%eax
   125eb:	84 c0                	test   %al,%al
   125ed:	74 79                	je     12668 <memory_destory_uvm+0xb9>
            continue;
        }
        pte_t * pte = (pte_t *)pde_paddr(pde);
   125ef:	ff 75 f4             	pushl  -0xc(%ebp)
   125f2:	e8 8e f7 ff ff       	call   11d85 <pde_paddr>
   125f7:	83 c4 04             	add    $0x4,%esp
   125fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   125fd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12604:	eb 36                	jmp    1263c <memory_destory_uvm+0x8d>
            if (!pte->present) {
   12606:	8b 45 ec             	mov    -0x14(%ebp),%eax
   12609:	0f b6 00             	movzbl (%eax),%eax
   1260c:	83 e0 01             	and    $0x1,%eax
   1260f:	84 c0                	test   %al,%al
   12611:	74 20                	je     12633 <memory_destory_uvm+0x84>
                continue;
            }
            addr_free_page(&g_paddr_alloc, pte_paddr(pte), 1);
   12613:	ff 75 ec             	pushl  -0x14(%ebp)
   12616:	e8 a1 f7 ff ff       	call   11dbc <pte_paddr>
   1261b:	83 c4 04             	add    $0x4,%esp
   1261e:	83 ec 04             	sub    $0x4,%esp
   12621:	6a 01                	push   $0x1
   12623:	50                   	push   %eax
   12624:	68 00 00 03 00       	push   $0x30000
   12629:	e8 83 f8 ff ff       	call   11eb1 <addr_free_page>
   1262e:	83 c4 10             	add    $0x10,%esp
   12631:	eb 01                	jmp    12634 <memory_destory_uvm+0x85>
                continue;
   12633:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   12634:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   12638:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   1263c:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   12643:	7e c1                	jle    12606 <memory_destory_uvm+0x57>
        }
        addr_free_page(&g_paddr_alloc, (uint32_t)pde_paddr(pde), 1);
   12645:	83 ec 0c             	sub    $0xc,%esp
   12648:	ff 75 f4             	pushl  -0xc(%ebp)
   1264b:	e8 35 f7 ff ff       	call   11d85 <pde_paddr>
   12650:	83 c4 10             	add    $0x10,%esp
   12653:	83 ec 04             	sub    $0x4,%esp
   12656:	6a 01                	push   $0x1
   12658:	50                   	push   %eax
   12659:	68 00 00 03 00       	push   $0x30000
   1265e:	e8 4e f8 ff ff       	call   11eb1 <addr_free_page>
   12663:	83 c4 10             	add    $0x10,%esp
   12666:	eb 01                	jmp    12669 <memory_destory_uvm+0xba>
            continue;
   12668:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   12669:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1266d:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   12671:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   12678:	0f 8e 64 ff ff ff    	jle    125e2 <memory_destory_uvm+0x33>
    }
    addr_free_page(&g_paddr_alloc, page_dir, 1);
   1267e:	83 ec 04             	sub    $0x4,%esp
   12681:	6a 01                	push   $0x1
   12683:	ff 75 08             	pushl  0x8(%ebp)
   12686:	68 00 00 03 00       	push   $0x30000
   1268b:	e8 21 f8 ff ff       	call   11eb1 <addr_free_page>
   12690:	83 c4 10             	add    $0x10,%esp
}
   12693:	90                   	nop
   12694:	c9                   	leave  
   12695:	c3                   	ret    

00012696 <memory_copy_uvm>:


uint32_t memory_copy_uvm (uint32_t page_dir) {
   12696:	55                   	push   %ebp
   12697:	89 e5                	mov    %esp,%ebp
   12699:	83 ec 38             	sub    $0x38,%esp
    uint32_t to_page_dir = memory_create_uvm();
   1269c:	e8 76 fc ff ff       	call   12317 <memory_create_uvm>
   126a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (to_page_dir == 0) {
   126a4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   126a8:	0f 84 1b 01 00 00    	je     127c9 <memory_copy_uvm+0x133>
        goto copy_uvm_failed;
    }

    uint32_t user_pde_start = pde_index(MEMORY_TASK_BASE);
   126ae:	83 ec 0c             	sub    $0xc,%esp
   126b1:	68 00 00 00 80       	push   $0x80000000
   126b6:	e8 b6 f6 ff ff       	call   11d71 <pde_index>
   126bb:	83 c4 10             	add    $0x10,%esp
   126be:	89 45 e0             	mov    %eax,-0x20(%ebp)
    pde_t * pde = (pde_t *)page_dir + user_pde_start;
   126c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126c4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   126cb:	8b 45 08             	mov    0x8(%ebp),%eax
   126ce:	01 d0                	add    %edx,%eax
   126d0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   126d3:	8b 45 e0             	mov    -0x20(%ebp),%eax
   126d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
   126d9:	e9 d9 00 00 00       	jmp    127b7 <memory_copy_uvm+0x121>
        if (!pde->present) {
   126de:	8b 45 f4             	mov    -0xc(%ebp),%eax
   126e1:	0f b6 00             	movzbl (%eax),%eax
   126e4:	83 e0 01             	and    $0x1,%eax
   126e7:	84 c0                	test   %al,%al
   126e9:	0f 84 bf 00 00 00    	je     127ae <memory_copy_uvm+0x118>
            continue;
        }
        pte_t * pte = (pte_t *)pde_paddr(pde);
   126ef:	83 ec 0c             	sub    $0xc,%esp
   126f2:	ff 75 f4             	pushl  -0xc(%ebp)
   126f5:	e8 8b f6 ff ff       	call   11d85 <pde_paddr>
   126fa:	83 c4 10             	add    $0x10,%esp
   126fd:	89 45 ec             	mov    %eax,-0x14(%ebp)
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   12700:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
   12707:	e9 93 00 00 00       	jmp    1279f <memory_copy_uvm+0x109>
            if (!pte->present) {
   1270c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1270f:	0f b6 00             	movzbl (%eax),%eax
   12712:	83 e0 01             	and    $0x1,%eax
   12715:	84 c0                	test   %al,%al
   12717:	74 7d                	je     12796 <memory_copy_uvm+0x100>
                continue;
            }
            uint32_t page = addr_alloc_page(&g_paddr_alloc, 1);
   12719:	83 ec 08             	sub    $0x8,%esp
   1271c:	6a 01                	push   $0x1
   1271e:	68 00 00 03 00       	push   $0x30000
   12723:	e8 22 f7 ff ff       	call   11e4a <addr_alloc_page>
   12728:	83 c4 10             	add    $0x10,%esp
   1272b:	89 45 dc             	mov    %eax,-0x24(%ebp)
            if (page == 0) {
   1272e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
   12732:	0f 84 94 00 00 00    	je     127cc <memory_copy_uvm+0x136>
                goto copy_uvm_failed;
            }
            uint32_t vaddr = (i << 22) | (j << 12);
   12738:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1273b:	c1 e0 16             	shl    $0x16,%eax
   1273e:	89 c2                	mov    %eax,%edx
   12740:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12743:	c1 e0 0c             	shl    $0xc,%eax
   12746:	09 d0                	or     %edx,%eax
   12748:	89 45 d8             	mov    %eax,-0x28(%ebp)
            int err = memory_create_map((pde_t *)to_page_dir, vaddr, page, 1, get_pte_perm(pte));
   1274b:	83 ec 0c             	sub    $0xc,%esp
   1274e:	ff 75 ec             	pushl  -0x14(%ebp)
   12751:	e8 8d f6 ff ff       	call   11de3 <get_pte_perm>
   12756:	83 c4 10             	add    $0x10,%esp
   12759:	89 c2                	mov    %eax,%edx
   1275b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1275e:	83 ec 0c             	sub    $0xc,%esp
   12761:	52                   	push   %edx
   12762:	6a 01                	push   $0x1
   12764:	ff 75 dc             	pushl  -0x24(%ebp)
   12767:	ff 75 d8             	pushl  -0x28(%ebp)
   1276a:	50                   	push   %eax
   1276b:	e8 9d f9 ff ff       	call   1210d <memory_create_map>
   12770:	83 c4 20             	add    $0x20,%esp
   12773:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if (err < 0) {
   12776:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
   1277a:	78 53                	js     127cf <memory_copy_uvm+0x139>
                goto copy_uvm_failed;
            }
            k_memcpy((void *)page, (void *)vaddr, MEM_PAGE_SIZE);
   1277c:	8b 55 d8             	mov    -0x28(%ebp),%edx
   1277f:	8b 45 dc             	mov    -0x24(%ebp),%eax
   12782:	83 ec 04             	sub    $0x4,%esp
   12785:	68 00 10 00 00       	push   $0x1000
   1278a:	52                   	push   %edx
   1278b:	50                   	push   %eax
   1278c:	e8 d7 ee ff ff       	call   11668 <k_memcpy>
   12791:	83 c4 10             	add    $0x10,%esp
   12794:	eb 01                	jmp    12797 <memory_copy_uvm+0x101>
                continue;
   12796:	90                   	nop
        for (int j = 0; j < PTE_CNT; j++, pte++) {
   12797:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
   1279b:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
   1279f:	81 7d e8 ff 03 00 00 	cmpl   $0x3ff,-0x18(%ebp)
   127a6:	0f 8e 60 ff ff ff    	jle    1270c <memory_copy_uvm+0x76>
   127ac:	eb 01                	jmp    127af <memory_copy_uvm+0x119>
            continue;
   127ae:	90                   	nop
    for (int i = user_pde_start; i < PDE_CNT; i++, pde++) {
   127af:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   127b3:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
   127b7:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
   127be:	0f 8e 1a ff ff ff    	jle    126de <memory_copy_uvm+0x48>
        }
    }
    return to_page_dir;
   127c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   127c7:	eb 20                	jmp    127e9 <memory_copy_uvm+0x153>
        goto copy_uvm_failed;
   127c9:	90                   	nop
   127ca:	eb 04                	jmp    127d0 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   127cc:	90                   	nop
   127cd:	eb 01                	jmp    127d0 <memory_copy_uvm+0x13a>
                goto copy_uvm_failed;
   127cf:	90                   	nop


copy_uvm_failed:
    if (to_page_dir) {
   127d0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   127d4:	74 0e                	je     127e4 <memory_copy_uvm+0x14e>
        memory_destory_uvm(to_page_dir);
   127d6:	83 ec 0c             	sub    $0xc,%esp
   127d9:	ff 75 e4             	pushl  -0x1c(%ebp)
   127dc:	e8 ce fd ff ff       	call   125af <memory_destory_uvm>
   127e1:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   127e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   127e9:	c9                   	leave  
   127ea:	c3                   	ret    

000127eb <memory_copy_uvm_data>:


int memory_copy_uvm_data(uint32_t to, uint32_t page_dir, uint32_t from, uint32_t size) {
   127eb:	55                   	push   %ebp
   127ec:	89 e5                	mov    %esp,%ebp
   127ee:	83 ec 18             	sub    $0x18,%esp
    char *buf, *pa0;

    while(size > 0){
   127f1:	eb 6e                	jmp    12861 <memory_copy_uvm_data+0x76>
        uint32_t to_paddr = memory_get_paddr(page_dir, to);
   127f3:	83 ec 08             	sub    $0x8,%esp
   127f6:	ff 75 08             	pushl  0x8(%ebp)
   127f9:	ff 75 0c             	pushl  0xc(%ebp)
   127fc:	e8 68 fd ff ff       	call   12569 <memory_get_paddr>
   12801:	83 c4 10             	add    $0x10,%esp
   12804:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (to_paddr == 0) {
   12807:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1280b:	75 07                	jne    12814 <memory_copy_uvm_data+0x29>
            return -1;
   1280d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12812:	eb 58                	jmp    1286c <memory_copy_uvm_data+0x81>
        }
        uint32_t offset_in_page = to_paddr & (MEM_PAGE_SIZE - 1);
   12814:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12817:	25 ff 0f 00 00       	and    $0xfff,%eax
   1281c:	89 45 ec             	mov    %eax,-0x14(%ebp)
        uint32_t curr_size = MEM_PAGE_SIZE - offset_in_page;
   1281f:	b8 00 10 00 00       	mov    $0x1000,%eax
   12824:	2b 45 ec             	sub    -0x14(%ebp),%eax
   12827:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (curr_size > size) {
   1282a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1282d:	3b 45 14             	cmp    0x14(%ebp),%eax
   12830:	76 06                	jbe    12838 <memory_copy_uvm_data+0x4d>
            curr_size = size;       // 如果比较大，超过页边界，则只拷贝此页内的
   12832:	8b 45 14             	mov    0x14(%ebp),%eax
   12835:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }
        k_memcpy((void *)to_paddr, (void *)from, curr_size);
   12838:	8b 4d f4             	mov    -0xc(%ebp),%ecx
   1283b:	8b 55 10             	mov    0x10(%ebp),%edx
   1283e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12841:	83 ec 04             	sub    $0x4,%esp
   12844:	51                   	push   %ecx
   12845:	52                   	push   %edx
   12846:	50                   	push   %eax
   12847:	e8 1c ee ff ff       	call   11668 <k_memcpy>
   1284c:	83 c4 10             	add    $0x10,%esp

        size -= curr_size;
   1284f:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12852:	29 45 14             	sub    %eax,0x14(%ebp)
        to += curr_size;
   12855:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12858:	01 45 08             	add    %eax,0x8(%ebp)
        from += curr_size;
   1285b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1285e:	01 45 10             	add    %eax,0x10(%ebp)
    while(size > 0){
   12861:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
   12865:	75 8c                	jne    127f3 <memory_copy_uvm_data+0x8>
  }
  return 0;
   12867:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1286c:	c9                   	leave  
   1286d:	c3                   	ret    

0001286e <list_count>:
static inline int list_count (list_t* list) {
   1286e:	55                   	push   %ebp
   1286f:	89 e5                	mov    %esp,%ebp
    return list->count;
   12871:	8b 45 08             	mov    0x8(%ebp),%eax
   12874:	8b 40 08             	mov    0x8(%eax),%eax
}
   12877:	5d                   	pop    %ebp
   12878:	c3                   	ret    

00012879 <mutex_init>:
#include <mux.h>
#include <irq.h>
#include <log.h>

void mutex_init (mutex_t * mutex) {
   12879:	55                   	push   %ebp
   1287a:	89 e5                	mov    %esp,%ebp
   1287c:	83 ec 08             	sub    $0x8,%esp
    mutex->locked_count = 0;
   1287f:	8b 45 08             	mov    0x8(%ebp),%eax
   12882:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    mutex->owner = (task_t *)0;
   12889:	8b 45 08             	mov    0x8(%ebp),%eax
   1288c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    list_init(&mutex->wait_list);
   12892:	8b 45 08             	mov    0x8(%ebp),%eax
   12895:	83 c0 08             	add    $0x8,%eax
   12898:	83 ec 0c             	sub    $0xc,%esp
   1289b:	50                   	push   %eax
   1289c:	e8 f2 f0 ff ff       	call   11993 <list_init>
   128a1:	83 c4 10             	add    $0x10,%esp
}
   128a4:	90                   	nop
   128a5:	c9                   	leave  
   128a6:	c3                   	ret    

000128a7 <mutex_lock>:

void mutex_lock (mutex_t * mutex) {
   128a7:	55                   	push   %ebp
   128a8:	89 e5                	mov    %esp,%ebp
   128aa:	83 ec 18             	sub    $0x18,%esp
    irq_state_t  irq_state = irq_enter_proection();
   128ad:	e8 69 e9 ff ff       	call   1121b <irq_enter_proection>
   128b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t * curr = task_current();
   128b5:	e8 e7 07 00 00       	call   130a1 <task_current>
   128ba:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->locked_count == 0) {
   128bd:	8b 45 08             	mov    0x8(%ebp),%eax
   128c0:	8b 40 04             	mov    0x4(%eax),%eax
   128c3:	85 c0                	test   %eax,%eax
   128c5:	75 14                	jne    128db <mutex_lock+0x34>
        mutex->locked_count = 1;
   128c7:	8b 45 08             	mov    0x8(%ebp),%eax
   128ca:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        mutex->owner = curr;
   128d1:	8b 45 08             	mov    0x8(%ebp),%eax
   128d4:	8b 55 f0             	mov    -0x10(%ebp),%edx
   128d7:	89 10                	mov    %edx,(%eax)
   128d9:	eb 4f                	jmp    1292a <mutex_lock+0x83>
    } else if (mutex->owner == curr) {
   128db:	8b 45 08             	mov    0x8(%ebp),%eax
   128de:	8b 00                	mov    (%eax),%eax
   128e0:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   128e3:	75 11                	jne    128f6 <mutex_lock+0x4f>
        mutex->locked_count++;
   128e5:	8b 45 08             	mov    0x8(%ebp),%eax
   128e8:	8b 40 04             	mov    0x4(%eax),%eax
   128eb:	8d 50 01             	lea    0x1(%eax),%edx
   128ee:	8b 45 08             	mov    0x8(%ebp),%eax
   128f1:	89 50 04             	mov    %edx,0x4(%eax)
   128f4:	eb 34                	jmp    1292a <mutex_lock+0x83>
    } else {
        task_t * curr = task_current();
   128f6:	e8 a6 07 00 00       	call   130a1 <task_current>
   128fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_block(curr);
   128fe:	83 ec 0c             	sub    $0xc,%esp
   12901:	ff 75 ec             	pushl  -0x14(%ebp)
   12904:	e8 d7 07 00 00       	call   130e0 <task_set_block>
   12909:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&mutex->wait_list, &curr->wait_node);
   1290c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1290f:	8d 50 4c             	lea    0x4c(%eax),%edx
   12912:	8b 45 08             	mov    0x8(%ebp),%eax
   12915:	83 c0 08             	add    $0x8,%eax
   12918:	83 ec 08             	sub    $0x8,%esp
   1291b:	52                   	push   %edx
   1291c:	50                   	push   %eax
   1291d:	e8 f5 f0 ff ff       	call   11a17 <list_insert_last>
   12922:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   12925:	e8 85 08 00 00       	call   131af <task_dispatch>
    }

    irq_leave_proection(irq_state);
   1292a:	83 ec 0c             	sub    $0xc,%esp
   1292d:	ff 75 f4             	pushl  -0xc(%ebp)
   12930:	e8 fe e8 ff ff       	call   11233 <irq_leave_proection>
   12935:	83 c4 10             	add    $0x10,%esp
}
   12938:	90                   	nop
   12939:	c9                   	leave  
   1293a:	c3                   	ret    

0001293b <mutex_unlock>:

void mutex_unlock (mutex_t * mutex) {
   1293b:	55                   	push   %ebp
   1293c:	89 e5                	mov    %esp,%ebp
   1293e:	83 ec 18             	sub    $0x18,%esp
    irq_state_t  irq_state = irq_enter_proection();
   12941:	e8 d5 e8 ff ff       	call   1121b <irq_enter_proection>
   12946:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t * curr = task_current();
   12949:	e8 53 07 00 00       	call   130a1 <task_current>
   1294e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (mutex->owner == curr) {
   12951:	8b 45 08             	mov    0x8(%ebp),%eax
   12954:	8b 00                	mov    (%eax),%eax
   12956:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   12959:	0f 85 88 00 00 00    	jne    129e7 <mutex_unlock+0xac>
        if (--mutex->locked_count == 0) {
   1295f:	8b 45 08             	mov    0x8(%ebp),%eax
   12962:	8b 40 04             	mov    0x4(%eax),%eax
   12965:	8d 50 ff             	lea    -0x1(%eax),%edx
   12968:	8b 45 08             	mov    0x8(%ebp),%eax
   1296b:	89 50 04             	mov    %edx,0x4(%eax)
   1296e:	8b 45 08             	mov    0x8(%ebp),%eax
   12971:	8b 40 04             	mov    0x4(%eax),%eax
   12974:	85 c0                	test   %eax,%eax
   12976:	75 6f                	jne    129e7 <mutex_unlock+0xac>
            mutex->owner = (task_t *)0;
   12978:	8b 45 08             	mov    0x8(%ebp),%eax
   1297b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

            if (list_count(&mutex->wait_list)) {
   12981:	8b 45 08             	mov    0x8(%ebp),%eax
   12984:	83 c0 08             	add    $0x8,%eax
   12987:	83 ec 0c             	sub    $0xc,%esp
   1298a:	50                   	push   %eax
   1298b:	e8 de fe ff ff       	call   1286e <list_count>
   12990:	83 c4 10             	add    $0x10,%esp
   12993:	85 c0                	test   %eax,%eax
   12995:	74 50                	je     129e7 <mutex_unlock+0xac>
                list_node_t * task_node = list_delete_first(&mutex->wait_list);
   12997:	8b 45 08             	mov    0x8(%ebp),%eax
   1299a:	83 c0 08             	add    $0x8,%eax
   1299d:	83 ec 0c             	sub    $0xc,%esp
   129a0:	50                   	push   %eax
   129a1:	e8 d5 f0 ff ff       	call   11a7b <list_delete_first>
   129a6:	83 c4 10             	add    $0x10,%esp
   129a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
                task_t * task = list_node_parent(task_node, task_t, wait_node);
   129ac:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   129b0:	74 08                	je     129ba <mutex_unlock+0x7f>
   129b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   129b5:	83 e8 4c             	sub    $0x4c,%eax
   129b8:	eb 05                	jmp    129bf <mutex_unlock+0x84>
   129ba:	b8 00 00 00 00       	mov    $0x0,%eax
   129bf:	89 45 e8             	mov    %eax,-0x18(%ebp)
                task_set_ready(task);
   129c2:	83 ec 0c             	sub    $0xc,%esp
   129c5:	ff 75 e8             	pushl  -0x18(%ebp)
   129c8:	e8 de 06 00 00       	call   130ab <task_set_ready>
   129cd:	83 c4 10             	add    $0x10,%esp

                mutex->locked_count = 1;
   129d0:	8b 45 08             	mov    0x8(%ebp),%eax
   129d3:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
                mutex->owner = task;
   129da:	8b 45 08             	mov    0x8(%ebp),%eax
   129dd:	8b 55 e8             	mov    -0x18(%ebp),%edx
   129e0:	89 10                	mov    %edx,(%eax)

                task_dispatch();
   129e2:	e8 c8 07 00 00       	call   131af <task_dispatch>
            }
        }
    }

    irq_leave_proection(irq_state);
   129e7:	83 ec 0c             	sub    $0xc,%esp
   129ea:	ff 75 f4             	pushl  -0xc(%ebp)
   129ed:	e8 41 e8 ff ff       	call   11233 <irq_leave_proection>
   129f2:	83 c4 10             	add    $0x10,%esp
   129f5:	90                   	nop
   129f6:	c9                   	leave  
   129f7:	c3                   	ret    

000129f8 <list_count>:
static inline int list_count (list_t* list) {
   129f8:	55                   	push   %ebp
   129f9:	89 e5                	mov    %esp,%ebp
    return list->count;
   129fb:	8b 45 08             	mov    0x8(%ebp),%eax
   129fe:	8b 40 08             	mov    0x8(%eax),%eax
}
   12a01:	5d                   	pop    %ebp
   12a02:	c3                   	ret    

00012a03 <sem_init>:
#include <sem.h>
#include <irq.h>

void sem_init(sem_t* sem, int init_count) {
   12a03:	55                   	push   %ebp
   12a04:	89 e5                	mov    %esp,%ebp
   12a06:	83 ec 08             	sub    $0x8,%esp
    sem->count = init_count;
   12a09:	8b 45 08             	mov    0x8(%ebp),%eax
   12a0c:	8b 55 0c             	mov    0xc(%ebp),%edx
   12a0f:	89 10                	mov    %edx,(%eax)
    list_init(&sem->wait_list);
   12a11:	8b 45 08             	mov    0x8(%ebp),%eax
   12a14:	83 c0 04             	add    $0x4,%eax
   12a17:	83 ec 0c             	sub    $0xc,%esp
   12a1a:	50                   	push   %eax
   12a1b:	e8 73 ef ff ff       	call   11993 <list_init>
   12a20:	83 c4 10             	add    $0x10,%esp
}
   12a23:	90                   	nop
   12a24:	c9                   	leave  
   12a25:	c3                   	ret    

00012a26 <sem_wait>:

void sem_wait(sem_t* sem) {
   12a26:	55                   	push   %ebp
   12a27:	89 e5                	mov    %esp,%ebp
   12a29:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_proection();
   12a2c:	e8 ea e7 ff ff       	call   1121b <irq_enter_proection>
   12a31:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (sem->count > 0) {
   12a34:	8b 45 08             	mov    0x8(%ebp),%eax
   12a37:	8b 00                	mov    (%eax),%eax
   12a39:	85 c0                	test   %eax,%eax
   12a3b:	7e 0f                	jle    12a4c <sem_wait+0x26>
        sem->count--;
   12a3d:	8b 45 08             	mov    0x8(%ebp),%eax
   12a40:	8b 00                	mov    (%eax),%eax
   12a42:	8d 50 ff             	lea    -0x1(%eax),%edx
   12a45:	8b 45 08             	mov    0x8(%ebp),%eax
   12a48:	89 10                	mov    %edx,(%eax)
   12a4a:	eb 34                	jmp    12a80 <sem_wait+0x5a>
    } else {
        task_t * curr = task_current();
   12a4c:	e8 50 06 00 00       	call   130a1 <task_current>
   12a51:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   12a54:	83 ec 0c             	sub    $0xc,%esp
   12a57:	ff 75 f0             	pushl  -0x10(%ebp)
   12a5a:	e8 81 06 00 00       	call   130e0 <task_set_block>
   12a5f:	83 c4 10             	add    $0x10,%esp
        list_insert_last(&sem->wait_list, &curr->wait_node);
   12a62:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12a65:	8d 50 4c             	lea    0x4c(%eax),%edx
   12a68:	8b 45 08             	mov    0x8(%ebp),%eax
   12a6b:	83 c0 04             	add    $0x4,%eax
   12a6e:	83 ec 08             	sub    $0x8,%esp
   12a71:	52                   	push   %edx
   12a72:	50                   	push   %eax
   12a73:	e8 9f ef ff ff       	call   11a17 <list_insert_last>
   12a78:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   12a7b:	e8 2f 07 00 00       	call   131af <task_dispatch>
    }
    irq_leave_proection(state);
   12a80:	83 ec 0c             	sub    $0xc,%esp
   12a83:	ff 75 f4             	pushl  -0xc(%ebp)
   12a86:	e8 a8 e7 ff ff       	call   11233 <irq_leave_proection>
   12a8b:	83 c4 10             	add    $0x10,%esp
}
   12a8e:	90                   	nop
   12a8f:	c9                   	leave  
   12a90:	c3                   	ret    

00012a91 <sem_notify>:

void sem_notify(sem_t* sem) {
   12a91:	55                   	push   %ebp
   12a92:	89 e5                	mov    %esp,%ebp
   12a94:	83 ec 18             	sub    $0x18,%esp

    irq_state_t state = irq_enter_proection();
   12a97:	e8 7f e7 ff ff       	call   1121b <irq_enter_proection>
   12a9c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (list_count(&sem->wait_list)) {
   12a9f:	8b 45 08             	mov    0x8(%ebp),%eax
   12aa2:	83 c0 04             	add    $0x4,%eax
   12aa5:	83 ec 0c             	sub    $0xc,%esp
   12aa8:	50                   	push   %eax
   12aa9:	e8 4a ff ff ff       	call   129f8 <list_count>
   12aae:	83 c4 10             	add    $0x10,%esp
   12ab1:	85 c0                	test   %eax,%eax
   12ab3:	74 40                	je     12af5 <sem_notify+0x64>
        list_node_t* node = list_delete_first(&sem->wait_list);
   12ab5:	8b 45 08             	mov    0x8(%ebp),%eax
   12ab8:	83 c0 04             	add    $0x4,%eax
   12abb:	83 ec 0c             	sub    $0xc,%esp
   12abe:	50                   	push   %eax
   12abf:	e8 b7 ef ff ff       	call   11a7b <list_delete_first>
   12ac4:	83 c4 10             	add    $0x10,%esp
   12ac7:	89 45 f0             	mov    %eax,-0x10(%ebp)

        task_t* task = list_node_parent(node, task_t, wait_node);
   12aca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   12ace:	74 08                	je     12ad8 <sem_notify+0x47>
   12ad0:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12ad3:	83 e8 4c             	sub    $0x4c,%eax
   12ad6:	eb 05                	jmp    12add <sem_notify+0x4c>
   12ad8:	b8 00 00 00 00       	mov    $0x0,%eax
   12add:	89 45 ec             	mov    %eax,-0x14(%ebp)
        task_set_ready(task);
   12ae0:	83 ec 0c             	sub    $0xc,%esp
   12ae3:	ff 75 ec             	pushl  -0x14(%ebp)
   12ae6:	e8 c0 05 00 00       	call   130ab <task_set_ready>
   12aeb:	83 c4 10             	add    $0x10,%esp
        task_dispatch();
   12aee:	e8 bc 06 00 00       	call   131af <task_dispatch>
   12af3:	eb 0d                	jmp    12b02 <sem_notify+0x71>
    } else {
        sem->count++;
   12af5:	8b 45 08             	mov    0x8(%ebp),%eax
   12af8:	8b 00                	mov    (%eax),%eax
   12afa:	8d 50 01             	lea    0x1(%eax),%edx
   12afd:	8b 45 08             	mov    0x8(%ebp),%eax
   12b00:	89 10                	mov    %edx,(%eax)
    }
    irq_leave_proection(state);
   12b02:	83 ec 0c             	sub    $0xc,%esp
   12b05:	ff 75 f4             	pushl  -0xc(%ebp)
   12b08:	e8 26 e7 ff ff       	call   11233 <irq_leave_proection>
   12b0d:	83 c4 10             	add    $0x10,%esp

}
   12b10:	90                   	nop
   12b11:	c9                   	leave  
   12b12:	c3                   	ret    

00012b13 <sem_count>:

int  sem_count(sem_t* sem) {
   12b13:	55                   	push   %ebp
   12b14:	89 e5                	mov    %esp,%ebp
   12b16:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_proection();
   12b19:	e8 fd e6 ff ff       	call   1121b <irq_enter_proection>
   12b1e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int count = sem->count;
   12b21:	8b 45 08             	mov    0x8(%ebp),%eax
   12b24:	8b 00                	mov    (%eax),%eax
   12b26:	89 45 f0             	mov    %eax,-0x10(%ebp)
    irq_leave_proection(state);
   12b29:	83 ec 0c             	sub    $0xc,%esp
   12b2c:	ff 75 f4             	pushl  -0xc(%ebp)
   12b2f:	e8 ff e6 ff ff       	call   11233 <irq_leave_proection>
   12b34:	83 c4 10             	add    $0x10,%esp
    return count;
   12b37:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12b3a:	c9                   	leave  
   12b3b:	c3                   	ret    

00012b3c <sys_print_msg>:
#include <log.h>

typedef int (*sys_handle_t)(uint32_t arg0, uint32_t arg1, uint32_t arg2, uint32_t arg3);

// 临时使用
void sys_print_msg(const char* fmt, int arg) {
   12b3c:	55                   	push   %ebp
   12b3d:	89 e5                	mov    %esp,%ebp
   12b3f:	83 ec 08             	sub    $0x8,%esp
    klog(fmt, arg);
   12b42:	83 ec 08             	sub    $0x8,%esp
   12b45:	ff 75 0c             	pushl  0xc(%ebp)
   12b48:	ff 75 08             	pushl  0x8(%ebp)
   12b4b:	e8 02 f1 ff ff       	call   11c52 <klog>
   12b50:	83 c4 10             	add    $0x10,%esp
}
   12b53:	90                   	nop
   12b54:	c9                   	leave  
   12b55:	c3                   	ret    

00012b56 <do_handler_syscall>:
    [SYS_yield] = (sys_handle_t)sys_yield,
};



void do_handler_syscall(syscall_frame_t * frame) {
   12b56:	55                   	push   %ebp
   12b57:	89 e5                	mov    %esp,%ebp
   12b59:	53                   	push   %ebx
   12b5a:	83 ec 14             	sub    $0x14,%esp
    if(frame->func_id < sizeof(sys_table) / sizeof(sys_table[0])) {
   12b5d:	8b 45 08             	mov    0x8(%ebp),%eax
   12b60:	8b 40 3c             	mov    0x3c(%eax),%eax
   12b63:	83 f8 05             	cmp    $0x5,%eax
   12b66:	77 4e                	ja     12bb6 <do_handler_syscall+0x60>
        sys_handle_t handler = sys_table[frame->func_id];
   12b68:	8b 45 08             	mov    0x8(%ebp),%eax
   12b6b:	8b 40 3c             	mov    0x3c(%eax),%eax
   12b6e:	8b 04 85 7c 3f 01 00 	mov    0x13f7c(,%eax,4),%eax
   12b75:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (handler) {
   12b78:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   12b7c:	74 38                	je     12bb6 <do_handler_syscall+0x60>
            int ret = handler(frame->arg0, frame->arg1, frame->arg2, frame->arg3);
   12b7e:	8b 45 08             	mov    0x8(%ebp),%eax
   12b81:	8b 40 4c             	mov    0x4c(%eax),%eax
   12b84:	89 c3                	mov    %eax,%ebx
   12b86:	8b 45 08             	mov    0x8(%ebp),%eax
   12b89:	8b 40 48             	mov    0x48(%eax),%eax
   12b8c:	89 c1                	mov    %eax,%ecx
   12b8e:	8b 45 08             	mov    0x8(%ebp),%eax
   12b91:	8b 40 44             	mov    0x44(%eax),%eax
   12b94:	89 c2                	mov    %eax,%edx
   12b96:	8b 45 08             	mov    0x8(%ebp),%eax
   12b99:	8b 40 40             	mov    0x40(%eax),%eax
   12b9c:	53                   	push   %ebx
   12b9d:	51                   	push   %ecx
   12b9e:	52                   	push   %edx
   12b9f:	50                   	push   %eax
   12ba0:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12ba3:	ff d0                	call   *%eax
   12ba5:	83 c4 10             	add    $0x10,%esp
   12ba8:	89 45 f0             	mov    %eax,-0x10(%ebp)
            frame->eax = ret;   // eax 防止返回值
   12bab:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12bae:	8b 45 08             	mov    0x8(%ebp),%eax
   12bb1:	89 50 30             	mov    %edx,0x30(%eax)
            return;
   12bb4:	eb 30                	jmp    12be6 <do_handler_syscall+0x90>
        }
    }

    task_t * task = task_current();
   12bb6:	e8 e6 04 00 00       	call   130a1 <task_current>
   12bbb:	89 45 ec             	mov    %eax,-0x14(%ebp)
    klog("task: %s, Unkown syscall: %d", task->name, frame->func_id);
   12bbe:	8b 45 08             	mov    0x8(%ebp),%eax
   12bc1:	8b 40 3c             	mov    0x3c(%eax),%eax
   12bc4:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12bc7:	83 c2 08             	add    $0x8,%edx
   12bca:	83 ec 04             	sub    $0x4,%esp
   12bcd:	50                   	push   %eax
   12bce:	52                   	push   %edx
   12bcf:	68 94 3f 01 00       	push   $0x13f94
   12bd4:	e8 79 f0 ff ff       	call   11c52 <klog>
   12bd9:	83 c4 10             	add    $0x10,%esp

    frame->eax = -1;
   12bdc:	8b 45 08             	mov    0x8(%ebp),%eax
   12bdf:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
   12be6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
   12be9:	c9                   	leave  
   12bea:	c3                   	ret    

00012beb <hlt>:
static inline void hlt() {
   12beb:	55                   	push   %ebp
   12bec:	89 e5                	mov    %esp,%ebp
	__asm__ __volatile__("hlt");
   12bee:	f4                   	hlt    
}
   12bef:	90                   	nop
   12bf0:	5d                   	pop    %ebp
   12bf1:	c3                   	ret    

00012bf2 <write_cr3>:
static inline void write_cr3(uint32_t v) {
   12bf2:	55                   	push   %ebp
   12bf3:	89 e5                	mov    %esp,%ebp
    __asm__ __volatile__("mov %[v], %%cr3"::[v]"r"(v));
   12bf5:	8b 45 08             	mov    0x8(%ebp),%eax
   12bf8:	0f 22 d8             	mov    %eax,%cr3
}
   12bfb:	90                   	nop
   12bfc:	5d                   	pop    %ebp
   12bfd:	c3                   	ret    

00012bfe <far_jump>:
static inline void far_jump(uint32_t selector, uint32_t offset) {
   12bfe:	55                   	push   %ebp
   12bff:	89 e5                	mov    %esp,%ebp
   12c01:	83 ec 10             	sub    $0x10,%esp
	volatile uint32_t addr[] = {offset, selector };
   12c04:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c07:	8b 55 08             	mov    0x8(%ebp),%edx
   12c0a:	89 45 f8             	mov    %eax,-0x8(%ebp)
   12c0d:	89 55 fc             	mov    %edx,-0x4(%ebp)
	__asm__ __volatile__("ljmpl *(%[a])"::[a]"r"(addr));
   12c10:	8d 45 f8             	lea    -0x8(%ebp),%eax
   12c13:	ff 28                	ljmp   *(%eax)
}
   12c15:	90                   	nop
   12c16:	c9                   	leave  
   12c17:	c3                   	ret    

00012c18 <write_tr>:
static inline void write_tr (uint16_t tss_selector) {
   12c18:	55                   	push   %ebp
   12c19:	89 e5                	mov    %esp,%ebp
   12c1b:	83 ec 04             	sub    $0x4,%esp
   12c1e:	8b 45 08             	mov    0x8(%ebp),%eax
   12c21:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
    __asm__ __volatile__("ltr %%ax"::"a"(tss_selector));
   12c25:	0f b7 45 fc          	movzwl -0x4(%ebp),%eax
   12c29:	0f 00 d8             	ltr    %ax
}
   12c2c:	90                   	nop
   12c2d:	c9                   	leave  
   12c2e:	c3                   	ret    

00012c2f <list_node_init>:
static inline void list_node_init(list_node_t* node) {
   12c2f:	55                   	push   %ebp
   12c30:	89 e5                	mov    %esp,%ebp
    node->pre = node->next = (list_node_t*)0;
   12c32:	8b 45 08             	mov    0x8(%ebp),%eax
   12c35:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
   12c3c:	8b 45 08             	mov    0x8(%ebp),%eax
   12c3f:	8b 50 04             	mov    0x4(%eax),%edx
   12c42:	8b 45 08             	mov    0x8(%ebp),%eax
   12c45:	89 10                	mov    %edx,(%eax)
}
   12c47:	90                   	nop
   12c48:	5d                   	pop    %ebp
   12c49:	c3                   	ret    

00012c4a <list_node_next>:
static inline list_node_t* list_node_next(list_node_t* node) {
   12c4a:	55                   	push   %ebp
   12c4b:	89 e5                	mov    %esp,%ebp
    return node->next;
   12c4d:	8b 45 08             	mov    0x8(%ebp),%eax
   12c50:	8b 40 04             	mov    0x4(%eax),%eax
}
   12c53:	5d                   	pop    %ebp
   12c54:	c3                   	ret    

00012c55 <list_count>:
static inline int list_count (list_t* list) {
   12c55:	55                   	push   %ebp
   12c56:	89 e5                	mov    %esp,%ebp
    return list->count;
   12c58:	8b 45 08             	mov    0x8(%ebp),%eax
   12c5b:	8b 40 08             	mov    0x8(%eax),%eax
}
   12c5e:	5d                   	pop    %ebp
   12c5f:	c3                   	ret    

00012c60 <list_first>:
static inline list_node_t* list_first (list_t* list) {
   12c60:	55                   	push   %ebp
   12c61:	89 e5                	mov    %esp,%ebp
    return list->first;
   12c63:	8b 45 08             	mov    0x8(%ebp),%eax
   12c66:	8b 00                	mov    (%eax),%eax
}
   12c68:	5d                   	pop    %ebp
   12c69:	c3                   	ret    

00012c6a <mmu_set_page_dir>:
static inline void mmu_set_page_dir(uint32_t paddr) {
   12c6a:	55                   	push   %ebp
   12c6b:	89 e5                	mov    %esp,%ebp
    write_cr3(paddr);
   12c6d:	ff 75 08             	pushl  0x8(%ebp)
   12c70:	e8 7d ff ff ff       	call   12bf2 <write_cr3>
   12c75:	83 c4 04             	add    $0x4,%esp
}
   12c78:	90                   	nop
   12c79:	c9                   	leave  
   12c7a:	c3                   	ret    

00012c7b <idle_task_func>:
static task_manager_t   g_task_manager;
static uint32_t         idle_task_stack[2048];
static task_t           g_task_table[128];
static mutex_t          task_table_mutex;

static void idle_task_func() { for(;;) hlt(); }
   12c7b:	55                   	push   %ebp
   12c7c:	89 e5                	mov    %esp,%ebp
   12c7e:	e8 68 ff ff ff       	call   12beb <hlt>
   12c83:	eb f9                	jmp    12c7e <idle_task_func+0x3>

00012c85 <task_switch_from_to>:

void simple_switch(uint32_t **from, uint32_t* to);

void task_switch_from_to(task_t* from, task_t* to) {
   12c85:	55                   	push   %ebp
   12c86:	89 e5                	mov    %esp,%ebp
    #ifndef USE_TSS
    simple_switch(&from->stack, to->stack);  // 使用直接跳转机制
    #else
    far_jump(to->tss_sel, 0);             // 使用 tss 机制
   12c88:	8b 45 0c             	mov    0xc(%ebp),%eax
   12c8b:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   12c91:	6a 00                	push   $0x0
   12c93:	50                   	push   %eax
   12c94:	e8 65 ff ff ff       	call   12bfe <far_jump>
   12c99:	83 c4 08             	add    $0x8,%esp
    #endif
}
   12c9c:	90                   	nop
   12c9d:	c9                   	leave  
   12c9e:	c3                   	ret    

00012c9f <tss_init>:


#ifdef USE_TSS
static int tss_init(task_t* task, int flag, uint32_t entry, uint32_t esp) {
   12c9f:	55                   	push   %ebp
   12ca0:	89 e5                	mov    %esp,%ebp
   12ca2:	83 ec 28             	sub    $0x28,%esp
    int tss_sel = gdt_alloc_desc();
   12ca5:	e8 68 da ff ff       	call   10712 <gdt_alloc_desc>
   12caa:	89 45 ec             	mov    %eax,-0x14(%ebp)

    segment_desc_set(tss_sel, (uint32_t)&task->tss, sizeof(tss_t), 
   12cad:	8b 45 08             	mov    0x8(%ebp),%eax
   12cb0:	83 c0 54             	add    $0x54,%eax
   12cb3:	68 89 00 00 00       	push   $0x89
   12cb8:	6a 68                	push   $0x68
   12cba:	50                   	push   %eax
   12cbb:	ff 75 ec             	pushl  -0x14(%ebp)
   12cbe:	e8 2e d9 ff ff       	call   105f1 <segment_desc_set>
   12cc3:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL0 | SEG_TYPE_TSS );

    k_memset(&task->tss, 0, sizeof(tss_t));
   12cc6:	8b 45 08             	mov    0x8(%ebp),%eax
   12cc9:	83 c0 54             	add    $0x54,%eax
   12ccc:	83 ec 04             	sub    $0x4,%esp
   12ccf:	6a 68                	push   $0x68
   12cd1:	6a 00                	push   $0x0
   12cd3:	50                   	push   %eax
   12cd4:	e8 de e9 ff ff       	call   116b7 <k_memset>
   12cd9:	83 c4 10             	add    $0x10,%esp

    uint32_t kernel_stack = memory_alloc_page();
   12cdc:	e8 cb f7 ff ff       	call   124ac <memory_alloc_page>
   12ce1:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (kernel_stack == 0) {
   12ce4:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12ce8:	0f 84 da 00 00 00    	je     12dc8 <tss_init+0x129>
        goto tss_init_failed;
    }

    int code_sel, data_sel;
    if (flag & TASK_FLAGS_SYSTEM) {
   12cee:	8b 45 0c             	mov    0xc(%ebp),%eax
   12cf1:	83 e0 01             	and    $0x1,%eax
   12cf4:	85 c0                	test   %eax,%eax
   12cf6:	74 10                	je     12d08 <tss_init+0x69>
        code_sel = KERNEL_SELECTOR_CS;
   12cf8:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%ebp)
        data_sel = KERNEL_SELECTOR_DS;
   12cff:	c7 45 f0 10 00 00 00 	movl   $0x10,-0x10(%ebp)
   12d06:	eb 16                	jmp    12d1e <tss_init+0x7f>
    } else {
        code_sel = g_task_manager.app_code_sel | SEG_RPL3;
   12d08:	a1 a8 21 03 00       	mov    0x321a8,%eax
   12d0d:	83 c8 03             	or     $0x3,%eax
   12d10:	89 45 f4             	mov    %eax,-0xc(%ebp)
        data_sel = g_task_manager.app_data_sel | SEG_RPL3;
   12d13:	a1 ac 21 03 00       	mov    0x321ac,%eax
   12d18:	83 c8 03             	or     $0x3,%eax
   12d1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }

    task->tss.eip  = entry;
   12d1e:	8b 45 08             	mov    0x8(%ebp),%eax
   12d21:	8b 55 10             	mov    0x10(%ebp),%edx
   12d24:	89 50 74             	mov    %edx,0x74(%eax)
    task->tss.esp  = esp;
   12d27:	8b 45 08             	mov    0x8(%ebp),%eax
   12d2a:	8b 55 14             	mov    0x14(%ebp),%edx
   12d2d:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
    task->tss.esp0 = kernel_stack + MEM_PAGE_SIZE;
   12d33:	8b 45 e8             	mov    -0x18(%ebp),%eax
   12d36:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
   12d3c:	8b 45 08             	mov    0x8(%ebp),%eax
   12d3f:	89 50 58             	mov    %edx,0x58(%eax)
    task->tss.ss  = data_sel;
   12d42:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12d45:	8b 45 08             	mov    0x8(%ebp),%eax
   12d48:	89 90 a4 00 00 00    	mov    %edx,0xa4(%eax)
    task->tss.ss0 = KERNEL_SELECTOR_DS;
   12d4e:	8b 45 08             	mov    0x8(%ebp),%eax
   12d51:	c7 40 5c 10 00 00 00 	movl   $0x10,0x5c(%eax)
    task->tss.es  = data_sel;
   12d58:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12d5b:	8b 45 08             	mov    0x8(%ebp),%eax
   12d5e:	89 90 9c 00 00 00    	mov    %edx,0x9c(%eax)
    task->tss.ds  = data_sel;
   12d64:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12d67:	8b 45 08             	mov    0x8(%ebp),%eax
   12d6a:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
    task->tss.fs  = data_sel;
   12d70:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12d73:	8b 45 08             	mov    0x8(%ebp),%eax
   12d76:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
    task->tss.gs  = data_sel;
   12d7c:	8b 55 f0             	mov    -0x10(%ebp),%edx
   12d7f:	8b 45 08             	mov    0x8(%ebp),%eax
   12d82:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
    task->tss.cs  = code_sel;
   12d88:	8b 55 f4             	mov    -0xc(%ebp),%edx
   12d8b:	8b 45 08             	mov    0x8(%ebp),%eax
   12d8e:	89 90 a0 00 00 00    	mov    %edx,0xa0(%eax)
    
    task->tss.eflags = EFLAGES_DEFAULT | EFLAGS_IF;
   12d94:	8b 45 08             	mov    0x8(%ebp),%eax
   12d97:	c7 40 78 02 02 00 00 	movl   $0x202,0x78(%eax)

    uint32_t page_dir = memory_create_uvm();
   12d9e:	e8 74 f5 ff ff       	call   12317 <memory_create_uvm>
   12da3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if(page_dir == 0) {
   12da6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   12daa:	74 1f                	je     12dcb <tss_init+0x12c>
        goto tss_init_failed;
    }
    task->tss.cr3 = page_dir;
   12dac:	8b 45 08             	mov    0x8(%ebp),%eax
   12daf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
   12db2:	89 50 70             	mov    %edx,0x70(%eax)
    task->tss_sel = tss_sel;
   12db5:	8b 55 ec             	mov    -0x14(%ebp),%edx
   12db8:	8b 45 08             	mov    0x8(%ebp),%eax
   12dbb:	89 90 bc 00 00 00    	mov    %edx,0xbc(%eax)

    return 0;
   12dc1:	b8 00 00 00 00       	mov    $0x0,%eax
   12dc6:	eb 2b                	jmp    12df3 <tss_init+0x154>
        goto tss_init_failed;
   12dc8:	90                   	nop
   12dc9:	eb 01                	jmp    12dcc <tss_init+0x12d>
        goto tss_init_failed;
   12dcb:	90                   	nop

tss_init_failed:

    gdt_free_sel(tss_sel);
   12dcc:	83 ec 0c             	sub    $0xc,%esp
   12dcf:	ff 75 ec             	pushl  -0x14(%ebp)
   12dd2:	e8 b0 d9 ff ff       	call   10787 <gdt_free_sel>
   12dd7:	83 c4 10             	add    $0x10,%esp
    if(kernel_stack) {
   12dda:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   12dde:	74 0e                	je     12dee <tss_init+0x14f>
        memory_free_page(kernel_stack);
   12de0:	83 ec 0c             	sub    $0xc,%esp
   12de3:	ff 75 e8             	pushl  -0x18(%ebp)
   12de6:	e8 f1 f6 ff ff       	call   124dc <memory_free_page>
   12deb:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   12dee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   12df3:	c9                   	leave  
   12df4:	c3                   	ret    

00012df5 <task_init>:
#endif

// 初始化一个任务
int task_init(task_t* task, const char* name, int flag, uint32_t entry, uint32_t esp) {
   12df5:	55                   	push   %ebp
   12df6:	89 e5                	mov    %esp,%ebp
   12df8:	83 ec 18             	sub    $0x18,%esp
        *(--pesp) = 0;
        *(--pesp) = 0;
        task->stack = pesp;
    }
    #else
    if (tss_init(task, flag, entry, esp) == -1) return -1;  // 使用 tss 机制
   12dfb:	ff 75 18             	pushl  0x18(%ebp)
   12dfe:	ff 75 14             	pushl  0x14(%ebp)
   12e01:	ff 75 10             	pushl  0x10(%ebp)
   12e04:	ff 75 08             	pushl  0x8(%ebp)
   12e07:	e8 93 fe ff ff       	call   12c9f <tss_init>
   12e0c:	83 c4 10             	add    $0x10,%esp
   12e0f:	83 f8 ff             	cmp    $0xffffffff,%eax
   12e12:	75 0a                	jne    12e1e <task_init+0x29>
   12e14:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   12e19:	e9 ba 00 00 00       	jmp    12ed8 <task_init+0xe3>
    #endif

    k_strncpy(task->name, name, TASK_NAME_SIZE);        // 进程名
   12e1e:	8b 45 08             	mov    0x8(%ebp),%eax
   12e21:	83 c0 08             	add    $0x8,%eax
   12e24:	83 ec 04             	sub    $0x4,%esp
   12e27:	6a 20                	push   $0x20
   12e29:	ff 75 0c             	pushl  0xc(%ebp)
   12e2c:	50                   	push   %eax
   12e2d:	e8 11 e7 ff ff       	call   11543 <k_strncpy>
   12e32:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_CREATED;                         // 状态  created
   12e35:	8b 45 08             	mov    0x8(%ebp),%eax
   12e38:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    task->time_ticks = TASK_TIME_SLICE_DEFAULT;         //  最大时间片
   12e3f:	8b 45 08             	mov    0x8(%ebp),%eax
   12e42:	c7 40 34 0a 00 00 00 	movl   $0xa,0x34(%eax)
    task->slice_ticks = TASK_TIME_SLICE_DEFAULT;        //  当前时间片
   12e49:	8b 45 08             	mov    0x8(%ebp),%eax
   12e4c:	c7 40 30 0a 00 00 00 	movl   $0xa,0x30(%eax)
    task->sleep_ticks = 0;
   12e53:	8b 45 08             	mov    0x8(%ebp),%eax
   12e56:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
    task->parent = (task_t*)0;
   12e5d:	8b 45 08             	mov    0x8(%ebp),%eax
   12e60:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
    list_node_init(&task->all_node); 
   12e67:	8b 45 08             	mov    0x8(%ebp),%eax
   12e6a:	83 c0 44             	add    $0x44,%eax
   12e6d:	83 ec 0c             	sub    $0xc,%esp
   12e70:	50                   	push   %eax
   12e71:	e8 b9 fd ff ff       	call   12c2f <list_node_init>
   12e76:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->run_node);
   12e79:	8b 45 08             	mov    0x8(%ebp),%eax
   12e7c:	83 c0 3c             	add    $0x3c,%eax
   12e7f:	83 ec 0c             	sub    $0xc,%esp
   12e82:	50                   	push   %eax
   12e83:	e8 a7 fd ff ff       	call   12c2f <list_node_init>
   12e88:	83 c4 10             	add    $0x10,%esp
    list_node_init(&task->wait_node);
   12e8b:	8b 45 08             	mov    0x8(%ebp),%eax
   12e8e:	83 c0 4c             	add    $0x4c,%eax
   12e91:	83 ec 0c             	sub    $0xc,%esp
   12e94:	50                   	push   %eax
   12e95:	e8 95 fd ff ff       	call   12c2f <list_node_init>
   12e9a:	83 c4 10             	add    $0x10,%esp
    
    task->pid = (uint32_t)task;
   12e9d:	8b 55 08             	mov    0x8(%ebp),%edx
   12ea0:	8b 45 08             	mov    0x8(%ebp),%eax
   12ea3:	89 50 28             	mov    %edx,0x28(%eax)

    irq_state_t state = irq_enter_proection();   //--enter protection
   12ea6:	e8 70 e3 ff ff       	call   1121b <irq_enter_proection>
   12eab:	89 45 f4             	mov    %eax,-0xc(%ebp)
        list_insert_last(&g_task_manager.task_list, &task->all_node);  // 加入到所有队列
   12eae:	8b 45 08             	mov    0x8(%ebp),%eax
   12eb1:	83 c0 44             	add    $0x44,%eax
   12eb4:	83 ec 08             	sub    $0x8,%esp
   12eb7:	50                   	push   %eax
   12eb8:	68 1c 20 03 00       	push   $0x3201c
   12ebd:	e8 55 eb ff ff       	call   11a17 <list_insert_last>
   12ec2:	83 c4 10             	add    $0x10,%esp
    irq_leave_proection(state);  //--leave protection
   12ec5:	83 ec 0c             	sub    $0xc,%esp
   12ec8:	ff 75 f4             	pushl  -0xc(%ebp)
   12ecb:	e8 63 e3 ff ff       	call   11233 <irq_leave_proection>
   12ed0:	83 c4 10             	add    $0x10,%esp

    return 0;
   12ed3:	b8 00 00 00 00       	mov    $0x0,%eax
}
   12ed8:	c9                   	leave  
   12ed9:	c3                   	ret    

00012eda <task_start>:

void task_start(task_t* task) {
   12eda:	55                   	push   %ebp
   12edb:	89 e5                	mov    %esp,%ebp
   12edd:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_proection();   //--enter protection
   12ee0:	e8 36 e3 ff ff       	call   1121b <irq_enter_proection>
   12ee5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
        task_set_ready(task);                                        // 加入到就绪队列
   12ee8:	83 ec 0c             	sub    $0xc,%esp
   12eeb:	ff 75 08             	pushl  0x8(%ebp)
   12eee:	e8 b8 01 00 00       	call   130ab <task_set_ready>
   12ef3:	83 c4 10             	add    $0x10,%esp
    
    irq_leave_proection(state);  //--leave protection
   12ef6:	83 ec 0c             	sub    $0xc,%esp
   12ef9:	ff 75 f4             	pushl  -0xc(%ebp)
   12efc:	e8 32 e3 ff ff       	call   11233 <irq_leave_proection>
   12f01:	83 c4 10             	add    $0x10,%esp
}
   12f04:	90                   	nop
   12f05:	c9                   	leave  
   12f06:	c3                   	ret    

00012f07 <task_manager_init>:


// 初始化任务管理
void task_manager_init() {
   12f07:	55                   	push   %ebp
   12f08:	89 e5                	mov    %esp,%ebp
   12f0a:	83 ec 18             	sub    $0x18,%esp
    k_memset(g_task_table, 0, sizeof(g_task_table));
   12f0d:	83 ec 04             	sub    $0x4,%esp
   12f10:	68 00 60 00 00       	push   $0x6000
   12f15:	6a 00                	push   $0x0
   12f17:	68 c0 41 03 00       	push   $0x341c0
   12f1c:	e8 96 e7 ff ff       	call   116b7 <k_memset>
   12f21:	83 c4 10             	add    $0x10,%esp
    mutex_init(&task_table_mutex);
   12f24:	83 ec 0c             	sub    $0xc,%esp
   12f27:	68 c0 a1 03 00       	push   $0x3a1c0
   12f2c:	e8 48 f9 ff ff       	call   12879 <mutex_init>
   12f31:	83 c4 10             	add    $0x10,%esp


    int seld = gdt_alloc_desc();
   12f34:	e8 d9 d7 ff ff       	call   10712 <gdt_alloc_desc>
   12f39:	89 45 f4             	mov    %eax,-0xc(%ebp)
    segment_desc_set(seld, 0x00000000, 0xffffffff, 
   12f3c:	68 f2 40 00 00       	push   $0x40f2
   12f41:	6a ff                	push   $0xffffffff
   12f43:	6a 00                	push   $0x0
   12f45:	ff 75 f4             	pushl  -0xc(%ebp)
   12f48:	e8 a4 d6 ff ff       	call   105f1 <segment_desc_set>
   12f4d:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_DATA
        | SEG_TYPE_RW | SEG_D
    );
    g_task_manager.app_data_sel = seld;
   12f50:	8b 45 f4             	mov    -0xc(%ebp),%eax
   12f53:	a3 ac 21 03 00       	mov    %eax,0x321ac

    int selc = gdt_alloc_desc();
   12f58:	e8 b5 d7 ff ff       	call   10712 <gdt_alloc_desc>
   12f5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
    segment_desc_set(selc, 0x00000000, 0xffffffff, 
   12f60:	68 fa 40 00 00       	push   $0x40fa
   12f65:	6a ff                	push   $0xffffffff
   12f67:	6a 00                	push   $0x0
   12f69:	ff 75 f0             	pushl  -0x10(%ebp)
   12f6c:	e8 80 d6 ff ff       	call   105f1 <segment_desc_set>
   12f71:	83 c4 10             	add    $0x10,%esp
        SEG_P_PRESENT | SEG_DPL3 | SEG_S_NORMAL | SEG_TYPE_CODE 
        | SEG_TYPE_RW | SEG_D
    );
    g_task_manager.app_code_sel = selc;
   12f74:	8b 45 f0             	mov    -0x10(%ebp),%eax
   12f77:	a3 a8 21 03 00       	mov    %eax,0x321a8

    list_init(&g_task_manager.ready_list);
   12f7c:	83 ec 0c             	sub    $0xc,%esp
   12f7f:	68 04 20 03 00       	push   $0x32004
   12f84:	e8 0a ea ff ff       	call   11993 <list_init>
   12f89:	83 c4 10             	add    $0x10,%esp
    list_init(&g_task_manager.task_list);
   12f8c:	83 ec 0c             	sub    $0xc,%esp
   12f8f:	68 1c 20 03 00       	push   $0x3201c
   12f94:	e8 fa e9 ff ff       	call   11993 <list_init>
   12f99:	83 c4 10             	add    $0x10,%esp
    list_init(&g_task_manager.sleep_list);
   12f9c:	83 ec 0c             	sub    $0xc,%esp
   12f9f:	68 10 20 03 00       	push   $0x32010
   12fa4:	e8 ea e9 ff ff       	call   11993 <list_init>
   12fa9:	83 c4 10             	add    $0x10,%esp
    g_task_manager.curr_task = get_first_task();
   12fac:	e8 e6 00 00 00       	call   13097 <get_first_task>
   12fb1:	a3 00 20 03 00       	mov    %eax,0x32000
    
    task_init(&g_task_manager.idle_task,  
   12fb6:	ba c0 41 03 00       	mov    $0x341c0,%edx
   12fbb:	b8 7b 2c 01 00       	mov    $0x12c7b,%eax
   12fc0:	83 ec 0c             	sub    $0xc,%esp
   12fc3:	52                   	push   %edx
   12fc4:	50                   	push   %eax
   12fc5:	6a 01                	push   $0x1
   12fc7:	68 b1 3f 01 00       	push   $0x13fb1
   12fcc:	68 e8 20 03 00       	push   $0x320e8
   12fd1:	e8 1f fe ff ff       	call   12df5 <task_init>
   12fd6:	83 c4 20             	add    $0x20,%esp
            "idle  task", 
            TASK_FLAGS_SYSTEM,
            (uint32_t)idle_task_func, 
            (uint32_t)&idle_task_stack[2048]
    );
    task_start(&g_task_manager.idle_task);
   12fd9:	83 ec 0c             	sub    $0xc,%esp
   12fdc:	68 e8 20 03 00       	push   $0x320e8
   12fe1:	e8 f4 fe ff ff       	call   12eda <task_start>
   12fe6:	83 c4 10             	add    $0x10,%esp
}
   12fe9:	90                   	nop
   12fea:	c9                   	leave  
   12feb:	c3                   	ret    

00012fec <first_task_init>:


void first_task_init() {
   12fec:	55                   	push   %ebp
   12fed:	89 e5                	mov    %esp,%ebp
   12fef:	83 ec 18             	sub    $0x18,%esp

    void first_task_entry();
    extern uint8_t s_first_task[], e_first_task[];

    uint32_t copy_size = (uint32_t)(e_first_task - s_first_task);
   12ff2:	ba 14 c4 03 00       	mov    $0x3c414,%edx
   12ff7:	b8 e0 c1 03 00       	mov    $0x3c1e0,%eax
   12ffc:	29 c2                	sub    %eax,%edx
   12ffe:	89 d0                	mov    %edx,%eax
   13000:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t alloc_size = 10 * MEM_PAGE_SIZE;
   13003:	c7 45 f0 00 a0 00 00 	movl   $0xa000,-0x10(%ebp)

    uint32_t first_start = (uint32_t)first_task_entry;
   1300a:	c7 45 ec 00 00 00 80 	movl   $0x80000000,-0x14(%ebp)

    // first_start + alloc_size 栈顶
    task_init(&g_task_manager.first_task, 
   13011:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13014:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13017:	01 d0                	add    %edx,%eax
   13019:	83 ec 0c             	sub    $0xc,%esp
   1301c:	50                   	push   %eax
   1301d:	ff 75 ec             	pushl  -0x14(%ebp)
   13020:	6a 00                	push   $0x0
   13022:	68 bc 3f 01 00       	push   $0x13fbc
   13027:	68 28 20 03 00       	push   $0x32028
   1302c:	e8 c4 fd ff ff       	call   12df5 <task_init>
   13031:	83 c4 20             	add    $0x20,%esp
            "first task", 0, 
            first_start, 
            first_start + alloc_size );
    
    mmu_set_page_dir((&g_task_manager)->first_task.tss.cr3);
   13034:	a1 98 20 03 00       	mov    0x32098,%eax
   13039:	83 ec 0c             	sub    $0xc,%esp
   1303c:	50                   	push   %eax
   1303d:	e8 28 fc ff ff       	call   12c6a <mmu_set_page_dir>
   13042:	83 c4 10             	add    $0x10,%esp

    memory_alloc_page_for(first_start, alloc_size, PTE_P | PTE_W | PTE_U);
   13045:	83 ec 04             	sub    $0x4,%esp
   13048:	6a 07                	push   $0x7
   1304a:	ff 75 f0             	pushl  -0x10(%ebp)
   1304d:	ff 75 ec             	pushl  -0x14(%ebp)
   13050:	e8 30 f4 ff ff       	call   12485 <memory_alloc_page_for>
   13055:	83 c4 10             	add    $0x10,%esp
    k_memcpy( (void*)first_start, (void *)&s_first_task, copy_size );
   13058:	8b 55 f4             	mov    -0xc(%ebp),%edx
   1305b:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1305e:	83 ec 04             	sub    $0x4,%esp
   13061:	52                   	push   %edx
   13062:	68 e0 c1 03 00       	push   $0x3c1e0
   13067:	50                   	push   %eax
   13068:	e8 fb e5 ff ff       	call   11668 <k_memcpy>
   1306d:	83 c4 10             	add    $0x10,%esp


    write_tr((&g_task_manager)->first_task.tss_sel);
   13070:	a1 e4 20 03 00       	mov    0x320e4,%eax
   13075:	0f b7 c0             	movzwl %ax,%eax
   13078:	83 ec 0c             	sub    $0xc,%esp
   1307b:	50                   	push   %eax
   1307c:	e8 97 fb ff ff       	call   12c18 <write_tr>
   13081:	83 c4 10             	add    $0x10,%esp

    task_start(&g_task_manager.first_task);
   13084:	83 ec 0c             	sub    $0xc,%esp
   13087:	68 28 20 03 00       	push   $0x32028
   1308c:	e8 49 fe ff ff       	call   12eda <task_start>
   13091:	83 c4 10             	add    $0x10,%esp
}
   13094:	90                   	nop
   13095:	c9                   	leave  
   13096:	c3                   	ret    

00013097 <get_first_task>:



task_t* get_first_task() {
   13097:	55                   	push   %ebp
   13098:	89 e5                	mov    %esp,%ebp
    return &g_task_manager.first_task;
   1309a:	b8 28 20 03 00       	mov    $0x32028,%eax
}
   1309f:	5d                   	pop    %ebp
   130a0:	c3                   	ret    

000130a1 <task_current>:

task_t* task_current() {
   130a1:	55                   	push   %ebp
   130a2:	89 e5                	mov    %esp,%ebp
    return g_task_manager.curr_task;
   130a4:	a1 00 20 03 00       	mov    0x32000,%eax
}
   130a9:	5d                   	pop    %ebp
   130aa:	c3                   	ret    

000130ab <task_set_ready>:


// 将任务添加到就绪队列 尾部 设置状态为 ready
void task_set_ready(task_t* task) {
   130ab:	55                   	push   %ebp
   130ac:	89 e5                	mov    %esp,%ebp
   130ae:	83 ec 08             	sub    $0x8,%esp
    if (task == &g_task_manager.idle_task) {  // 空进程不应该加入就绪队列
   130b1:	81 7d 08 e8 20 03 00 	cmpl   $0x320e8,0x8(%ebp)
   130b8:	74 23                	je     130dd <task_set_ready+0x32>
        return;
    }

    list_insert_last(&g_task_manager.ready_list, &task->run_node);
   130ba:	8b 45 08             	mov    0x8(%ebp),%eax
   130bd:	83 c0 3c             	add    $0x3c,%eax
   130c0:	83 ec 08             	sub    $0x8,%esp
   130c3:	50                   	push   %eax
   130c4:	68 04 20 03 00       	push   $0x32004
   130c9:	e8 49 e9 ff ff       	call   11a17 <list_insert_last>
   130ce:	83 c4 10             	add    $0x10,%esp
    task->state = TASK_READY;
   130d1:	8b 45 08             	mov    0x8(%ebp),%eax
   130d4:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
   130db:	eb 01                	jmp    130de <task_set_ready+0x33>
        return;
   130dd:	90                   	nop
}
   130de:	c9                   	leave  
   130df:	c3                   	ret    

000130e0 <task_set_block>:

// 将 特定 任务从就绪队列删除
void task_set_block(task_t* task) {
   130e0:	55                   	push   %ebp
   130e1:	89 e5                	mov    %esp,%ebp
   130e3:	83 ec 08             	sub    $0x8,%esp
    if (task == &g_task_manager.idle_task) {  // 空进程不应该删除
   130e6:	81 7d 08 e8 20 03 00 	cmpl   $0x320e8,0x8(%ebp)
   130ed:	74 19                	je     13108 <task_set_block+0x28>
        return;
    }
    list_delete(&g_task_manager.ready_list, &task->run_node);
   130ef:	8b 45 08             	mov    0x8(%ebp),%eax
   130f2:	83 c0 3c             	add    $0x3c,%eax
   130f5:	83 ec 08             	sub    $0x8,%esp
   130f8:	50                   	push   %eax
   130f9:	68 04 20 03 00       	push   $0x32004
   130fe:	e8 f1 e9 ff ff       	call   11af4 <list_delete>
   13103:	83 c4 10             	add    $0x10,%esp
   13106:	eb 01                	jmp    13109 <task_set_block+0x29>
        return;
   13108:	90                   	nop
    // list_delete_first(&g_task_manager.ready_list);
}
   13109:	c9                   	leave  
   1310a:	c3                   	ret    

0001310b <sys_yield>:

// 主动放弃cpu执行
int  sys_yield() {
   1310b:	55                   	push   %ebp
   1310c:	89 e5                	mov    %esp,%ebp
   1310e:	83 ec 18             	sub    $0x18,%esp

    irq_state_t state = irq_enter_proection();   //--enter protection
   13111:	e8 05 e1 ff ff       	call   1121b <irq_enter_proection>
   13116:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    if(list_count(&g_task_manager.ready_list) > 1) {
   13119:	83 ec 0c             	sub    $0xc,%esp
   1311c:	68 04 20 03 00       	push   $0x32004
   13121:	e8 2f fb ff ff       	call   12c55 <list_count>
   13126:	83 c4 10             	add    $0x10,%esp
   13129:	83 f8 01             	cmp    $0x1,%eax
   1312c:	7e 29                	jle    13157 <sys_yield+0x4c>
        task_t* curr = task_current();
   1312e:	e8 6e ff ff ff       	call   130a1 <task_current>
   13133:	89 45 f0             	mov    %eax,-0x10(%ebp)
        task_set_block(curr);
   13136:	83 ec 0c             	sub    $0xc,%esp
   13139:	ff 75 f0             	pushl  -0x10(%ebp)
   1313c:	e8 9f ff ff ff       	call   130e0 <task_set_block>
   13141:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr);
   13144:	83 ec 0c             	sub    $0xc,%esp
   13147:	ff 75 f0             	pushl  -0x10(%ebp)
   1314a:	e8 5c ff ff ff       	call   130ab <task_set_ready>
   1314f:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   13152:	e8 58 00 00 00       	call   131af <task_dispatch>
    }
    
    irq_leave_proection(state);  //--leave protection
   13157:	83 ec 0c             	sub    $0xc,%esp
   1315a:	ff 75 f4             	pushl  -0xc(%ebp)
   1315d:	e8 d1 e0 ff ff       	call   11233 <irq_leave_proection>
   13162:	83 c4 10             	add    $0x10,%esp

    return 0;
   13165:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1316a:	c9                   	leave  
   1316b:	c3                   	ret    

0001316c <task_next_run>:

// 从就绪队列中找到一第一个任务
task_t * task_next_run() {
   1316c:	55                   	push   %ebp
   1316d:	89 e5                	mov    %esp,%ebp
   1316f:	83 ec 10             	sub    $0x10,%esp
    if (list_count(&g_task_manager.ready_list) == 0) {
   13172:	68 04 20 03 00       	push   $0x32004
   13177:	e8 d9 fa ff ff       	call   12c55 <list_count>
   1317c:	83 c4 04             	add    $0x4,%esp
   1317f:	85 c0                	test   %eax,%eax
   13181:	75 07                	jne    1318a <task_next_run+0x1e>
        return &g_task_manager.idle_task;
   13183:	b8 e8 20 03 00       	mov    $0x320e8,%eax
   13188:	eb 23                	jmp    131ad <task_next_run+0x41>
    }

    list_node_t * task_node = list_first(&g_task_manager.ready_list);
   1318a:	68 04 20 03 00       	push   $0x32004
   1318f:	e8 cc fa ff ff       	call   12c60 <list_first>
   13194:	83 c4 04             	add    $0x4,%esp
   13197:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return list_node_parent(task_node, task_t, run_node);
   1319a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
   1319e:	74 08                	je     131a8 <task_next_run+0x3c>
   131a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
   131a3:	83 e8 3c             	sub    $0x3c,%eax
   131a6:	eb 05                	jmp    131ad <task_next_run+0x41>
   131a8:	b8 00 00 00 00       	mov    $0x0,%eax
}
   131ad:	c9                   	leave  
   131ae:	c3                   	ret    

000131af <task_dispatch>:

// 分配一个任务并从当前任务切换过去
void task_dispatch() {
   131af:	55                   	push   %ebp
   131b0:	89 e5                	mov    %esp,%ebp
   131b2:	83 ec 18             	sub    $0x18,%esp

    irq_state_t state = irq_enter_proection();   //--enter protection
   131b5:	e8 61 e0 ff ff       	call   1121b <irq_enter_proection>
   131ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
    task_t * to = task_next_run();
   131bd:	e8 aa ff ff ff       	call   1316c <task_next_run>
   131c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (to != g_task_manager.curr_task) {
   131c5:	a1 00 20 03 00       	mov    0x32000,%eax
   131ca:	39 45 f0             	cmp    %eax,-0x10(%ebp)
   131cd:	74 2b                	je     131fa <task_dispatch+0x4b>
        task_t * from = task_current();
   131cf:	e8 cd fe ff ff       	call   130a1 <task_current>
   131d4:	89 45 ec             	mov    %eax,-0x14(%ebp)

        g_task_manager.curr_task = to;   // 设置将要切换的任务为“当前任务”
   131d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
   131da:	a3 00 20 03 00       	mov    %eax,0x32000
        to->state = TASK_RUNNING;      // 设置 task running
   131df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   131e2:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)

        task_switch_from_to(from, to);
   131e9:	83 ec 08             	sub    $0x8,%esp
   131ec:	ff 75 f0             	pushl  -0x10(%ebp)
   131ef:	ff 75 ec             	pushl  -0x14(%ebp)
   131f2:	e8 8e fa ff ff       	call   12c85 <task_switch_from_to>
   131f7:	83 c4 10             	add    $0x10,%esp
    }
    irq_leave_proection(state);  //--leave protection
   131fa:	83 ec 0c             	sub    $0xc,%esp
   131fd:	ff 75 f4             	pushl  -0xc(%ebp)
   13200:	e8 2e e0 ff ff       	call   11233 <irq_leave_proection>
   13205:	83 c4 10             	add    $0x10,%esp
   
}
   13208:	90                   	nop
   13209:	c9                   	leave  
   1320a:	c3                   	ret    

0001320b <task_time_tick>:

// 检查当前任务的时间片是否用完，若用完强制切换到下一任务
void task_time_tick() {
   1320b:	55                   	push   %ebp
   1320c:	89 e5                	mov    %esp,%ebp
   1320e:	83 ec 28             	sub    $0x28,%esp
    task_t* curr = task_current();
   13211:	e8 8b fe ff ff       	call   130a1 <task_current>
   13216:	89 45 f0             	mov    %eax,-0x10(%ebp)

    int slice = --curr->slice_ticks;
   13219:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1321c:	8b 40 30             	mov    0x30(%eax),%eax
   1321f:	8d 50 ff             	lea    -0x1(%eax),%edx
   13222:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13225:	89 50 30             	mov    %edx,0x30(%eax)
   13228:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1322b:	8b 40 30             	mov    0x30(%eax),%eax
   1322e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if( slice == 0 && &g_task_manager.ready_list.count > 0) {
   13231:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13235:	75 2d                	jne    13264 <task_time_tick+0x59>
        curr->slice_ticks = curr->time_ticks;
   13237:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1323a:	8b 50 34             	mov    0x34(%eax),%edx
   1323d:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13240:	89 50 30             	mov    %edx,0x30(%eax)

        task_set_block(curr);
   13243:	83 ec 0c             	sub    $0xc,%esp
   13246:	ff 75 f0             	pushl  -0x10(%ebp)
   13249:	e8 92 fe ff ff       	call   130e0 <task_set_block>
   1324e:	83 c4 10             	add    $0x10,%esp
        task_set_ready(curr);
   13251:	83 ec 0c             	sub    $0xc,%esp
   13254:	ff 75 f0             	pushl  -0x10(%ebp)
   13257:	e8 4f fe ff ff       	call   130ab <task_set_ready>
   1325c:	83 c4 10             	add    $0x10,%esp

        task_dispatch();
   1325f:	e8 4b ff ff ff       	call   131af <task_dispatch>
    }

    list_node_t* sleep_lists_curr = list_first(&g_task_manager.sleep_list);
   13264:	83 ec 0c             	sub    $0xc,%esp
   13267:	68 10 20 03 00       	push   $0x32010
   1326c:	e8 ef f9 ff ff       	call   12c60 <list_first>
   13271:	83 c4 10             	add    $0x10,%esp
   13274:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (sleep_lists_curr) {
   13277:	eb 62                	jmp    132db <task_time_tick+0xd0>
        list_node_t * next = list_node_next(sleep_lists_curr);
   13279:	83 ec 0c             	sub    $0xc,%esp
   1327c:	ff 75 f4             	pushl  -0xc(%ebp)
   1327f:	e8 c6 f9 ff ff       	call   12c4a <list_node_next>
   13284:	83 c4 10             	add    $0x10,%esp
   13287:	89 45 e8             	mov    %eax,-0x18(%ebp)
        task_t* task = list_node_parent(sleep_lists_curr, task_t, run_node);
   1328a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   1328e:	74 08                	je     13298 <task_time_tick+0x8d>
   13290:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13293:	83 e8 3c             	sub    $0x3c,%eax
   13296:	eb 05                	jmp    1329d <task_time_tick+0x92>
   13298:	b8 00 00 00 00       	mov    $0x0,%eax
   1329d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        
        if(--task->sleep_ticks == 0) {
   132a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   132a3:	8b 40 38             	mov    0x38(%eax),%eax
   132a6:	8d 50 ff             	lea    -0x1(%eax),%edx
   132a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   132ac:	89 50 38             	mov    %edx,0x38(%eax)
   132af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   132b2:	8b 40 38             	mov    0x38(%eax),%eax
   132b5:	85 c0                	test   %eax,%eax
   132b7:	75 1c                	jne    132d5 <task_time_tick+0xca>
            task_set_wakeup(task);
   132b9:	83 ec 0c             	sub    $0xc,%esp
   132bc:	ff 75 e4             	pushl  -0x1c(%ebp)
   132bf:	e8 b8 00 00 00       	call   1337c <task_set_wakeup>
   132c4:	83 c4 10             	add    $0x10,%esp
            task_set_ready(task);
   132c7:	83 ec 0c             	sub    $0xc,%esp
   132ca:	ff 75 e4             	pushl  -0x1c(%ebp)
   132cd:	e8 d9 fd ff ff       	call   130ab <task_set_ready>
   132d2:	83 c4 10             	add    $0x10,%esp
        }
        sleep_lists_curr = next;
   132d5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   132d8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    while (sleep_lists_curr) {
   132db:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
   132df:	75 98                	jne    13279 <task_time_tick+0x6e>
    }

    task_dispatch();
   132e1:	e8 c9 fe ff ff       	call   131af <task_dispatch>
}
   132e6:	90                   	nop
   132e7:	c9                   	leave  
   132e8:	c3                   	ret    

000132e9 <sys_sleep>:



void sys_sleep(uint32_t ms) {
   132e9:	55                   	push   %ebp
   132ea:	89 e5                	mov    %esp,%ebp
   132ec:	83 ec 18             	sub    $0x18,%esp
    irq_state_t state = irq_enter_proection();
   132ef:	e8 27 df ff ff       	call   1121b <irq_enter_proection>
   132f4:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t* curr = task_current();
   132f7:	e8 a5 fd ff ff       	call   130a1 <task_current>
   132fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
    task_set_block(curr);
   132ff:	83 ec 0c             	sub    $0xc,%esp
   13302:	ff 75 f0             	pushl  -0x10(%ebp)
   13305:	e8 d6 fd ff ff       	call   130e0 <task_set_block>
   1330a:	83 c4 10             	add    $0x10,%esp
    task_set_sleep(curr, ms / OS_TICK_MS);
   1330d:	8b 45 08             	mov    0x8(%ebp),%eax
   13310:	ba cd cc cc cc       	mov    $0xcccccccd,%edx
   13315:	f7 e2                	mul    %edx
   13317:	89 d0                	mov    %edx,%eax
   13319:	c1 e8 03             	shr    $0x3,%eax
   1331c:	83 ec 08             	sub    $0x8,%esp
   1331f:	50                   	push   %eax
   13320:	ff 75 f0             	pushl  -0x10(%ebp)
   13323:	e8 19 00 00 00       	call   13341 <task_set_sleep>
   13328:	83 c4 10             	add    $0x10,%esp

    task_dispatch();
   1332b:	e8 7f fe ff ff       	call   131af <task_dispatch>

    irq_leave_proection(state);
   13330:	83 ec 0c             	sub    $0xc,%esp
   13333:	ff 75 f4             	pushl  -0xc(%ebp)
   13336:	e8 f8 de ff ff       	call   11233 <irq_leave_proection>
   1333b:	83 c4 10             	add    $0x10,%esp
}
   1333e:	90                   	nop
   1333f:	c9                   	leave  
   13340:	c3                   	ret    

00013341 <task_set_sleep>:

void task_set_sleep(task_t* task, uint32_t ticks) {
   13341:	55                   	push   %ebp
   13342:	89 e5                	mov    %esp,%ebp
   13344:	83 ec 08             	sub    $0x8,%esp
    if(ticks <= 0) return;
   13347:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
   1334b:	74 2c                	je     13379 <task_set_sleep+0x38>
    task->sleep_ticks = ticks;
   1334d:	8b 55 0c             	mov    0xc(%ebp),%edx
   13350:	8b 45 08             	mov    0x8(%ebp),%eax
   13353:	89 50 38             	mov    %edx,0x38(%eax)
    task->state = TASK_SLEEP;
   13356:	8b 45 08             	mov    0x8(%ebp),%eax
   13359:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
    list_insert_last(&g_task_manager.sleep_list, 
   13360:	8b 45 08             	mov    0x8(%ebp),%eax
   13363:	83 c0 3c             	add    $0x3c,%eax
   13366:	83 ec 08             	sub    $0x8,%esp
   13369:	50                   	push   %eax
   1336a:	68 10 20 03 00       	push   $0x32010
   1336f:	e8 a3 e6 ff ff       	call   11a17 <list_insert_last>
   13374:	83 c4 10             	add    $0x10,%esp
   13377:	eb 01                	jmp    1337a <task_set_sleep+0x39>
    if(ticks <= 0) return;
   13379:	90                   	nop
        &task->run_node);
}
   1337a:	c9                   	leave  
   1337b:	c3                   	ret    

0001337c <task_set_wakeup>:

void task_set_wakeup(task_t* task) {
   1337c:	55                   	push   %ebp
   1337d:	89 e5                	mov    %esp,%ebp
   1337f:	83 ec 08             	sub    $0x8,%esp
    list_delete(&g_task_manager.sleep_list, 
   13382:	8b 45 08             	mov    0x8(%ebp),%eax
   13385:	83 c0 3c             	add    $0x3c,%eax
   13388:	83 ec 08             	sub    $0x8,%esp
   1338b:	50                   	push   %eax
   1338c:	68 10 20 03 00       	push   $0x32010
   13391:	e8 5e e7 ff ff       	call   11af4 <list_delete>
   13396:	83 c4 10             	add    $0x10,%esp
        &task->run_node);
}
   13399:	90                   	nop
   1339a:	c9                   	leave  
   1339b:	c3                   	ret    

0001339c <sys_getpid>:

int sys_getpid () {
   1339c:	55                   	push   %ebp
   1339d:	89 e5                	mov    %esp,%ebp
   1339f:	83 ec 10             	sub    $0x10,%esp

    task_t* curr = task_current();
   133a2:	e8 fa fc ff ff       	call   130a1 <task_current>
   133a7:	89 45 fc             	mov    %eax,-0x4(%ebp)

    return curr->pid;
   133aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
   133ad:	8b 40 28             	mov    0x28(%eax),%eax
}
   133b0:	c9                   	leave  
   133b1:	c3                   	ret    

000133b2 <alloc_task>:


static task_t* alloc_task() {
   133b2:	55                   	push   %ebp
   133b3:	89 e5                	mov    %esp,%ebp
   133b5:	83 ec 18             	sub    $0x18,%esp
    task_t* task = (task_t*)0;
   133b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    mutex_lock(&task_table_mutex);
   133bf:	83 ec 0c             	sub    $0xc,%esp
   133c2:	68 c0 a1 03 00       	push   $0x3a1c0
   133c7:	e8 db f4 ff ff       	call   128a7 <mutex_lock>
   133cc:	83 c4 10             	add    $0x10,%esp
    for(int i=0; i<128; i++) {
   133cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   133d6:	eb 2b                	jmp    13403 <alloc_task+0x51>
        task_t* curr = g_task_table + i;
   133d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
   133db:	89 d0                	mov    %edx,%eax
   133dd:	01 c0                	add    %eax,%eax
   133df:	01 d0                	add    %edx,%eax
   133e1:	c1 e0 06             	shl    $0x6,%eax
   133e4:	05 c0 41 03 00       	add    $0x341c0,%eax
   133e9:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(curr->name[0] == '\0') {
   133ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
   133ef:	0f b6 40 08          	movzbl 0x8(%eax),%eax
   133f3:	84 c0                	test   %al,%al
   133f5:	75 08                	jne    133ff <alloc_task+0x4d>
            task = curr;
   133f7:	8b 45 ec             	mov    -0x14(%ebp),%eax
   133fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
            break;
   133fd:	eb 0a                	jmp    13409 <alloc_task+0x57>
    for(int i=0; i<128; i++) {
   133ff:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   13403:	83 7d f0 7f          	cmpl   $0x7f,-0x10(%ebp)
   13407:	7e cf                	jle    133d8 <alloc_task+0x26>
        }
    }
    mutex_unlock(&task_table_mutex);
   13409:	83 ec 0c             	sub    $0xc,%esp
   1340c:	68 c0 a1 03 00       	push   $0x3a1c0
   13411:	e8 25 f5 ff ff       	call   1293b <mutex_unlock>
   13416:	83 c4 10             	add    $0x10,%esp
    return task;
   13419:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
   1341c:	c9                   	leave  
   1341d:	c3                   	ret    

0001341e <free_task>:

static void free_task(task_t* task) {
   1341e:	55                   	push   %ebp
   1341f:	89 e5                	mov    %esp,%ebp
   13421:	83 ec 08             	sub    $0x8,%esp
    mutex_lock(&task_table_mutex);
   13424:	83 ec 0c             	sub    $0xc,%esp
   13427:	68 c0 a1 03 00       	push   $0x3a1c0
   1342c:	e8 76 f4 ff ff       	call   128a7 <mutex_lock>
   13431:	83 c4 10             	add    $0x10,%esp
    task->name[0] = '\0';
   13434:	8b 45 08             	mov    0x8(%ebp),%eax
   13437:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    mutex_unlock(&task_table_mutex);
   1343b:	83 ec 0c             	sub    $0xc,%esp
   1343e:	68 c0 a1 03 00       	push   $0x3a1c0
   13443:	e8 f3 f4 ff ff       	call   1293b <mutex_unlock>
   13448:	83 c4 10             	add    $0x10,%esp
}
   1344b:	90                   	nop
   1344c:	c9                   	leave  
   1344d:	c3                   	ret    

0001344e <task_uninit>:

static void task_uninit(task_t* task) {
   1344e:	55                   	push   %ebp
   1344f:	89 e5                	mov    %esp,%ebp
   13451:	83 ec 08             	sub    $0x8,%esp
    if(task->tss_sel) {
   13454:	8b 45 08             	mov    0x8(%ebp),%eax
   13457:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   1345d:	85 c0                	test   %eax,%eax
   1345f:	74 15                	je     13476 <task_uninit+0x28>
        gdt_free_sel(task->tss_sel);
   13461:	8b 45 08             	mov    0x8(%ebp),%eax
   13464:	8b 80 bc 00 00 00    	mov    0xbc(%eax),%eax
   1346a:	83 ec 0c             	sub    $0xc,%esp
   1346d:	50                   	push   %eax
   1346e:	e8 14 d3 ff ff       	call   10787 <gdt_free_sel>
   13473:	83 c4 10             	add    $0x10,%esp
    }
    if(task->tss.esp0) {
   13476:	8b 45 08             	mov    0x8(%ebp),%eax
   13479:	8b 40 58             	mov    0x58(%eax),%eax
   1347c:	85 c0                	test   %eax,%eax
   1347e:	74 1a                	je     1349a <task_uninit+0x4c>
        memory_free_page(task->tss.esp - MEM_PAGE_SIZE);
   13480:	8b 45 08             	mov    0x8(%ebp),%eax
   13483:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
   13489:	2d 00 10 00 00       	sub    $0x1000,%eax
   1348e:	83 ec 0c             	sub    $0xc,%esp
   13491:	50                   	push   %eax
   13492:	e8 45 f0 ff ff       	call   124dc <memory_free_page>
   13497:	83 c4 10             	add    $0x10,%esp
    }
    if(task->tss.cr3) {
   1349a:	8b 45 08             	mov    0x8(%ebp),%eax
   1349d:	8b 40 70             	mov    0x70(%eax),%eax
   134a0:	85 c0                	test   %eax,%eax
   134a2:	74 12                	je     134b6 <task_uninit+0x68>
        memory_destory_uvm(task->tss.cr3);
   134a4:	8b 45 08             	mov    0x8(%ebp),%eax
   134a7:	8b 40 70             	mov    0x70(%eax),%eax
   134aa:	83 ec 0c             	sub    $0xc,%esp
   134ad:	50                   	push   %eax
   134ae:	e8 fc f0 ff ff       	call   125af <memory_destory_uvm>
   134b3:	83 c4 10             	add    $0x10,%esp
    }

    k_memset(task, 0, sizeof(task_t));
   134b6:	83 ec 04             	sub    $0x4,%esp
   134b9:	68 c0 00 00 00       	push   $0xc0
   134be:	6a 00                	push   $0x0
   134c0:	ff 75 08             	pushl  0x8(%ebp)
   134c3:	e8 ef e1 ff ff       	call   116b7 <k_memset>
   134c8:	83 c4 10             	add    $0x10,%esp
}
   134cb:	90                   	nop
   134cc:	c9                   	leave  
   134cd:	c3                   	ret    

000134ce <sys_fork>:


int sys_fork() {
   134ce:	55                   	push   %ebp
   134cf:	89 e5                	mov    %esp,%ebp
   134d1:	83 ec 28             	sub    $0x28,%esp
    task_t* parent_task = task_current();
   134d4:	e8 c8 fb ff ff       	call   130a1 <task_current>
   134d9:	89 45 f4             	mov    %eax,-0xc(%ebp)

    task_t* child_task = alloc_task();
   134dc:	e8 d1 fe ff ff       	call   133b2 <alloc_task>
   134e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (child_task == (task_t*)0) goto fork_failed;
   134e4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   134e8:	0f 84 2a 01 00 00    	je     13618 <sys_fork+0x14a>


    syscall_frame_t* frame = (syscall_frame_t*)( parent_task->tss.esp0 
   134ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
   134f1:	8b 40 58             	mov    0x58(%eax),%eax
        - sizeof(syscall_frame_t));
   134f4:	83 e8 58             	sub    $0x58,%eax
    syscall_frame_t* frame = (syscall_frame_t*)( parent_task->tss.esp0 
   134f7:	89 45 ec             	mov    %eax,-0x14(%ebp)


    int err = task_init(child_task, parent_task->name, 0, frame->eip, 
        frame->esp + sizeof(uint32_t) * SYSCALL_PARAM_COUNT );
   134fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
   134fd:	8b 40 50             	mov    0x50(%eax),%eax
   13500:	8d 50 14             	lea    0x14(%eax),%edx
    int err = task_init(child_task, parent_task->name, 0, frame->eip, 
   13503:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13506:	8b 40 34             	mov    0x34(%eax),%eax
   13509:	89 c1                	mov    %eax,%ecx
   1350b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1350e:	83 c0 08             	add    $0x8,%eax
   13511:	83 ec 0c             	sub    $0xc,%esp
   13514:	52                   	push   %edx
   13515:	51                   	push   %ecx
   13516:	6a 00                	push   $0x0
   13518:	50                   	push   %eax
   13519:	ff 75 f0             	pushl  -0x10(%ebp)
   1351c:	e8 d4 f8 ff ff       	call   12df5 <task_init>
   13521:	83 c4 20             	add    $0x20,%esp
   13524:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (err < 0) goto fork_failed;
   13527:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   1352b:	0f 88 ea 00 00 00    	js     1361b <sys_fork+0x14d>

    tss_t* tss = &child_task->tss;
   13531:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13534:	83 c0 54             	add    $0x54,%eax
   13537:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    tss->eax = 0;                       // 子进程返回0
   1353a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1353d:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
    tss->ebx = frame->ebx;
   13544:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13547:	8b 50 24             	mov    0x24(%eax),%edx
   1354a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1354d:	89 50 34             	mov    %edx,0x34(%eax)
    tss->ecx = frame->ecx;
   13550:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13553:	8b 50 2c             	mov    0x2c(%eax),%edx
   13556:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13559:	89 50 2c             	mov    %edx,0x2c(%eax)
    tss->edx = frame->edx;
   1355c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1355f:	8b 50 28             	mov    0x28(%eax),%edx
   13562:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13565:	89 50 30             	mov    %edx,0x30(%eax)
    tss->esi = frame->esi;
   13568:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1356b:	8b 50 18             	mov    0x18(%eax),%edx
   1356e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13571:	89 50 40             	mov    %edx,0x40(%eax)
    tss->edi = frame->edi;
   13574:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13577:	8b 50 14             	mov    0x14(%eax),%edx
   1357a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   1357d:	89 50 44             	mov    %edx,0x44(%eax)
    tss->ebp = frame->ebp;
   13580:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13583:	8b 50 1c             	mov    0x1c(%eax),%edx
   13586:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13589:	89 50 3c             	mov    %edx,0x3c(%eax)

    tss->cs  = frame->cs;
   1358c:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1358f:	8b 40 38             	mov    0x38(%eax),%eax
   13592:	89 c2                	mov    %eax,%edx
   13594:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13597:	89 50 4c             	mov    %edx,0x4c(%eax)
    tss->ds  = frame->ds;
   1359a:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1359d:	8b 40 10             	mov    0x10(%eax),%eax
   135a0:	89 c2                	mov    %eax,%edx
   135a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   135a5:	89 50 54             	mov    %edx,0x54(%eax)
    tss->es  = frame->es;
   135a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
   135ab:	8b 40 0c             	mov    0xc(%eax),%eax
   135ae:	89 c2                	mov    %eax,%edx
   135b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   135b3:	89 50 48             	mov    %edx,0x48(%eax)
    tss->fs  = frame->fs;
   135b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
   135b9:	8b 40 08             	mov    0x8(%eax),%eax
   135bc:	89 c2                	mov    %eax,%edx
   135be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   135c1:	89 50 58             	mov    %edx,0x58(%eax)
    tss->gs  = frame->gs;
   135c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
   135c7:	8b 40 04             	mov    0x4(%eax),%eax
   135ca:	89 c2                	mov    %eax,%edx
   135cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   135cf:	89 50 5c             	mov    %edx,0x5c(%eax)
    tss->eflags = frame->eflags;
   135d2:	8b 45 ec             	mov    -0x14(%ebp),%eax
   135d5:	8b 00                	mov    (%eax),%eax
   135d7:	89 c2                	mov    %eax,%edx
   135d9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   135dc:	89 50 24             	mov    %edx,0x24(%eax)
    
    child_task->parent = parent_task;
   135df:	8b 45 f0             	mov    -0x10(%ebp),%eax
   135e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
   135e5:	89 50 2c             	mov    %edx,0x2c(%eax)

    if( (tss->cr3 = memory_copy_uvm(parent_task->tss.cr3) ) < 0) {
   135e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
   135eb:	8b 40 70             	mov    0x70(%eax),%eax
   135ee:	83 ec 0c             	sub    $0xc,%esp
   135f1:	50                   	push   %eax
   135f2:	e8 9f f0 ff ff       	call   12696 <memory_copy_uvm>
   135f7:	83 c4 10             	add    $0x10,%esp
   135fa:	89 c2                	mov    %eax,%edx
   135fc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   135ff:	89 50 1c             	mov    %edx,0x1c(%eax)
        goto fork_failed;
    }

    // tss->cr3 = parent_task->tss.cr3;
    task_start(child_task);
   13602:	83 ec 0c             	sub    $0xc,%esp
   13605:	ff 75 f0             	pushl  -0x10(%ebp)
   13608:	e8 cd f8 ff ff       	call   12eda <task_start>
   1360d:	83 c4 10             	add    $0x10,%esp
    return child_task->pid;
   13610:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13613:	8b 40 28             	mov    0x28(%eax),%eax
   13616:	eb 2b                	jmp    13643 <sys_fork+0x175>
    if (child_task == (task_t*)0) goto fork_failed;
   13618:	90                   	nop
   13619:	eb 01                	jmp    1361c <sys_fork+0x14e>
    if (err < 0) goto fork_failed;
   1361b:	90                   	nop

fork_failed:
    if(child_task) {
   1361c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13620:	74 1c                	je     1363e <sys_fork+0x170>
        task_uninit(child_task);
   13622:	83 ec 0c             	sub    $0xc,%esp
   13625:	ff 75 f0             	pushl  -0x10(%ebp)
   13628:	e8 21 fe ff ff       	call   1344e <task_uninit>
   1362d:	83 c4 10             	add    $0x10,%esp
        free_task(child_task);
   13630:	83 ec 0c             	sub    $0xc,%esp
   13633:	ff 75 f0             	pushl  -0x10(%ebp)
   13636:	e8 e3 fd ff ff       	call   1341e <free_task>
   1363b:	83 c4 10             	add    $0x10,%esp
    }
    return -1;
   1363e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
   13643:	c9                   	leave  
   13644:	c3                   	ret    

00013645 <load_phdr>:



static int load_phdr(int file, Elf32_Phdr * phdr, uint32_t page_dir) {
   13645:	55                   	push   %ebp
   13646:	89 e5                	mov    %esp,%ebp
   13648:	83 ec 28             	sub    $0x28,%esp

    int err = memory_alloc_for_page_dir(page_dir, phdr->p_vaddr, phdr->p_memsz, PTE_P | PTE_U | PTE_W);
   1364b:	8b 45 0c             	mov    0xc(%ebp),%eax
   1364e:	8b 50 14             	mov    0x14(%eax),%edx
   13651:	8b 45 0c             	mov    0xc(%ebp),%eax
   13654:	8b 40 08             	mov    0x8(%eax),%eax
   13657:	6a 07                	push   $0x7
   13659:	52                   	push   %edx
   1365a:	50                   	push   %eax
   1365b:	ff 75 10             	pushl  0x10(%ebp)
   1365e:	e8 39 ed ff ff       	call   1239c <memory_alloc_for_page_dir>
   13663:	83 c4 10             	add    $0x10,%esp
   13666:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (err < 0) {
   13669:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   1366d:	79 1a                	jns    13689 <load_phdr+0x44>
        klog("no memory");
   1366f:	83 ec 0c             	sub    $0xc,%esp
   13672:	68 c7 3f 01 00       	push   $0x13fc7
   13677:	e8 d6 e5 ff ff       	call   11c52 <klog>
   1367c:	83 c4 10             	add    $0x10,%esp
        return -1;
   1367f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13684:	e9 b8 00 00 00       	jmp    13741 <load_phdr+0xfc>
    }

    if (sys_lseek(file, phdr->p_offset, 0) < 0) {
   13689:	8b 45 0c             	mov    0xc(%ebp),%eax
   1368c:	8b 40 04             	mov    0x4(%eax),%eax
   1368f:	83 ec 04             	sub    $0x4,%esp
   13692:	6a 00                	push   $0x0
   13694:	50                   	push   %eax
   13695:	ff 75 08             	pushl  0x8(%ebp)
   13698:	e8 03 cf ff ff       	call   105a0 <sys_lseek>
   1369d:	83 c4 10             	add    $0x10,%esp
   136a0:	85 c0                	test   %eax,%eax
   136a2:	79 1a                	jns    136be <load_phdr+0x79>
        klog("read file failed");
   136a4:	83 ec 0c             	sub    $0xc,%esp
   136a7:	68 d1 3f 01 00       	push   $0x13fd1
   136ac:	e8 a1 e5 ff ff       	call   11c52 <klog>
   136b1:	83 c4 10             	add    $0x10,%esp
        return -1;
   136b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   136b9:	e9 83 00 00 00       	jmp    13741 <load_phdr+0xfc>
    }

    uint32_t vaddr = phdr->p_vaddr;
   136be:	8b 45 0c             	mov    0xc(%ebp),%eax
   136c1:	8b 40 08             	mov    0x8(%eax),%eax
   136c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
    uint32_t size = phdr->p_filesz;
   136c7:	8b 45 0c             	mov    0xc(%ebp),%eax
   136ca:	8b 40 10             	mov    0x10(%eax),%eax
   136cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    while (size > 0) {
   136d0:	eb 64                	jmp    13736 <load_phdr+0xf1>
        int curr_size = (size > MEM_PAGE_SIZE) ? MEM_PAGE_SIZE : size;
   136d2:	b8 00 10 00 00       	mov    $0x1000,%eax
   136d7:	81 7d f0 00 10 00 00 	cmpl   $0x1000,-0x10(%ebp)
   136de:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
   136e2:	89 45 e8             	mov    %eax,-0x18(%ebp)

        uint32_t paddr = memory_get_paddr(page_dir, vaddr);
   136e5:	83 ec 08             	sub    $0x8,%esp
   136e8:	ff 75 f4             	pushl  -0xc(%ebp)
   136eb:	ff 75 10             	pushl  0x10(%ebp)
   136ee:	e8 76 ee ff ff       	call   12569 <memory_get_paddr>
   136f3:	83 c4 10             	add    $0x10,%esp
   136f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if (sys_read(file, (char *)paddr, curr_size) <  curr_size) {
   136f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   136fc:	83 ec 04             	sub    $0x4,%esp
   136ff:	ff 75 e8             	pushl  -0x18(%ebp)
   13702:	50                   	push   %eax
   13703:	ff 75 08             	pushl  0x8(%ebp)
   13706:	e8 51 ce ff ff       	call   1055c <sys_read>
   1370b:	83 c4 10             	add    $0x10,%esp
   1370e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
   13711:	7e 17                	jle    1372a <load_phdr+0xe5>
            klog("read file failed");
   13713:	83 ec 0c             	sub    $0xc,%esp
   13716:	68 d1 3f 01 00       	push   $0x13fd1
   1371b:	e8 32 e5 ff ff       	call   11c52 <klog>
   13720:	83 c4 10             	add    $0x10,%esp
            return -1;
   13723:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   13728:	eb 17                	jmp    13741 <load_phdr+0xfc>
        }

        size -= curr_size;
   1372a:	8b 45 e8             	mov    -0x18(%ebp),%eax
   1372d:	29 45 f0             	sub    %eax,-0x10(%ebp)
        vaddr += curr_size;
   13730:	8b 45 e8             	mov    -0x18(%ebp),%eax
   13733:	01 45 f4             	add    %eax,-0xc(%ebp)
    while (size > 0) {
   13736:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1373a:	75 96                	jne    136d2 <load_phdr+0x8d>
    }

    return 0;
   1373c:	b8 00 00 00 00       	mov    $0x0,%eax
}
   13741:	c9                   	leave  
   13742:	c3                   	ret    

00013743 <load_elf_file>:

static uint32_t load_elf_file(task_t* task, const char* name, uint32_t page_dir) {
   13743:	55                   	push   %ebp
   13744:	89 e5                	mov    %esp,%ebp
   13746:	83 ec 78             	sub    $0x78,%esp
    Elf32_Ehdr elf_hdr;

    Elf32_Phdr elf_phdr;

    int file = sys_open(name, 0);
   13749:	83 ec 08             	sub    $0x8,%esp
   1374c:	6a 00                	push   $0x0
   1374e:	ff 75 0c             	pushl  0xc(%ebp)
   13751:	e8 cd cd ff ff       	call   10523 <sys_open>
   13756:	83 c4 10             	add    $0x10,%esp
   13759:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if ( file < 0 ) {
   1375c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   13760:	79 18                	jns    1377a <load_elf_file+0x37>
        klog("open failed: %s", name);
   13762:	83 ec 08             	sub    $0x8,%esp
   13765:	ff 75 0c             	pushl  0xc(%ebp)
   13768:	68 e2 3f 01 00       	push   $0x13fe2
   1376d:	e8 e0 e4 ff ff       	call   11c52 <klog>
   13772:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   13775:	e9 0c 01 00 00       	jmp    13886 <load_elf_file+0x143>
    }

    int cnt = sys_read(file, (char*)&elf_hdr, sizeof(elf_hdr));
   1377a:	83 ec 04             	sub    $0x4,%esp
   1377d:	6a 34                	push   $0x34
   1377f:	8d 45 b0             	lea    -0x50(%ebp),%eax
   13782:	50                   	push   %eax
   13783:	ff 75 f0             	pushl  -0x10(%ebp)
   13786:	e8 d1 cd ff ff       	call   1055c <sys_read>
   1378b:	83 c4 10             	add    $0x10,%esp
   1378e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if ( cnt < sizeof(Elf32_Ehdr) ) {
   13791:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13794:	83 f8 33             	cmp    $0x33,%eax
   13797:	77 18                	ja     137b1 <load_elf_file+0x6e>
        klog("elf hdr too small. size=%s", cnt);
   13799:	83 ec 08             	sub    $0x8,%esp
   1379c:	ff 75 ec             	pushl  -0x14(%ebp)
   1379f:	68 f2 3f 01 00       	push   $0x13ff2
   137a4:	e8 a9 e4 ff ff       	call   11c52 <klog>
   137a9:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   137ac:	e9 d5 00 00 00       	jmp    13886 <load_elf_file+0x143>
    }

    if ( (elf_hdr.e_ident[0] != ELF_MAGIC) || (elf_hdr.e_ident[1] != 'E')
   137b1:	0f b6 45 b0          	movzbl -0x50(%ebp),%eax
   137b5:	3c 7f                	cmp    $0x7f,%al
   137b7:	75 18                	jne    137d1 <load_elf_file+0x8e>
   137b9:	0f b6 45 b1          	movzbl -0x4f(%ebp),%eax
   137bd:	3c 45                	cmp    $0x45,%al
   137bf:	75 10                	jne    137d1 <load_elf_file+0x8e>
        || (elf_hdr.e_ident[2] != 'L') || (elf_hdr.e_ident[3] != 'F')) 
   137c1:	0f b6 45 b2          	movzbl -0x4e(%ebp),%eax
   137c5:	3c 4c                	cmp    $0x4c,%al
   137c7:	75 08                	jne    137d1 <load_elf_file+0x8e>
   137c9:	0f b6 45 b3          	movzbl -0x4d(%ebp),%eax
   137cd:	3c 46                	cmp    $0x46,%al
   137cf:	74 15                	je     137e6 <load_elf_file+0xa3>
    {
        klog("chekc elf ident failed");
   137d1:	83 ec 0c             	sub    $0xc,%esp
   137d4:	68 0d 40 01 00       	push   $0x1400d
   137d9:	e8 74 e4 ff ff       	call   11c52 <klog>
   137de:	83 c4 10             	add    $0x10,%esp
        goto load_failed;
   137e1:	e9 a0 00 00 00       	jmp    13886 <load_elf_file+0x143>
    }

    uint32_t e_phoff = elf_hdr.e_phoff;
   137e6:	8b 45 cc             	mov    -0x34(%ebp),%eax
   137e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
    for (int i=0; i < elf_hdr.e_phnum; i++) {
   137ec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
   137f3:	eb 6b                	jmp    13860 <load_elf_file+0x11d>
        if( sys_lseek(file, e_phoff, 0) < 0 ) {
   137f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
   137f8:	83 ec 04             	sub    $0x4,%esp
   137fb:	6a 00                	push   $0x0
   137fd:	50                   	push   %eax
   137fe:	ff 75 f0             	pushl  -0x10(%ebp)
   13801:	e8 9a cd ff ff       	call   105a0 <sys_lseek>
   13806:	83 c4 10             	add    $0x10,%esp
   13809:	85 c0                	test   %eax,%eax
   1380b:	78 72                	js     1387f <load_elf_file+0x13c>
            goto load_failed;
        }

        cnt = sys_read(file, (char *)&elf_phdr, sizeof(elf_phdr));
   1380d:	83 ec 04             	sub    $0x4,%esp
   13810:	6a 20                	push   $0x20
   13812:	8d 45 90             	lea    -0x70(%ebp),%eax
   13815:	50                   	push   %eax
   13816:	ff 75 f0             	pushl  -0x10(%ebp)
   13819:	e8 3e cd ff ff       	call   1055c <sys_read>
   1381e:	83 c4 10             	add    $0x10,%esp
   13821:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (cnt < sizeof(elf_phdr)) {
   13824:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13827:	83 f8 1f             	cmp    $0x1f,%eax
   1382a:	76 56                	jbe    13882 <load_elf_file+0x13f>
            goto load_failed;
        }

        if ((elf_phdr.p_type != PT_LOAD) || (elf_phdr.p_vaddr < MEMORY_TASK_BASE)) {
   1382c:	8b 45 90             	mov    -0x70(%ebp),%eax
   1382f:	83 f8 01             	cmp    $0x1,%eax
   13832:	75 27                	jne    1385b <load_elf_file+0x118>
   13834:	8b 45 98             	mov    -0x68(%ebp),%eax
   13837:	85 c0                	test   %eax,%eax
   13839:	79 20                	jns    1385b <load_elf_file+0x118>
           continue;
        }

        int err = load_phdr(file, &elf_phdr, page_dir);
   1383b:	83 ec 04             	sub    $0x4,%esp
   1383e:	ff 75 10             	pushl  0x10(%ebp)
   13841:	8d 45 90             	lea    -0x70(%ebp),%eax
   13844:	50                   	push   %eax
   13845:	ff 75 f0             	pushl  -0x10(%ebp)
   13848:	e8 f8 fd ff ff       	call   13645 <load_phdr>
   1384d:	83 c4 10             	add    $0x10,%esp
   13850:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (err < 0) {
   13853:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
   13857:	78 2c                	js     13885 <load_elf_file+0x142>
   13859:	eb 01                	jmp    1385c <load_elf_file+0x119>
           continue;
   1385b:	90                   	nop
    for (int i=0; i < elf_hdr.e_phnum; i++) {
   1385c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
   13860:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
   13864:	0f b7 c0             	movzwl %ax,%eax
   13867:	39 45 f4             	cmp    %eax,-0xc(%ebp)
   1386a:	7c 89                	jl     137f5 <load_elf_file+0xb2>
        //task->heap_start = elf_phdr.p_vaddr + elf_phdr.p_memsz;
        //task->heap_end = task->heap_start;

    }

    sys_close(file);
   1386c:	83 ec 0c             	sub    $0xc,%esp
   1386f:	ff 75 f0             	pushl  -0x10(%ebp)
   13872:	e8 48 cd ff ff       	call   105bf <sys_close>
   13877:	83 c4 10             	add    $0x10,%esp
    return elf_hdr.e_entry;
   1387a:	8b 45 c8             	mov    -0x38(%ebp),%eax
   1387d:	eb 20                	jmp    1389f <load_elf_file+0x15c>
            goto load_failed;
   1387f:	90                   	nop
   13880:	eb 04                	jmp    13886 <load_elf_file+0x143>
            goto load_failed;
   13882:	90                   	nop
   13883:	eb 01                	jmp    13886 <load_elf_file+0x143>
            goto load_failed;
   13885:	90                   	nop

load_failed:
    if (file) {
   13886:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
   1388a:	74 0e                	je     1389a <load_elf_file+0x157>
        sys_close(file);
   1388c:	83 ec 0c             	sub    $0xc,%esp
   1388f:	ff 75 f0             	pushl  -0x10(%ebp)
   13892:	e8 28 cd ff ff       	call   105bf <sys_close>
   13897:	83 c4 10             	add    $0x10,%esp
    }
return 0;
   1389a:	b8 00 00 00 00       	mov    $0x0,%eax
}
   1389f:	c9                   	leave  
   138a0:	c3                   	ret    

000138a1 <copy_args>:


static int copy_args (char * to, uint32_t page_dir, int argc, char **argv) {
   138a1:	55                   	push   %ebp
   138a2:	89 e5                	mov    %esp,%ebp
   138a4:	83 ec 38             	sub    $0x38,%esp
    task_args_t task_args;
    task_args.argc = argc;
   138a7:	8b 45 10             	mov    0x10(%ebp),%eax
   138aa:	89 45 d8             	mov    %eax,-0x28(%ebp)
    task_args.argv = (char **)(to + sizeof(task_args_t));
   138ad:	8b 45 08             	mov    0x8(%ebp),%eax
   138b0:	83 c0 0c             	add    $0xc,%eax
   138b3:	89 45 dc             	mov    %eax,-0x24(%ebp)

    char * dest_arg = to + sizeof(task_args_t) + sizeof(char *) * (argc + 1);   // 留出结束符
   138b6:	8b 45 10             	mov    0x10(%ebp),%eax
   138b9:	83 c0 04             	add    $0x4,%eax
   138bc:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   138c3:	8b 45 08             	mov    0x8(%ebp),%eax
   138c6:	01 d0                	add    %edx,%eax
   138c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    
    char ** dest_argv_tb = (char **)memory_get_paddr(page_dir, (uint32_t)(to + sizeof(task_args_t)));
   138cb:	8b 45 08             	mov    0x8(%ebp),%eax
   138ce:	83 c0 0c             	add    $0xc,%eax
   138d1:	83 ec 08             	sub    $0x8,%esp
   138d4:	50                   	push   %eax
   138d5:	ff 75 0c             	pushl  0xc(%ebp)
   138d8:	e8 8c ec ff ff       	call   12569 <memory_get_paddr>
   138dd:	83 c4 10             	add    $0x10,%esp
   138e0:	89 45 ec             	mov    %eax,-0x14(%ebp)

    for (int i = 0; i < argc; i++) {
   138e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
   138ea:	eb 60                	jmp    1394c <copy_args+0xab>
        char * from = argv[i];
   138ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
   138ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   138f6:	8b 45 14             	mov    0x14(%ebp),%eax
   138f9:	01 d0                	add    %edx,%eax
   138fb:	8b 00                	mov    (%eax),%eax
   138fd:	89 45 e8             	mov    %eax,-0x18(%ebp)

        int len = k_strlen(from) + 1;   // 包含结束符
   13900:	83 ec 0c             	sub    $0xc,%esp
   13903:	ff 75 e8             	pushl  -0x18(%ebp)
   13906:	e8 22 dd ff ff       	call   1162d <k_strlen>
   1390b:	83 c4 10             	add    $0x10,%esp
   1390e:	83 c0 01             	add    $0x1,%eax
   13911:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        int err = memory_copy_uvm_data((uint32_t)dest_arg, page_dir, (uint32_t)from, len);
   13914:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
   13917:	8b 55 e8             	mov    -0x18(%ebp),%edx
   1391a:	8b 45 f4             	mov    -0xc(%ebp),%eax
   1391d:	51                   	push   %ecx
   1391e:	52                   	push   %edx
   1391f:	ff 75 0c             	pushl  0xc(%ebp)
   13922:	50                   	push   %eax
   13923:	e8 c3 ee ff ff       	call   127eb <memory_copy_uvm_data>
   13928:	83 c4 10             	add    $0x10,%esp
   1392b:	89 45 e0             	mov    %eax,-0x20(%ebp)

        dest_argv_tb[i] = dest_arg;
   1392e:	8b 45 f0             	mov    -0x10(%ebp),%eax
   13931:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13938:	8b 45 ec             	mov    -0x14(%ebp),%eax
   1393b:	01 c2                	add    %eax,%edx
   1393d:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13940:	89 02                	mov    %eax,(%edx)
        dest_arg += len;
   13942:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13945:	01 45 f4             	add    %eax,-0xc(%ebp)
    for (int i = 0; i < argc; i++) {
   13948:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
   1394c:	8b 45 f0             	mov    -0x10(%ebp),%eax
   1394f:	3b 45 10             	cmp    0x10(%ebp),%eax
   13952:	7c 98                	jl     138ec <copy_args+0x4b>
    }
    if (argc) {
   13954:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
   13958:	74 15                	je     1396f <copy_args+0xce>
        dest_argv_tb[argc] = '\0';
   1395a:	8b 45 10             	mov    0x10(%ebp),%eax
   1395d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
   13964:	8b 45 ec             	mov    -0x14(%ebp),%eax
   13967:	01 d0                	add    %edx,%eax
   13969:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
     // 写入task_args
    return memory_copy_uvm_data((uint32_t)to, page_dir, (uint32_t)&task_args, sizeof(task_args_t));
   1396f:	8d 55 d4             	lea    -0x2c(%ebp),%edx
   13972:	8b 45 08             	mov    0x8(%ebp),%eax
   13975:	6a 0c                	push   $0xc
   13977:	52                   	push   %edx
   13978:	ff 75 0c             	pushl  0xc(%ebp)
   1397b:	50                   	push   %eax
   1397c:	e8 6a ee ff ff       	call   127eb <memory_copy_uvm_data>
   13981:	83 c4 10             	add    $0x10,%esp
}
   13984:	c9                   	leave  
   13985:	c3                   	ret    

00013986 <sys_execve>:

// 用当前进程运行新的代码
int sys_execve(char* name, char** argv, char** env) {
   13986:	55                   	push   %ebp
   13987:	89 e5                	mov    %esp,%ebp
   13989:	83 ec 38             	sub    $0x38,%esp
    task_t* curr_task = task_current();
   1398c:	e8 10 f7 ff ff       	call   130a1 <task_current>
   13991:	89 45 f4             	mov    %eax,-0xc(%ebp)

    k_strncpy(curr_task->name, get_file_name(name), TASK_NAME_SIZE);
   13994:	83 ec 0c             	sub    $0xc,%esp
   13997:	ff 75 08             	pushl  0x8(%ebp)
   1399a:	e8 17 db ff ff       	call   114b6 <get_file_name>
   1399f:	83 c4 10             	add    $0x10,%esp
   139a2:	89 c2                	mov    %eax,%edx
   139a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
   139a7:	83 c0 08             	add    $0x8,%eax
   139aa:	83 ec 04             	sub    $0x4,%esp
   139ad:	6a 20                	push   $0x20
   139af:	52                   	push   %edx
   139b0:	50                   	push   %eax
   139b1:	e8 8d db ff ff       	call   11543 <k_strncpy>
   139b6:	83 c4 10             	add    $0x10,%esp

    uint32_t old_page_dir = curr_task->tss.cr3;
   139b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
   139bc:	8b 40 70             	mov    0x70(%eax),%eax
   139bf:	89 45 f0             	mov    %eax,-0x10(%ebp)

    // 删除原来进程的页表
    uint32_t new_page_dir = memory_create_uvm();
   139c2:	e8 50 e9 ff ff       	call   12317 <memory_create_uvm>
   139c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(!new_page_dir) goto exec_failed;
   139ca:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   139ce:	0f 84 27 01 00 00    	je     13afb <sys_execve+0x175>

    // 根据elf文件找到运行地址
    uint32_t entry = load_elf_file(curr_task, name, new_page_dir);
   139d4:	83 ec 04             	sub    $0x4,%esp
   139d7:	ff 75 ec             	pushl  -0x14(%ebp)
   139da:	ff 75 08             	pushl  0x8(%ebp)
   139dd:	ff 75 f4             	pushl  -0xc(%ebp)
   139e0:	e8 5e fd ff ff       	call   13743 <load_elf_file>
   139e5:	83 c4 10             	add    $0x10,%esp
   139e8:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(entry == 0) goto exec_failed;
   139eb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
   139ef:	0f 84 09 01 00 00    	je     13afe <sys_execve+0x178>

    uint32_t stack_top = MEM_TASK_STACK_TOP - MEM_TASK_ARG_SIZE;
   139f5:	c7 45 e4 00 00 ff df 	movl   $0xdfff0000,-0x1c(%ebp)
    int err = memory_alloc_for_page_dir(
   139fc:	6a 07                	push   $0x7
   139fe:	68 00 40 1f 00       	push   $0x1f4000
   13a03:	68 00 c0 e0 df       	push   $0xdfe0c000
   13a08:	ff 75 ec             	pushl  -0x14(%ebp)
   13a0b:	e8 8c e9 ff ff       	call   1239c <memory_alloc_for_page_dir>
   13a10:	83 c4 10             	add    $0x10,%esp
   13a13:	89 45 e0             	mov    %eax,-0x20(%ebp)
        new_page_dir, MEM_TASK_STACK_TOP - MEM_TASK_STACK_SIZE,
        MEM_TASK_STACK_SIZE, PTE_P | PTE_U | PTE_W
    );
    if (err < 0) {
   13a16:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
   13a1a:	0f 88 e1 00 00 00    	js     13b01 <sys_execve+0x17b>
        goto exec_failed;
    }

    int argc = strings_count(argv);
   13a20:	83 ec 0c             	sub    $0xc,%esp
   13a23:	ff 75 0c             	pushl  0xc(%ebp)
   13a26:	e8 5e da ff ff       	call   11489 <strings_count>
   13a2b:	83 c4 10             	add    $0x10,%esp
   13a2e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    int err2 = copy_args((char* )stack_top, new_page_dir, argc, argv);
   13a31:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13a34:	ff 75 0c             	pushl  0xc(%ebp)
   13a37:	ff 75 dc             	pushl  -0x24(%ebp)
   13a3a:	ff 75 ec             	pushl  -0x14(%ebp)
   13a3d:	50                   	push   %eax
   13a3e:	e8 5e fe ff ff       	call   138a1 <copy_args>
   13a43:	83 c4 10             	add    $0x10,%esp
   13a46:	89 45 d8             	mov    %eax,-0x28(%ebp)
    if (err2 < 0) {
   13a49:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
   13a4d:	0f 88 b1 00 00 00    	js     13b04 <sys_execve+0x17e>
        goto exec_failed;
    }

    syscall_frame_t * frame = (syscall_frame_t *)(curr_task->tss.esp0 
   13a53:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13a56:	8b 40 58             	mov    0x58(%eax),%eax
        - sizeof(syscall_frame_t));
   13a59:	83 e8 58             	sub    $0x58,%eax
    syscall_frame_t * frame = (syscall_frame_t *)(curr_task->tss.esp0 
   13a5c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    frame->eip = entry;
   13a5f:	8b 55 e8             	mov    -0x18(%ebp),%edx
   13a62:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a65:	89 50 34             	mov    %edx,0x34(%eax)
    frame->eax = frame->ebx = frame->ecx = frame->edx = 0;
   13a68:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a6b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
   13a72:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a75:	8b 50 28             	mov    0x28(%eax),%edx
   13a78:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a7b:	89 50 2c             	mov    %edx,0x2c(%eax)
   13a7e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a81:	8b 50 2c             	mov    0x2c(%eax),%edx
   13a84:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a87:	89 50 24             	mov    %edx,0x24(%eax)
   13a8a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a8d:	8b 50 24             	mov    0x24(%eax),%edx
   13a90:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a93:	89 50 30             	mov    %edx,0x30(%eax)
    frame->esi = frame->edi = frame->ebp = 0;
   13a96:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13a99:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
   13aa0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13aa3:	8b 50 1c             	mov    0x1c(%eax),%edx
   13aa6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13aa9:	89 50 14             	mov    %edx,0x14(%eax)
   13aac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13aaf:	8b 50 14             	mov    0x14(%eax),%edx
   13ab2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13ab5:	89 50 18             	mov    %edx,0x18(%eax)
    frame->eflags = EFLAGES_DEFAULT| EFLAGS_IF;  // 段寄存器无需修改
   13ab8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13abb:	c7 00 02 02 00 00    	movl   $0x202,(%eax)

    frame->esp = stack_top - sizeof(uint32_t)*SYSCALL_PARAM_COUNT;
   13ac1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
   13ac4:	83 e8 14             	sub    $0x14,%eax
   13ac7:	89 c2                	mov    %eax,%edx
   13ac9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
   13acc:	89 50 50             	mov    %edx,0x50(%eax)

    curr_task->tss.cr3 = new_page_dir;          // 设置页表
   13acf:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13ad2:	8b 55 ec             	mov    -0x14(%ebp),%edx
   13ad5:	89 50 70             	mov    %edx,0x70(%eax)
    mmu_set_page_dir(new_page_dir);             // 跟新页表
   13ad8:	83 ec 0c             	sub    $0xc,%esp
   13adb:	ff 75 ec             	pushl  -0x14(%ebp)
   13ade:	e8 87 f1 ff ff       	call   12c6a <mmu_set_page_dir>
   13ae3:	83 c4 10             	add    $0x10,%esp

    memory_destory_uvm(old_page_dir);           // 删除之前的页表
   13ae6:	83 ec 0c             	sub    $0xc,%esp
   13ae9:	ff 75 f0             	pushl  -0x10(%ebp)
   13aec:	e8 be ea ff ff       	call   125af <memory_destory_uvm>
   13af1:	83 c4 10             	add    $0x10,%esp

    return 0;
   13af4:	b8 00 00 00 00       	mov    $0x0,%eax
   13af9:	eb 3a                	jmp    13b35 <sys_execve+0x1af>
    if(!new_page_dir) goto exec_failed;
   13afb:	90                   	nop
   13afc:	eb 07                	jmp    13b05 <sys_execve+0x17f>
    if(entry == 0) goto exec_failed;
   13afe:	90                   	nop
   13aff:	eb 04                	jmp    13b05 <sys_execve+0x17f>
        goto exec_failed;
   13b01:	90                   	nop
   13b02:	eb 01                	jmp    13b05 <sys_execve+0x17f>
        goto exec_failed;
   13b04:	90                   	nop
exec_failed:
    if(new_page_dir) {
   13b05:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
   13b09:	74 25                	je     13b30 <sys_execve+0x1aa>
        curr_task->tss.cr3 = old_page_dir;
   13b0b:	8b 45 f4             	mov    -0xc(%ebp),%eax
   13b0e:	8b 55 f0             	mov    -0x10(%ebp),%edx
   13b11:	89 50 70             	mov    %edx,0x70(%eax)
        mmu_set_page_dir(old_page_dir);
   13b14:	83 ec 0c             	sub    $0xc,%esp
   13b17:	ff 75 f0             	pushl  -0x10(%ebp)
   13b1a:	e8 4b f1 ff ff       	call   12c6a <mmu_set_page_dir>
   13b1f:	83 c4 10             	add    $0x10,%esp
        memory_destory_uvm(new_page_dir);
   13b22:	83 ec 0c             	sub    $0xc,%esp
   13b25:	ff 75 ec             	pushl  -0x14(%ebp)
   13b28:	e8 82 ea ff ff       	call   125af <memory_destory_uvm>
   13b2d:	83 c4 10             	add    $0x10,%esp
    }
return -1;
   13b30:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

}
   13b35:	c9                   	leave  
   13b36:	c3                   	ret    

Disassembly of section .first_task:

80000000 <first_task_entry>:
    .text
    .global first_task_entry
    .extern first_task_main
first_task_entry:
	mov %ss, %ax
80000000:	66 8c d0             	mov    %ss,%ax
    mov %ax, %ds
80000003:	8e d8                	mov    %eax,%ds
    mov %ax, %es
80000005:	8e c0                	mov    %eax,%es
    mov %ax, %fs
80000007:	8e e0                	mov    %eax,%fs
    mov %ax, %gs
80000009:	8e e8                	mov    %eax,%gs
8000000b:	e9 03 01 00 00       	jmp    80000113 <first_task_main>

80000010 <sys_call>:
} syscall_arg_t ;



static inline int 
sys_call (syscall_arg_t * args) {
80000010:	55                   	push   %ebp
80000011:	89 e5                	mov    %esp,%ebp
80000013:	57                   	push   %edi
80000014:	56                   	push   %esi
80000015:	53                   	push   %ebx
80000016:	83 ec 10             	sub    $0x10,%esp
    int ret;
	volatile uint32_t addr[] = {0,  SELECTOR_SYSCALL | 0};
80000019:	b8 00 00 00 00       	mov    $0x0,%eax
8000001e:	ba 18 00 00 00       	mov    $0x18,%edx
80000023:	89 45 e8             	mov    %eax,-0x18(%ebp)
80000026:	89 55 ec             	mov    %edx,-0x14(%ebp)
        "push %[arg1]\n\t"
        "push %[arg0]\n\t"
        "push %[id]\n\t"
        "lcalll *(%[a])"       
        :"=a"(ret)              //  output
        :[arg3]"r"(args->arg3), //  input
80000029:	8b 45 08             	mov    0x8(%ebp),%eax
8000002c:	8b 40 10             	mov    0x10(%eax),%eax
        [arg2]"r"(args->arg2), 
8000002f:	8b 55 08             	mov    0x8(%ebp),%edx
80000032:	8b 52 0c             	mov    0xc(%edx),%edx
        [arg1]"r"(args->arg1), 
80000035:	8b 4d 08             	mov    0x8(%ebp),%ecx
80000038:	8b 49 08             	mov    0x8(%ecx),%ecx
        [arg0]"r"(args->arg0), 
8000003b:	8b 5d 08             	mov    0x8(%ebp),%ebx
8000003e:	8b 5b 04             	mov    0x4(%ebx),%ebx
        [id]"r"(args->id), 
80000041:	8b 75 08             	mov    0x8(%ebp),%esi
80000044:	8b 36                	mov    (%esi),%esi
	__asm__ __volatile__(
80000046:	8d 7d e8             	lea    -0x18(%ebp),%edi
80000049:	50                   	push   %eax
8000004a:	52                   	push   %edx
8000004b:	51                   	push   %ecx
8000004c:	53                   	push   %ebx
8000004d:	56                   	push   %esi
8000004e:	ff 1f                	lcall  *(%edi)
80000050:	89 45 f0             	mov    %eax,-0x10(%ebp)
        [a]"r"(addr)
    );

    return ret;
80000053:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
80000056:	83 c4 10             	add    $0x10,%esp
80000059:	5b                   	pop    %ebx
8000005a:	5e                   	pop    %esi
8000005b:	5f                   	pop    %edi
8000005c:	5d                   	pop    %ebp
8000005d:	c3                   	ret    

8000005e <msleep>:


static inline void 
msleep(int ms) {
8000005e:	55                   	push   %ebp
8000005f:	89 e5                	mov    %esp,%ebp
80000061:	83 ec 20             	sub    $0x20,%esp
    if(ms <= 0) { return; }
80000064:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
80000068:	7e 1b                	jle    80000085 <msleep+0x27>
    syscall_arg_t args;
    args.id = SYS_sleep;
8000006a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    args.arg0 = ms;
80000071:	8b 45 08             	mov    0x8(%ebp),%eax
80000074:	89 45 f0             	mov    %eax,-0x10(%ebp)
    sys_call(&args);
80000077:	8d 45 ec             	lea    -0x14(%ebp),%eax
8000007a:	50                   	push   %eax
8000007b:	e8 90 ff ff ff       	call   80000010 <sys_call>
80000080:	83 c4 04             	add    $0x4,%esp
80000083:	eb 01                	jmp    80000086 <msleep+0x28>
    if(ms <= 0) { return; }
80000085:	90                   	nop
}
80000086:	c9                   	leave  
80000087:	c3                   	ret    

80000088 <getpid>:

static inline int
getpid() {
80000088:	55                   	push   %ebp
80000089:	89 e5                	mov    %esp,%ebp
8000008b:	83 ec 20             	sub    $0x20,%esp
    syscall_arg_t args;
    args.id = SYS_getpid;
8000008e:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
    return sys_call(&args);
80000095:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000098:	50                   	push   %eax
80000099:	e8 72 ff ff ff       	call   80000010 <sys_call>
8000009e:	83 c4 04             	add    $0x4,%esp
}
800000a1:	c9                   	leave  
800000a2:	c3                   	ret    

800000a3 <print_msg>:

static inline void 
print_msg (const char*fmt, int arg) {
800000a3:	55                   	push   %ebp
800000a4:	89 e5                	mov    %esp,%ebp
800000a6:	83 ec 20             	sub    $0x20,%esp
    syscall_arg_t args;
    args.id = SYS_print_msg;
800000a9:	c7 45 ec 02 00 00 00 	movl   $0x2,-0x14(%ebp)
    args.arg0 = (int)fmt;
800000b0:	8b 45 08             	mov    0x8(%ebp),%eax
800000b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = arg;
800000b6:	8b 45 0c             	mov    0xc(%ebp),%eax
800000b9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    sys_call(&args);
800000bc:	8d 45 ec             	lea    -0x14(%ebp),%eax
800000bf:	50                   	push   %eax
800000c0:	e8 4b ff ff ff       	call   80000010 <sys_call>
800000c5:	83 c4 04             	add    $0x4,%esp
}
800000c8:	90                   	nop
800000c9:	c9                   	leave  
800000ca:	c3                   	ret    

800000cb <fork>:

static inline int
fork() {
800000cb:	55                   	push   %ebp
800000cc:	89 e5                	mov    %esp,%ebp
800000ce:	83 ec 20             	sub    $0x20,%esp
    syscall_arg_t args;
    args.id = SYS_fork;
800000d1:	c7 45 ec 03 00 00 00 	movl   $0x3,-0x14(%ebp)
    return sys_call(&args);
800000d8:	8d 45 ec             	lea    -0x14(%ebp),%eax
800000db:	50                   	push   %eax
800000dc:	e8 2f ff ff ff       	call   80000010 <sys_call>
800000e1:	83 c4 04             	add    $0x4,%esp
}
800000e4:	c9                   	leave  
800000e5:	c3                   	ret    

800000e6 <execve>:

static inline int
execve(const char* name, char* const* argv, char* const * env ) {
800000e6:	55                   	push   %ebp
800000e7:	89 e5                	mov    %esp,%ebp
800000e9:	83 ec 20             	sub    $0x20,%esp
    syscall_arg_t args;
    args.id = SYS_execve;
800000ec:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)
    args.arg0 = (int)name;
800000f3:	8b 45 08             	mov    0x8(%ebp),%eax
800000f6:	89 45 f0             	mov    %eax,-0x10(%ebp)
    args.arg1 = (int)argv;
800000f9:	8b 45 0c             	mov    0xc(%ebp),%eax
800000fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    args.arg2 = (int)env;
800000ff:	8b 45 10             	mov    0x10(%ebp),%eax
80000102:	89 45 f8             	mov    %eax,-0x8(%ebp)
    return sys_call(&args);
80000105:	8d 45 ec             	lea    -0x14(%ebp),%eax
80000108:	50                   	push   %eax
80000109:	e8 02 ff ff ff       	call   80000010 <sys_call>
8000010e:	83 c4 04             	add    $0x4,%esp
}
80000111:	c9                   	leave  
80000112:	c3                   	ret    

80000113 <first_task_main>:
#include <applib/lib_syscall.h>


int first_task_main() {
80000113:	55                   	push   %ebp
80000114:	89 e5                	mov    %esp,%ebp
80000116:	83 ec 20             	sub    $0x20,%esp
    int count = 1;
80000119:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
    int pare_pid = getpid();
80000120:	e8 63 ff ff ff       	call   80000088 <getpid>
80000125:	89 45 f8             	mov    %eax,-0x8(%ebp)

    int pid = fork();
80000128:	e8 9e ff ff ff       	call   800000cb <fork>
8000012d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(pid < 0) {
80000130:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
80000134:	79 11                	jns    80000147 <first_task_main+0x34>
        print_msg("fork failed %d", 0);
80000136:	6a 00                	push   $0x0
80000138:	68 c7 01 00 80       	push   $0x800001c7
8000013d:	e8 61 ff ff ff       	call   800000a3 <print_msg>
80000142:	83 c4 08             	add    $0x8,%esp
80000145:	eb 71                	jmp    800001b8 <first_task_main+0xa5>

    } else if (pid == 0) {
80000147:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
8000014b:	75 44                	jne    80000191 <first_task_main+0x7e>
        count += 20;
8000014d:	83 45 fc 14          	addl   $0x14,-0x4(%ebp)
        print_msg("create child:  id=%d", 0);
80000151:	6a 00                	push   $0x0
80000153:	68 d6 01 00 80       	push   $0x800001d6
80000158:	e8 46 ff ff ff       	call   800000a3 <print_msg>
8000015d:	83 c4 08             	add    $0x8,%esp

        char* argv[] = {"arg0", "arg1", "arg2", "arg3"};
80000160:	c7 45 e4 eb 01 00 80 	movl   $0x800001eb,-0x1c(%ebp)
80000167:	c7 45 e8 f0 01 00 80 	movl   $0x800001f0,-0x18(%ebp)
8000016e:	c7 45 ec f5 01 00 80 	movl   $0x800001f5,-0x14(%ebp)
80000175:	c7 45 f0 fa 01 00 80 	movl   $0x800001fa,-0x10(%ebp)
        execve("/shell.elf", argv, (char**)0);
8000017c:	6a 00                	push   $0x0
8000017e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
80000181:	50                   	push   %eax
80000182:	68 ff 01 00 80       	push   $0x800001ff
80000187:	e8 5a ff ff ff       	call   800000e6 <execve>
8000018c:	83 c4 0c             	add    $0xc,%esp
8000018f:	eb 27                	jmp    800001b8 <first_task_main+0xa5>

    } else {
        count += 1000;
80000191:	81 45 fc e8 03 00 00 	addl   $0x3e8,-0x4(%ebp)
        print_msg("child task  :  id=%d", pid);
80000198:	ff 75 f4             	pushl  -0xc(%ebp)
8000019b:	68 0a 02 00 80       	push   $0x8000020a
800001a0:	e8 fe fe ff ff       	call   800000a3 <print_msg>
800001a5:	83 c4 08             	add    $0x8,%esp
        print_msg("parent      :  id=%d", pare_pid);
800001a8:	ff 75 f8             	pushl  -0x8(%ebp)
800001ab:	68 1f 02 00 80       	push   $0x8000021f
800001b0:	e8 ee fe ff ff       	call   800000a3 <print_msg>
800001b5:	83 c4 08             	add    $0x8,%esp
    }

    for(;;) {

        //print_msg("current id=%d", pid);
        msleep(1000);
800001b8:	68 e8 03 00 00       	push   $0x3e8
800001bd:	e8 9c fe ff ff       	call   8000005e <msleep>
800001c2:	83 c4 04             	add    $0x4,%esp
800001c5:	eb f1                	jmp    800001b8 <first_task_main+0xa5>
800001c7:	66 6f                	outsw  %ds:(%esi),(%dx)
800001c9:	72 6b                	jb     80000236 <first_task_main+0x123>
800001cb:	20 66 61             	and    %ah,0x61(%esi)
800001ce:	69 6c 65 64 20 25 64 	imul   $0x642520,0x64(%ebp,%eiz,2),%ebp
800001d5:	00 
800001d6:	63 72 65             	arpl   %si,0x65(%edx)
800001d9:	61                   	popa   
800001da:	74 65                	je     80000241 <first_task_main+0x12e>
800001dc:	20 63 68             	and    %ah,0x68(%ebx)
800001df:	69 6c 64 3a 20 20 69 	imul   $0x64692020,0x3a(%esp,%eiz,2),%ebp
800001e6:	64 
800001e7:	3d 25 64 00 61       	cmp    $0x61006425,%eax
800001ec:	72 67                	jb     80000255 <first_task_main+0x142>
800001ee:	30 00                	xor    %al,(%eax)
800001f0:	61                   	popa   
800001f1:	72 67                	jb     8000025a <first_task_main+0x147>
800001f3:	31 00                	xor    %eax,(%eax)
800001f5:	61                   	popa   
800001f6:	72 67                	jb     8000025f <first_task_main+0x14c>
800001f8:	32 00                	xor    (%eax),%al
800001fa:	61                   	popa   
800001fb:	72 67                	jb     80000264 <first_task_main+0x151>
800001fd:	33 00                	xor    (%eax),%eax
800001ff:	2f                   	das    
80000200:	73 68                	jae    8000026a <first_task_main+0x157>
80000202:	65 6c                	gs insb (%dx),%es:(%edi)
80000204:	6c                   	insb   (%dx),%es:(%edi)
80000205:	2e 65 6c             	cs gs insb (%dx),%es:(%edi)
80000208:	66 00 63 68          	data16 add %ah,0x68(%ebx)
8000020c:	69 6c 64 20 74 61 73 	imul   $0x6b736174,0x20(%esp,%eiz,2),%ebp
80000213:	6b 
80000214:	20 20                	and    %ah,(%eax)
80000216:	3a 20                	cmp    (%eax),%ah
80000218:	20 69 64             	and    %ch,0x64(%ecx)
8000021b:	3d 25 64 00 70       	cmp    $0x70006425,%eax
80000220:	61                   	popa   
80000221:	72 65                	jb     80000288 <first_task_main+0x175>
80000223:	6e                   	outsb  %ds:(%esi),(%dx)
80000224:	74 20                	je     80000246 <first_task_main+0x133>
80000226:	20 20                	and    %ah,(%eax)
80000228:	20 20                	and    %ah,(%eax)
8000022a:	20 3a                	and    %bh,(%edx)
8000022c:	20 20                	and    %ah,(%eax)
8000022e:	69                   	.byte 0x69
8000022f:	64                   	fs
80000230:	3d                   	.byte 0x3d
80000231:	25                   	.byte 0x25
80000232:	64                   	fs
	...
